<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="dora is my precious">
<meta name="keywords" content="java golang">
<meta property="og:type" content="website">
<meta property="og:title" content="迷途小书童">
<meta property="og:url" content="http://stevenhoukai.github.io/index.html">
<meta property="og:site_name" content="迷途小书童">
<meta property="og:description" content="dora is my precious">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="迷途小书童">
<meta name="twitter:description" content="dora is my precious">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://stevenhoukai.github.io/">





  <title>迷途小书童</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">迷途小书童</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">读过几年书，尘世间一枚不起眼的小书童</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stevenhoukai.github.io/2021/10/10/20211010-guitar/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="steven Hou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/upload/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/10/10/20211010-guitar/" itemprop="url">和弦的构成（分析）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-10-10T00:00:01+08:00">
                2021-10-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/乐理/" itemprop="url" rel="index">
                    <span itemprop="name">乐理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>弹了有段时间的吉他的，一直对吉他乐理方面没有做一个系统的分析，今天来对常用3和弦和7和弦做一个完整的分析以及公式总结</p>
<h2 id="3和弦"><a href="#3和弦" class="headerlink" title="3和弦"></a>3和弦</h2><ul>
<li><p>大3和弦（大三度+小三度）</p>
<p>例如：<br>C和弦 组成音： 1 &lt;大三度&gt; 3 &lt;小三度&gt; 5<br>D和弦 组成音： 2 &lt;大三度&gt; 4(#) &lt;小三度&gt; 6 </p>
<p>同理可推导<br>G和弦 组成音：5 &lt;大三度&gt; 7 &lt;小三度&gt; 2^</p>
</li>
<li><p>小3和弦（小三度+大三度）</p>
<p>例如：<br>Cm和弦 组成音： 1 &lt;小三度&gt; 3(b) &lt;大三度&gt; 5<br>Dm和弦 组成音： 2 &lt;小三度&gt; 4 &lt;大三度&gt; 6</p>
<p>同理可以推导</p>
<p>Gm和弦 组成音： 5 &lt;小三度&gt; 7(b) &lt;大三度&gt; 2^</p>
</li>
<li><p>增3和弦（大三度+大三度）</p>
<p>例如：C+或者 Caug</p>
</li>
<li><p>减3和弦（小三度+小三度）</p>
<p>例如：C- 或者 Cdim</p>
</li>
</ul>
<h2 id="7和弦"><a href="#7和弦" class="headerlink" title="7和弦"></a>7和弦</h2><p>记得看中国好声音时，李荣浩说leehom的《爱错》中的bridge中那句在这少了你的世界那里的7减5和弦让他头皮发麻，这就来看看啥是7减5和弦，其实那时说7减5的时候王力宏是懵逼的，专业叫法应该叫半减7和弦。</p>
<ul>
<li><p>大小7和弦（属7和弦）（大三和弦+小7度）[小7度就是包含两个半音，大7度就是包含一个半音]</p>
<p>例如：</p>
<p>C7和弦组成音本质就是 C和弦+小7度（1 3 5 + 7(b)）</p>
<p>F7和弦组成音本质就是 F和弦+小7度（4 6 1^ + 3^(b)）</p>
</li>
<li><p>小7和弦（小三和弦+小7度）</p>
<p>例如：</p>
<p>Cm7和弦的组成音本质就是 Cm和弦+小7度 （1 3(b) 5 7(b)）</p>
</li>
<li><p>大7和弦（大三和弦+大7度）</p>
<p>例如：</p>
<p>Cmaj7和弦组成音本质就是C和弦+大7度（1 3 5 + 7）</p>
<p>Fmaj7和弦组成音本质就是F和弦+大7度 （4 6 1^ 3^）</p>
</li>
<li><p>小大7和弦（小三和弦+大7度）</p>
<p>例如：</p>
<p>Cmmaj7和弦组成音本质就是Cm和弦+大7度（1 3(b) 5 7）</p>
</li>
<li><p>半减7和弦</p>
<p>例如：</p>
<p>Bm7-5 这个和弦就是上面说到的让李荣浩头皮发麻的7-5和弦了，没错这种和弦的收缩性非常强，用到合适的地方确实会头皮发麻。</p>
<p>那么这个和弦的本质其实就是Bm和弦(7 2^ 4^(#) + 小7度 + 5音降半音 ( 7 2^ 4^ 6^)</p>
<p>所以通过公式我们也可以推到出Ammaj7-5和弦的组成音了，哈哈哈 虽然这个和弦不一定存在。</p>
</li>
</ul>
<h2 id="和弦色彩"><a href="#和弦色彩" class="headerlink" title="和弦色彩"></a>和弦色彩</h2><p>今天不打算对和弦色彩进行总结，但是要提一句的是，和弦色彩对于编配来说实在是太重要了，就好像一首歌你可以用4536251去完成，你也可以用分割和弦 5/4去代替其中的5，但是两者表达出来的色彩是完全不一样的。后面会对和弦色彩进行一次详细的记录。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>像我这种业余玩流行音乐的，和弦其实是一个非常重要的理论基础，就像我们写程序你要写好代码就一定要懂原理，老实说其实掌握一些和弦套路例如6451，4536251还有17654325(卡农和弦)低音下行这些后基本上流行乐坛百分之70的歌你都能弹唱了，无非就是一首换一首，就像你你做开发选用的是dubbo框架还是springcloud框架一样。但是如果想玩的更有趣一点就需要去了解这些框架的构成原理了。</p>
<p><img src="/2021/10/10/20211010-guitar/6.jpg" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stevenhoukai.github.io/2021/10/08/20211008-cdk/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="steven Hou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/upload/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/10/08/20211008-cdk/" itemprop="url">如何搭建一个高性能cdk系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-10-08T00:00:01+08:00">
                2021-10-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工作沉淀/" itemprop="url" rel="index">
                    <span itemprop="name">工作沉淀</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本人前不久稍稍改进了一个cdkey系统，来总结下是如何设计一个cdkey(兑换码)系统的，本文打算从以下三个方面来说。</p>
<ul>
<li>cdkey兑换</li>
<li>如何生成cdkey以及如何存储</li>
<li>如何保证高可用</li>
</ul>
<h2 id="cdkey兑换"><a href="#cdkey兑换" class="headerlink" title="cdkey兑换"></a>cdkey兑换</h2><p>cdkey本身只是一种推广售卖方式，其实不用也是可以的，不过市面上的商品一般除了正常的收费购买之外一定会伴随有cdkey售卖这样的方式。一个cdkey就对应着一个具体的商品，这也意味着cdkey是需要与商品以及订进行绑定的，举个例子，类似这样的一串字符串XXX3XXXNLMX1YEXXX就是cdkey的一个样式，是一个36进制构成的16位表达式，一般先由系统提前生成好然后下发出去售卖或者活动赠送等，兑换的时候做一些校验工作然后是生成订单流程，订单流程走完之后最后将订单号与cdkey绑定并将其状态更改成已兑换。流程如下图:</p>
<p>流程图因涉及到公司的业务流转 不方便在此贴出</p>
<h2 id="如何生成cdkey以及如何存储"><a href="#如何生成cdkey以及如何存储" class="headerlink" title="如何生成cdkey以及如何存储"></a>如何生成cdkey以及如何存储</h2><p>上一节提到目前系统的cdkey是一个36进制的16位表达式，针对36进制我们可以预先定义一个数组：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">myVal = []<span class="keyword">string</span>&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>, <span class="string">"K"</span>, <span class="string">"L"</span>, <span class="string">"M"</span>, <span class="string">"N"</span>, <span class="string">"O"</span>, <span class="string">"P"</span>,<span class="string">"Q"</span>, <span class="string">"R"</span>, <span class="string">"S"</span>, <span class="string">"T"</span>, <span class="string">"U"</span>, <span class="string">"V"</span>, <span class="string">"W"</span>, <span class="string">"X"</span>, <span class="string">"Y"</span>, <span class="string">"Z"</span>,<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>&#125;</span><br><span class="line"><span class="comment">//生成一个cdk的代码，所以是有可能一批cdk里面产生重复的，必须做好本地去重</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genOneKey</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	buf.Reset()</span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">16</span>; j++ &#123;</span><br><span class="line">		val := rand.Intn(<span class="built_in">len</span>(myVal))</span><br><span class="line">		buf.WriteString(myVal[val])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然为了安全我们也可以将上述的数组顺序随意打乱，这种方式在上一篇短链系统设计的时候已经用过一次了，只不过短链用的是64进制而已。我们也可以使用64进制来降低cdkey生成时的碰撞率，不过就cdkey而言为了美观一般就不掺杂小写字母了。本人目前的需求是需要支持大批量cdk申请的，单批次申请需要支持10w，所以我这边cdkey的生成实际是按批次生成的，这样的好处就是可以减少与数据库的网络IO，每次生成一批cdkey然后去数据库校验是否存在，存在了就重试生成一批新cdkey再校验，直到校验不存在就插入数据库然后生成下一批，反复执行直到申请数量全部生成完毕。</p>
<p>总体流程图如下：</p>
<p><img src="/2021/10/08/20211008-cdk/2.png" alt></p>
<p>接下来是单批次生成cdk详细逻辑:</p>
<p><img src="/2021/10/08/20211008-cdk/3.png" alt></p>
<p>给出表设计方案 : </p>
<p>下面的表中很多字段都是与具体业务相关的，不必过于关心，但是核心的字段在一个cdk系统中基本上都是不变的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//因为表设计也有相关敏感信息不方便在此处贴出具体字段</span><br><span class="line">//cdk订单申请表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`cdk_order`</span> (</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COMMENT</span>=<span class="string">'cdk申请单表'</span></span><br><span class="line"></span><br><span class="line">//cdk详情表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`cdk_detail`</span> (</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COMMENT</span>=<span class="string">'cdk明细表'</span></span><br></pre></td></tr></table></figure>

<h2 id="如何保证高可用"><a href="#如何保证高可用" class="headerlink" title="如何保证高可用"></a>如何保证高可用</h2><p>一般来说通过集群部署可解决系统高可用问题，但是集群部署就会导致新的问题，可能两个服务节点同时工作产生的cdkey就有可能会出现交集本地去重并不能解决问题，这里我列出了两种方案来解决这个问题，就当前情况而言本人采用了第一种方案:</p>
<ul>
<li><p>方案一：通过数据库自身来解决该问题</p>
<p>上一节介绍的方案就是了，通过数据库校验 + 事务 + 重试来解决</p>
</li>
<li><p>方案二：通过分布式锁+bloomfilter来解决这个问题</p>
<p>见方案设计图:</p>
<p><img src="/2021/10/08/20211008-cdk/4.png" alt></p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对cdk系统设计方案作了一点总结，整体的思路就是要减少碰撞，保证申请数量与实际生成数量一致，并且要防止一次性提交数据量过大，具体最后的高可用方案哪种更合适还是依据实际情况再做定夺为佳。</p>
<p><img src="/2021/10/08/20211008-cdk/5.jpg" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stevenhoukai.github.io/2021/09/27/20210927-shorturl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="steven Hou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/upload/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/09/27/20210927-shorturl/" itemprop="url">高性能短链系统的一些设计思考</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-09-27T00:00:01+08:00">
                2021-09-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工作沉淀/" itemprop="url" rel="index">
                    <span itemprop="name">工作沉淀</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近遇到一个需求，需要短时间内将大量的长链转换成短链然后再转成二维码，由于我们的短链服务是通过接口外部进行调用的，而且不能批量转换，所以这里就会出现一个情况就是短时间的大量请求接口会以失败告终，如果能自己设计一个短链系统，这个问题就能解决了。那么今天就来谈谈如何设计一个高性能短链系统。</p>
<p>本文将会从以下几个方面来进行探讨 </p>
<ul>
<li>为啥要用短链 长链存在哪些问题</li>
<li>短链是如何实现跳转的</li>
<li>如何生成短链以及如何存储</li>
<li>如何保证高性能高可用</li>
</ul>
<h2 id="为啥要用短链-长链存在哪些问题"><a href="#为啥要用短链-长链存在哪些问题" class="headerlink" title="为啥要用短链 长链存在哪些问题"></a>为啥要用短链 长链存在哪些问题</h2><p>下面是自如给我发的推送短信，点击下方蓝色的链接（短链）</p>
<p><img src="/2021/09/27/20210927-shorturl/1.png" alt="img"></p>
<p>浏览器接着会跳转到一个确认跳转页面。</p>
<p><img src="/2021/09/27/20210927-shorturl/2.jpeg" alt="img"></p>
<p>那么为啥要用短链表示，直接用长链不行吗，用短链的话有如下好外</p>
<p>1、链接变短，在对内容长度有限制的平台发文，可编辑的文字就变多了</p>
<p>最典型的就是微博，限定了只能发 140 个字，如果一串长链直接怼上去，其他可编辑的内容就所剩无几了，用短链的话，链接长度大大减少，自然可编辑的文字多了不少。</p>
<p>再比如上面的短信如果一个长链直接怼上去满屏都是一个链接，非常不美观。</p>
<p>2、像我前言中的需求需要将链接转成二维码，如果是长链的话二维码非常密集而且很难识别，短链的话就会清爽很多,如下图所示</p>
<p><img src="/2021/09/27/20210927-shorturl/3.png" alt="img"></p>
<p>3、链接太长在有些平台上无法自动识别为超链接</p>
<h2 id="短链是如何实现跳转的"><a href="#短链是如何实现跳转的" class="headerlink" title="短链是如何实现跳转的"></a>短链是如何实现跳转的</h2><p>从上文可知，短链好处多多，那么它是如何工作的呢。我们在浏览器抓下包看看</p>
<p><img src="/2021/09/27/20210927-shorturl/10.png" alt="img"></p>
<p>可以看到请求后，返回了状态码 302（重定向）与 location 值为长链的响应，然后浏览器会再请求这个长链以得到最终的响应,整个交互流程图如下</p>
<p><img src="/2021/09/27/20210927-shorturl/11.png" alt="img"></p>
<p>主要步骤就是访问短网址后重定向访问 B，那么问题来了，301 和 302 都是重定向，到底该用哪个，这里需要注意一下 301 和 302 的区别</p>
<ul>
<li>301，代表 <strong>永久重定向</strong>，也就是说第一次请求拿到长链接后，下次浏览器再去请求短链的话，不会向短网址服务器请求了，而是直接从浏览器的缓存里拿，这样在 server 层面就无法获取到短网址的点击数了，如果这个链接刚好是某个活动的链接，也就无法分析此活动的效果。所以我们一般不采用 301。</li>
<li><strong>302</strong>，代表 <strong>临时重定向</strong>，也就是说每次去请求短链都会去请求短网址服务器（除非响应中用 Cache-Control 或 Expired 暗示浏览器缓存）,这样就便于 server 统计点击数，所以虽然用 302 会给 server 增加一点压力，但在数据异常重要的今天，这点代码是值得的，所以推荐使用 302！</li>
</ul>
<h2 id="如何生成短链以及如何存储"><a href="#如何生成短链以及如何存储" class="headerlink" title="如何生成短链以及如何存储"></a>如何生成短链以及如何存储</h2><h3 id="1、Hash"><a href="#1、Hash" class="headerlink" title="1、Hash"></a>1、Hash</h3><p>短链怎么生成，我的第一反应,这不就是以不定长输入(长链)转换成定长输出(短链)【哈希的定义】，观察上面的短链很明显可以看到短链是由固定短链域名 + 长链映射成的一串字母组成(不定长输入–&gt;定长输出)，那么这个哈希函数该怎么取呢，相信肯定有很多人说用 MD5，SHA 等算法，网上确实有很多是用md5先生成32位串，然后均分4段做hash处理，最后再随机取其中之一作为最后结果，只是我在想这个md5先生成32位串是否一定有必要，而且既然是加密就意味着性能上会有损失，其实我觉得这里的重点应该是hash并不是加解密，如何提升哈希的运算速度和减少冲突概率才是重点。以下属于借鉴内容了这里推荐 Google 出品的 <strong>MurmurHash 算法</strong>，MurmurHash 是一种<strong>非加密型</strong>哈希函数，适用于一般的哈希检索操作。与其它流行的哈希函数相比，对于规律性较强的 key，MurmurHash 的随机分布特征表现更良好。非加密意味着着相比 MD5，SHA 这些函数它的性能肯定更高（实际上性能是 MD5 等加密算法的十倍以上），也正是由于它的这些优点，所以虽然它出现于 2008，但目前已经广泛应用到 Redis、MemCache、Cassandra、HBase、Lucene 等众多著名的软件中。</p>
<p>MurmurHash 提供了两种长度的哈希值，32 bit，128 bit，为了让网址尽可通地短，我们选择 32 bit 的哈希值，<strong>32 bit 能表示的最大值近 43 亿</strong>，对于中小型公司的业务而言绰绰有余。对上文提到的极客长链做 MurmurHash 计算，得到的哈希值为 3002604296，于是我们现在得到的短链为 固定短链域名+哈希值 = <a href="http://xxx.com/a/3002604296" target="_blank" rel="noopener">http://xxx.com/a/3002604296</a></p>
<p><strong>上述结果还是有点长？</strong></p>
<p>觉得10位的短链还是有点长怎么办？首先3002604296 这个结果是10进制数字，有一种方案就是将它转为 62 进制就可以缩短它的长度，10 进制转 62 进制如下，也就是按62取模，对应的余数在下面的字符串中取对应值：</p>
<p>62进制思路 : 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</p>
<p><img src="/2021/09/27/20210927-shorturl/7.png" alt="img"></p>
<p>经过上面的取模运算然后取映射值，就可以将(3002604296)10进制数字转换成 (3hcCxy)62进制，立马又缩短了4位，因此最终的短链为 <a href="http://xxx.com/a/3hcCxy，6" target="_blank" rel="noopener">http://xxx.com/a/3hcCxy，6</a> 位 62 进制数可表示 568 亿的数，应付长链转换绰绰有余，如果需要更短一点也是可以的，根据实际需求进行取舍吧，我们公司目前用的是8位<a href="https://xxx.com/r8CpSjCN" target="_blank" rel="noopener">https://xxx.com/r8CpSjCN</a></p>
<p><strong>hash冲突了怎么办？</strong></p>
<p>既然是哈希函数，那么很有可能两个不同的长链经过hash之后生成的短链是一样的，那么这个问题要怎么解决？这里给出的思路就是在长链的基础上添加随机字符串然后重试生成短链。</p>
<p>由上文知道访问短链能跳转到长链，那么长短链的关系一定是有一个地方存储的， <strong>Redis 或 Mysql</strong> ？，一般来说 Mysql 存储首选，redis缓存首选。表结构如下所示</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`long_short_url_map`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`long_url`</span> <span class="built_in">varchar</span>(<span class="number">160</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'长链'</span>,</span><br><span class="line">  <span class="string">`short_url`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'短链'</span>,</span><br><span class="line">  <span class="string">`created_at`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span></span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<p>基于上面的组件可以做出如下的设计。</p>
<ol>
<li>长链（longurl）经过 MurmurHash 后取模62得到最终短链。</li>
<li>再根据短链去 long_short_url_map 表中查找看是否存在相关记录，如果不存在，将长链与短链对应关系插入数据库中，存储。</li>
<li><strong>如果存在，说明已经有相关记录了，此时在长串上拼接一个自定义好的字段，比如「duplicate+RandomNum」，「longurl + duplicate+RandomNum」去重试第一步操作，如果最后还是重复就继续重拾，如果没有重复了就把原longurl和短链的关系存储即可</strong>。</li>
</ol>
<p>上面的步骤是没有加入缓存的，插入一条记录是需要经过两次(甚至三次(概率微乎其微)) sql 查询（1.根据短链查记录是否存在 2.将长短链对应关系插入数据库中），像我前言中的需求在高并发下，明显还是会有瓶颈出现的。一般数据库和应用服务（只做计算不做存储）会部署在两台不同的 server 上，执行两条 sql 就需要两次网络通信，<strong>这两次网络通信与两次 sql 执行是整个短链系统的性能瓶颈所在</strong>！</p>
<p>引入缓存减少第一次的sql查询？</p>
<p>很显然插入数据那一次的sql肯定没跑了，无论怎样那一次的sql都是要执行的</p>
<ol>
<li>方案一 : 给短链字段 short_url 加上<strong>唯一索引</strong>，把唯一性校验直接交给数据库去做，可行但是数据库压力很大（唯一索引懂的都懂）</li>
<li>方案二 : 数据量很大的情况下，冲突的概率会增大，此时我们可以使用加<strong>Bloomfilter</strong>(缓存)来进行优化。</li>
</ol>
<p><strong>用所有生成的短网址构建布隆过滤器</strong>，当一个新的长链生成短链后，先将此短链在Bloomfilter中进行查找，如果不存在，说明 db 里不存在此短网址，可以插入，插入db之前先将短链放入Bloomfilter。Bloomfilter是一种非常省内存的数据结构，长度为 10 亿的布隆过滤器，只需要 125 M 的内存空间。</p>
<p>综上，如果用哈希函数来设计，总体的设计思路如下</p>
<p><img src="/2021/09/27/20210927-shorturl/5.png" alt="img"></p>
<p>用哈希算法生成的短链其实已经能满足我们的业务需求，本人目前工作中遇到的短链就是用hash生成的只不过保留的是8位。其实还有另外一种是通过自增序列</p>
<h3 id="2、Sequence"><a href="#2、Sequence" class="headerlink" title="2、Sequence"></a>2、Sequence</h3><p>待完善</p>
<h2 id="高性能短链的架构设计"><a href="#高性能短链的架构设计" class="headerlink" title="高性能短链的架构设计"></a>高性能短链的架构设计</h2><p>在电商公司，经常有很多活动，秒杀，抢红包等等，在某个时间点的 QPS 会很高，考虑到这种情况，可以引入了 <strong>openResty</strong>，它是一个基于 Nginx 与 Lua 的高性能 Web 平台，由于 Nginx 的非阻塞 IO 模型，使用 openResty 可以轻松支持 100 w + 的并发数，一般情况下你只要部署一台即可，不过为了避免单点故障，两台为宜，同时 openResty 也自带了缓存机制，集成了 redis 这些缓存模块，也可以直接连 mysql。不需要再通过业务层连这些中间件，性能自然会高不少</p>
<p><img src="/2021/09/27/20210927-shorturl/6.png" alt="img"></p>
<p>上图所示，使用 openResty 可以直接跳过了业务层这一步，直达缓存层与数据库层，对性能也有大量提升。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对短链设计方案作了一点总结，文中涉及到像Bloomfilter，openResty 等技术，后续再去详细讨论。值得说明的是Bloomfilter的确是一个强大的缓存层有必要好好学习一番。</p>
<p><img src="/2021/09/27/20210927-shorturl/6.jpg" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stevenhoukai.github.io/2021/09/14/20210914-goroutinepoolcpubug/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="steven Hou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/upload/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/09/14/20210914-goroutinepoolcpubug/" itemprop="url">自定义简易协程池踩坑记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-09-14T00:00:01+08:00">
                2021-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Golang/" itemprop="url" rel="index">
                    <span itemprop="name">Golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇文章中完善了一个自定义协程池，正所谓不改就没事，哈哈，果然上周测试环境发版后就出问题了，本人的服务的健康检查一发新版本之后就会立马unhealthy，然后先是观察容器cpu负载竟然是100%，好家伙，登陆容器通过top命令确定了就是自己的服务导致的，然后检查了自己修改过的代码，经过半天的排查果然找到了这个病因。</p>
<h2 id="代码展示（问题代码部分）"><a href="#代码展示（问题代码部分）" class="headerlink" title="代码展示（问题代码部分）"></a>代码展示（问题代码部分）</h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行一个groutine 开始消费任务 核心的问题就出在了下面这个方法内 </span></span><br><span class="line"><span class="comment">//for循环中嵌套了select 然后通过关闭通道进行跳出</span></span><br><span class="line"><span class="comment">//然而我之前的跳出用的是break，这里就是关键了</span></span><br><span class="line"><span class="comment">//break只能是跳出当前select，外层的for循环还是继续走的，然后就进入了死循环了</span></span><br><span class="line">func (self *Pool) runGroutine() &#123; // runningWorkers + 1</span><br><span class="line">	self.incRunningWorkers() //worker运行ing数量原子自增1</span><br><span class="line">	go func() &#123;</span><br><span class="line">		defer func() &#123;</span><br><span class="line">			self.decRunningWorkers() //worker运行ing数量原子自减1</span><br><span class="line">			if r := recover(); r != nil &#123;</span><br><span class="line">				<span class="comment">// if self.PanicHandler != nil &#123;</span></span><br><span class="line">				<span class="comment">// 	self.PanicHandler(r)</span></span><br><span class="line">				<span class="comment">// &#125; else &#123;</span></span><br><span class="line">				<span class="comment">// 	log.Printf("Worker panic: %s\n", r)</span></span><br><span class="line">				<span class="comment">// &#125;</span></span><br><span class="line">				err := errs.New(Panic_Sub_Goroutine, "子协程panic") //子协程panic是会导致主协程挂掉的，这一步也是必须进行捕获处理</span><br><span class="line">				self.ResultQuene &lt;- err</span><br><span class="line">			&#125;</span><br><span class="line">			self.checkWorker<span class="comment">()</span> <span class="comment">// 兜底机制，避免worker全部panic后没有worker消费队列中的数据,理论上这一步非常重要！否则有可能出现死锁状态</span></span><br><span class="line">		&#125;<span class="comment">()</span></span><br><span class="line">		for &#123;</span><br><span class="line">			select &#123;</span><br><span class="line">			case task, ok := &lt;-self.TaskQueue:</span><br><span class="line">				<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				  <span class="comment">//break</span></span><br><span class="line">					return //这里不要用break  break只能跳出一层第二层的for循环还会继续 会直接把cpu打满</span><br><span class="line">				&#125;</span><br><span class="line">				err := task<span class="comment">()</span></span><br><span class="line">				self.ResultQuene &lt;- err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="comment">()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好在是在测试环境发布时发现了这样的问题，如果是线上出现该问题还是比较麻烦的，总结就是对select的一些用法还是不够熟悉，下一篇文章就来对golang中的select用法进行一下总结<a href="https://stevenhoukai.github.io/2021/09/14/20210914-goroutineselect/"><strong>（点此处了解select用法总结）</strong></a>。</p>
<p><img src="/2021/09/14/20210914-goroutinepoolcpubug/6.jpg" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stevenhoukai.github.io/2021/09/14/20210914-goroutineselect/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="steven Hou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/upload/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/09/14/20210914-goroutineselect/" itemprop="url">go的select用法总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-09-14T00:00:01+08:00">
                2021-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Golang/" itemprop="url" rel="index">
                    <span itemprop="name">Golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>沿着上一篇留下来的问题继续说，来总结下golang中的select的一些用法，避免后续踩坑。</p>
<p>首先golang中的select语句格式如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch1:</span><br><span class="line">        <span class="comment">// 如果从 ch1 信道成功接收数据，则执行该分支代码</span></span><br><span class="line">    <span class="keyword">case</span> ch2 &lt;- <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// 如果成功向 ch2 信道成功发送数据，则执行该分支代码</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 如果上面都没有成功，则进入 default 分支处理流程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　</p>
<p>直观上跟switch确实是有点相似的，但实际上两者有着本质上的区别。</p>
<p>select里的case后面并不带判断条件，而是一个信道的操作，不同于switch里的case，对于从其它语言转过来的开发者来说有些需要特别注意的地方。</p>
<p>golang 的 select 就是监听 IO 操作，当 IO 操作发生时，触发相应的动作每个case语句里必须是一个IO操作，确切的说，应该是一个面向channel的IO操作。</p>
<blockquote>
<p>注：Go 语言的 <code>select</code> 语句借鉴自 Unix 的 <code>select()</code> 函数，在 Unix 中，可以通过调用 <code>select()</code> 函数来监控一系列的文件句柄，一旦其中一个文件句柄发生了 IO 动作，该 <code>select()</code> 调用就会被返回（C 语言中就是这么做的），后来该机制也被用于实现高并发的 Socket 服务器程序。Go 语言直接在语言级别支持 <code>select</code>关键字，用于处理并发编程中通道之间异步 IO 通信问题。</p>
</blockquote>
<p>注意：如果 <code>ch1</code> 或者 <code>ch2</code> 信道都阻塞的话，就会立即进入 <code>default</code> 分支，并不会阻塞。但是如果没有 <code>default</code> 语句，则会阻塞直到某个信道操作成功为止。</p>
<h3 id="重要知识点"><a href="#重要知识点" class="headerlink" title="重要知识点"></a>重要知识点</h3><ol>
<li><strong>select语句只能用于信道的读写操作</strong></li>
<li><strong>select中的case条件(非阻塞)是并发执行的，select会选择先操作成功的那个case条件去执行，如果多个同时返回，则随机选择一个执行，此时将无法保证执行顺序。对于阻塞的case语句会直到其中有信道可以操作，如果有多个信道可操作，会随机选择其中一个 case 执行</strong></li>
<li><strong>对于case条件语句中，如果存在信道值为nil的读写操作，则该分支将被忽略，可以理解为从select语句中删除了这个case语句</strong></li>
<li><strong>如果有超时条件语句，判断逻辑为如果在这个时间段内一直没有满足条件的case,则执行这个超时case。如果此段时间内出现了可操作的case,则直接执行这个case。一般用超时语句代替了default语句</strong></li>
<li><strong>对于空的select{}，会引起死锁</strong></li>
<li><strong>对于for中的select{}, 也有可能会引起cpu占用过高的问题</strong></li>
</ol>
<p>下面列出每种情况的示例代码</p>
<h3 id="1-select语句只能用于信道的读写操作"><a href="#1-select语句只能用于信道的读写操作" class="headerlink" title="1. select语句只能用于信道的读写操作"></a>1. select语句只能用于信道的读写操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"> </span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"> </span><br><span class="line">func main() &#123;</span><br><span class="line">    size := 10</span><br><span class="line">    ch := make(chan int, size)</span><br><span class="line">    for i := 0; i &lt; size; i++ &#123;</span><br><span class="line">        ch &lt;- 1</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ch2 := make(chan int, size)</span><br><span class="line">    for i := 0; i &lt; size; i++ &#123;</span><br><span class="line">        ch2 &lt;- 2</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ch3 := make(chan int, 1)</span><br><span class="line"> </span><br><span class="line">    select &#123;</span><br><span class="line">    case 3 == 3:</span><br><span class="line">        fmt.Println(&quot;equal&quot;)</span><br><span class="line">    case v := &lt;-ch:</span><br><span class="line">        fmt.Print(v)</span><br><span class="line">    case b := &lt;-ch2:</span><br><span class="line">        fmt.Print(b)</span><br><span class="line">    case ch3 &lt;- 10:</span><br><span class="line">        fmt.Print(&quot;write&quot;)</span><br><span class="line">    default:</span><br><span class="line">        fmt.Println(&quot;none&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">语句会报错</span><br><span class="line"> </span><br><span class="line">prog.go:20:9: 3 == 3 evaluated but not used</span><br><span class="line">prog.go:20:9: select case must be receive, send or assign recv&lt;br&gt;从错误信息里我们证实了第一点。</span><br></pre></td></tr></table></figure>

<p>　　</p>
<h3 id="2-select中的case语句是随机执行的"><a href="#2-select中的case语句是随机执行的" class="headerlink" title="2. select中的case语句是随机执行的"></a>2. select中的case语句是随机执行的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"> </span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"> </span><br><span class="line">func main() &#123;</span><br><span class="line">    size := 10</span><br><span class="line">    ch := make(chan int, size)</span><br><span class="line">    for i := 0; i &lt; size; i++ &#123;</span><br><span class="line">        ch &lt;- 1</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ch2 := make(chan int, size)</span><br><span class="line">    for i := 0; i &lt; size; i++ &#123;</span><br><span class="line">        ch2 &lt;- 2</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ch3 := make(chan int, 1)</span><br><span class="line"> </span><br><span class="line">    select &#123;</span><br><span class="line">    case v := &lt;-ch:</span><br><span class="line">        fmt.Print(v)</span><br><span class="line">    case b := &lt;-ch2:</span><br><span class="line">        fmt.Print(b)</span><br><span class="line">    case ch3 &lt;- 10:</span><br><span class="line">        fmt.Print(&quot;write&quot;)</span><br><span class="line">    default:</span><br><span class="line">        fmt.Println(&quot;none&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　多次执行的话，会随机输出不同的值，分别为1,2,write。这是因为ch和ch2是并发执行会同时返回数据，所以会随机选择一个case执行，。但永远不会执行default语句，因为上面的三个case都是可以操作的信道。</p>
<h3 id="3-对于case条件语句中，如果存在通道值为nil的读写操作，则该分支将被忽略"><a href="#3-对于case条件语句中，如果存在通道值为nil的读写操作，则该分支将被忽略" class="headerlink" title="3. 对于case条件语句中，如果存在通道值为nil的读写操作，则该分支将被忽略"></a>3. 对于case条件语句中，如果存在通道值为nil的读写操作，则该分支将被忽略</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"> </span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"> </span><br><span class="line">func main() &#123;</span><br><span class="line">    var ch chan int</span><br><span class="line">    // ch = make(chan int)</span><br><span class="line">     </span><br><span class="line">    go func(c chan int) &#123;</span><br><span class="line">        c &lt;- 100</span><br><span class="line">    &#125;(ch)</span><br><span class="line"> </span><br><span class="line">    select &#123;</span><br><span class="line">    case &lt;-ch:</span><br><span class="line">        fmt.Print(&quot;ok&quot;)</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">报错</span><br><span class="line"> </span><br><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"> </span><br><span class="line">goroutine 1 [select (no cases)]:</span><br><span class="line">main.main()</span><br><span class="line">    /tmp/sandbox488456896/main.go:14 +0x60</span><br><span class="line"> </span><br><span class="line">goroutine 5 [chan send (nil chan)]:</span><br><span class="line">main.main.func1(0x0, 0x1043a070)</span><br><span class="line">    /tmp/sandbox488456896/main.go:10 +0x40</span><br><span class="line">created by main.main</span><br><span class="line">    /tmp/sandbox488456896/main.go:9 +0x40</span><br><span class="line">可以看到 “goroutine 1 [select (no cases)]” ，虽然写了case条件，但操作的是nil通道，被优化掉了。</span><br><span class="line">要解决这个问题，只能使用make()进行初始化才可以。</span><br></pre></td></tr></table></figure>

<p>　　</p>
<h3 id="4-超时用法"><a href="#4-超时用法" class="headerlink" title="4. 超时用法"></a>4. 超时用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"> </span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">func main() &#123;</span><br><span class="line">    ch := make(chan int)</span><br><span class="line">    go func(c chan int) &#123;</span><br><span class="line">        // 修改时间后,再查看执行结果</span><br><span class="line">        time.Sleep(time.Second * 1)</span><br><span class="line">        ch &lt;- 1</span><br><span class="line">    &#125;(ch)</span><br><span class="line"> </span><br><span class="line">    select &#123;</span><br><span class="line">    case v := &lt;-ch:</span><br><span class="line">        fmt.Print(v)</span><br><span class="line">    case &lt;-time.After(2 * time.Second): // 等待 2s</span><br><span class="line">        fmt.Println(&quot;no case ok&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    time.Sleep(time.Second * 10)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">我们通过修改上面的时等待时间可以看到，如果等待时间超出&lt;2秒，则输出1，否则打印“no case ok”</span><br></pre></td></tr></table></figure>

<p>　　</p>
<h3 id="5-空select"><a href="#5-空select" class="headerlink" title="5. 空select{}"></a>5. 空select{}</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"> </span><br><span class="line">func main() &#123;</span><br><span class="line">    select &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">goroutine 1 [select (no cases)]:</span><br><span class="line">main.main()</span><br><span class="line">/root/project/practice/mytest/main.go:10 +0x20</span><br><span class="line">exit status 2</span><br><span class="line">直接死锁</span><br></pre></td></tr></table></figure>

<p>　　</p>
<h3 id="6-for中的select-引起的CPU过高的问题（上一篇踩坑记录中就是这个问题）"><a href="#6-for中的select-引起的CPU过高的问题（上一篇踩坑记录中就是这个问题）" class="headerlink" title="6. for中的select 引起的CPU过高的问题（上一篇踩坑记录中就是这个问题）"></a>6. for中的select 引起的CPU过高的问题（上一篇踩坑记录中就是这个问题）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"> </span><br><span class="line">import (</span><br><span class="line">    &quot;runtime&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">func main() &#123;</span><br><span class="line">    quit := make(chan bool)</span><br><span class="line">    for i := 0; i != runtime.NumCPU(); i++ &#123;</span><br><span class="line">        go func() &#123;</span><br><span class="line">            for &#123;</span><br><span class="line">                select &#123;</span><br><span class="line">                case &lt;-quit:</span><br><span class="line">                    break</span><br><span class="line">                default:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    time.Sleep(time.Second * 15)</span><br><span class="line">    for i := 0; i != runtime.NumCPU(); i++ &#123;</span><br><span class="line">        quit &lt;- true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　</p>
<p>上面这段代码会把所有CPU都跑满，原因就就在<code>select</code>的用法上。</p>
<p>一般来说，我们用<code>select</code>监听各个<code>case</code>的IO事件，每个<code>case</code>都是阻塞的。上面的例子中，我们希望<code>select</code>在获取到<code>quit</code>通道里面的数据时立即退出循环，但由于他在for{}里面，在第一次读取quit后，仅仅退出了select{}，并未退出for，所以下次还会继续执行select{}逻辑，此时永远是执行default，直到<code>quit</code>通道里读到数据，否则会一直在一个死循环中运行，即使放到一个<code>goroutine</code>里运行，也是会占满所有的CPU。</p>
<p>解决方法我这里总结了有三种方案：</p>
<p><strong>1.使用break + 标示位置 相当于 使用goto 跳出for循环 。</strong></p>
<p><strong>2.使用return代替break 直接结束子goroutine 。</strong></p>
<p><strong>3.使用flag，二次break跳出for循环。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们在使用每一句代码时都需要时刻保持敬畏之心，先将其原理用法都弄清楚然后再投入使用是我们开发工程师应该时刻保持的原则。谨记～</p>
<p><img src="/2021/09/14/20210914-goroutineselect/6.jpg" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stevenhoukai.github.io/2021/09/03/20210903-goroutinepool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="steven Hou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/upload/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/09/03/20210903-goroutinepool/" itemprop="url">简易协程池</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-09-03T00:00:01+08:00">
                2021-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Golang/" itemprop="url" rel="index">
                    <span itemprop="name">Golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Go 的 goroutine 提供了一种较线程而言更廉价的方式处理并发场景, go 使用二级线程的模式, 将 goroutine 以 M:N 的形式复用到系统线程上, 节省了 cpu 调度的开销, 也避免了用户级线程（协程）进行系统调用时阻塞整个系统线程的问题。</p>
<p>但在实际的开发中如果待执行的tasks数量过多，可能带来的问题就是goroutine数量激增进而导致调度性能下降、GC 频繁、内存暴涨, 引发一系列问题。在面临这样的场景时, 限制 goroutine 的数量、重用 goroutine 显然很有价值。所以可以通过一个goroutine池来对所有的tasks进行排队执行，类似下面就是一个简单的goroutine池，通过定量的goroutine来进行任务的消费。设计下面的协程池有三个重点问题是需要重点考虑到的<br>1.如何确保任务全部都被消费完？<br>2.子goroutine发生panic如何处理？<br>3.子goroutine如果全部发生panic了怎么办？放任死锁吗？</p>
<p>这里并没考虑子goroutine执行时间太长的问题，主要原因我们可以自定义子goroutine的数量，我更希望的是任务能够执行完全而不是任务什么时候执行完，任务执行时间太长应该是业务侧的问题。</p>
<h2 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">import <span class="comment">(</span></span><br><span class="line"><span class="comment">    "sync"</span></span><br><span class="line"><span class="comment">    "sync/atomic"</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    "git.code.oa.com/trpc-go/trpc-go/errs"</span></span><br><span class="line"><span class="comment">    "git.code.oa.com/trpc-go/trpc-go/log"</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//自定义简单协程池 统一管理并发协程</span></span><br><span class="line"><span class="comment">//整体思路:定量的协程从同一个任务队列循环消费任务</span></span><br><span class="line"><span class="comment">//缺点:目前功能对协程超时情况存在缺陷 初始化函数中没有对初始化数量进行校验</span></span><br><span class="line">type Pool struct &#123;</span><br><span class="line">    TaskQueue      chan func() error //任务队列</span><br><span class="line">    WorkerNumber   int               //初始化worker数量</span><br><span class="line">    TaskNumber     int               //待消费任务数量</span><br><span class="line">    ResultQuene    chan error        //返回结果队列</span><br><span class="line">    FinishCallback func()            //全部任务消费完成的回调函数</span><br><span class="line">    runningWorkers int64             //运行中的worker数</span><br><span class="line">    sync.Mutex</span><br><span class="line">    <span class="comment">// PanicHandler   func(interface&#123;&#125;) //协程panic的处理函数 防止协程panic后导致主协程崩溃</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//初始化 根据自定义需求设定worker数量以及任务队列长度</span></span><br><span class="line">func (self *Pool) Init(WorkerNumber int, TaskNumber int) &#123;</span><br><span class="line">    self.WorkerNumber = WorkerNumber</span><br><span class="line">    self.TaskNumber = TaskNumber</span><br><span class="line">    self.TaskQueue = make(chan func() error, TaskNumber)</span><br><span class="line">    self.ResultQuene = make(chan error, TaskNumber)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//开启worker的消费动作</span></span><br><span class="line">func (self *Pool) Start() &#123;</span><br><span class="line">    <span class="comment">//默认开启 WorkerNumber个goruntine</span></span><br><span class="line">    for i := 0; i &lt; self.WorkerNumber; i++ &#123;</span><br><span class="line">        self.runGroutine()</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//获取每个任务的处理结果</span></span><br><span class="line">    for j := 0; j &lt; self.TaskNumber; j++ &#123;</span><br><span class="line">        err, ok := &lt;-self.ResultQue<span class="symbol">ne</span></span><br><span class="line">        //这里可以通过自定义决定是否上报日志</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            break</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if err != nil &#123;</span><br><span class="line">                log.Error<span class="comment">(err.Error()</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//结束时的回调函数 可以做一些通知操作等等</span></span><br><span class="line">    if self.FinishCallback != nil &#123;</span><br><span class="line">        self.FinishCallback()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//运行一个groutine 开始消费任务</span></span><br><span class="line">func (self *Pool) runGroutine() &#123; // runningWorkers + 1</span><br><span class="line">    self.incRunningWorkers() //worker运行ing数量原子自增1</span><br><span class="line">    go func() &#123;</span><br><span class="line">        defer func() &#123;</span><br><span class="line">            self.decRunningWorkers() //worker运行ing数量原子自减1</span><br><span class="line">            if r := recover(); r != nil &#123;</span><br><span class="line">                <span class="comment">// if self.PanicHandler != nil &#123;</span></span><br><span class="line">                <span class="comment">//  self.PanicHandler(r)</span></span><br><span class="line">                <span class="comment">// &#125; else &#123;</span></span><br><span class="line">                <span class="comment">//  log.Printf("Worker panic: %s\n", r)</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                err := errs.New(Panic_Sub_Goroutine, "子协程panic") //子协程panic是会导致主协程挂掉的，这一步也是必须进行捕获处理</span><br><span class="line">                self.ResultQuene &lt;- err</span><br><span class="line">            &#125;</span><br><span class="line">            self.checkWorker<span class="comment">()</span> <span class="comment">// 兜底机制，避免worker全部panic后没有worker消费队列中的数据,理论上这一步非常重要！否则有可能出现死锁状态</span></span><br><span class="line">        &#125;<span class="comment">()</span></span><br><span class="line">        for &#123;</span><br><span class="line">            select &#123;</span><br><span class="line">            case task, ok := &lt;-self.TaskQueue:</span><br><span class="line">                <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                    <span class="comment">//break 这里用break导致线上遇到了一个cpu被打满的bug 下一篇文章中进行说明</span></span><br><span class="line">                    retur<span class="symbol">n</span></span><br><span class="line">                &#125;</span><br><span class="line">                err := task<span class="comment">()</span></span><br><span class="line">                self.ResultQuene &lt;- err</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">()</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func (self *Pool) incRunningWorkers() &#123; // runningWorkers + 1</span><br><span class="line">    atomic.AddI<span class="symbol">nt64</span><span class="comment">(&amp;self.runningWorkers, 1)</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func (self *Pool) decRunningWorkers() &#123; // runningWorkers - 1</span><br><span class="line">    atomic.AddI<span class="symbol">nt64</span><span class="comment">(&amp;self.runningWorkers, -1)</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func (self *Pool) GetRunningWorkers() int64 &#123;</span><br><span class="line">    return atomic.LoadInt64(&amp;self.runningWorkers)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func (self *Pool) checkWorker() &#123;</span><br><span class="line">    self.Lock<span class="comment">()</span></span><br><span class="line">    defer self.Unlock()</span><br><span class="line"> </span><br><span class="line">    if self.GetRunningWorkers() == 0 &amp;&amp; len(self.TaskQueue) &gt; 0 &#123;</span><br><span class="line">        self.runGroutine()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//关闭通道避免内存泄漏</span></span><br><span class="line">func (self *Pool) Stop() &#123;</span><br><span class="line">    close<span class="comment">(self.TaskQueue)</span></span><br><span class="line">    close<span class="comment">(self.ResultQuene)</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//任务入队</span></span><br><span class="line">func (self *Pool) AddTask(task func() error) &#123;</span><br><span class="line">    self.TaskQueue &lt;- task</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//执行结束后的回调</span></span><br><span class="line">func (self *Pool) SetFinishCallback(fun func()) &#123;</span><br><span class="line">    self.FinishCallback = fun</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ctx := context.Background()</span><br><span class="line">ids := make<span class="comment">([]int32, 0)</span></span><br><span class="line">var pool comm.Pool</span><br><span class="line">pool.Init(50, len(ids))</span><br><span class="line">count := int32(0)</span><br><span class="line">for _, id := range ids &#123;</span><br><span class="line">    idValue := id</span><br><span class="line">    pool.AddTask<span class="comment">(func()</span> error &#123;</span><br><span class="line">        return func(innerId int32) error &#123;</span><br><span class="line">            err := DoSomething(innerId)</span><br><span class="line">            if err != nil &#123;</span><br><span class="line">                log.ErrorContextf(ctx, "DoSomething failed, id:%d err:%s", innerId, err.Error())</span><br><span class="line">                return nil</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//以上执行无问题，完成数就+1</span></span><br><span class="line">            atomic.AddI<span class="symbol">nt32</span><span class="comment">(&amp;count, 1)</span></span><br><span class="line">            return nil</span><br><span class="line">        &#125;<span class="comment">(int32(idValue)</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//回调</span></span><br><span class="line">pool.SetFinishCallback(func() &#123;</span><br><span class="line">    <span class="comment">//自定义通知操作</span></span><br><span class="line">    fmt.Println("all done")</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//开始执行</span></span><br><span class="line">pool.Start<span class="comment">()</span></span><br><span class="line"><span class="comment">//关闭资源</span></span><br><span class="line">pool.Stop<span class="comment">()</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>池化管理自己的goroutine是非常有必要的，可以帮助我们提升开发效率降低异常风险！所以赶紧把你的goroutine管理起来吧</p>
<p><img src="/2021/09/03/20210903-goroutinepool/6.jpg" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stevenhoukai.github.io/2021/08/25/20210825-redisScanExplain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="steven Hou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/upload/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/25/20210825-redisScanExplain/" itemprop="url">Redis的scan命令解释</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-25T00:00:01+08:00">
                2021-08-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="scan的种类"><a href="#scan的种类" class="headerlink" title="scan的种类"></a>scan的种类</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原文地址:https://segmentfault.com/a/1190000018218584</span><br><span class="line"><span class="selector-tag">SCAN</span> <span class="selector-tag">cursor</span> <span class="selector-attr">[MATCH pattern]</span> <span class="selector-attr">[COUNT count]</span></span><br><span class="line"><span class="selector-tag">SSCAN</span> <span class="selector-tag">KEY</span> <span class="selector-tag">cursor</span> <span class="selector-attr">[MATCH pattern]</span> <span class="selector-attr">[COUNT count]</span></span><br><span class="line">HSCAN  KEY cursor [MATCH pattern] [COUNT count</span><br><span class="line"><span class="selector-tag">ZSCAN</span> <span class="selector-tag">KEY</span> <span class="selector-tag">cursor</span> <span class="selector-attr">[MATCH pattern]</span> <span class="selector-attr">[COUNT count]</span></span><br></pre></td></tr></table></figure>

<p>scan:迭代当前库</p>
<p>sscan:迭代一个 set 类型</p>
<p>hscan:迭代一个hash类型,并返回相应的值</p>
<p>zscan:迭代一个sorted set，并且返回相应的分数</p>
<p>知道redis是单进程单线程模型,keys和smembers这种命令可能会阻塞服务器,导致redis有可能出现长时间无法响应其他命令的情况,所以出现了scan系列的命令,通过返回一个游标，可以增量式迭代。</p>
<h2 id="scan类型命令的实现"><a href="#scan类型命令的实现" class="headerlink" title="scan类型命令的实现"></a>scan类型命令的实现</h2><p>scan,sscan,hscan,zsan分别有自己的命令入口,入口中会进行参数检测和游标赋值,然后进入统一的入口函数:scanGenericCommand,以hscan命令为例:</p>
<p><img src="/2021/08/25/20210825-redisScanExplain/1.png" alt="图片描述"><br>scanGenericCommand主要分四步:</p>
<ul>
<li>解析count和match参数.如果没有指定count,默认返回10条数据</li>
<li>开始迭代集合,如果key保存为ziplist或者intset,则一次性返回所有数据,没有游标(游标值直接返回0).由于redis设计只有数据量比较小的时候才会保存为ziplist或者intset,所以此处不会影响性能.</li>
</ul>
<p>游标在保存为hash的时候发挥作用,具体入口函数为dictScan,下文详细描述。</p>
<ul>
<li>根据match参数过滤返回值,并且如果这个键已经过期也会直接过滤掉(redis中键过期之后并不会立即删除)</li>
<li>返回结果到客户端,是一个数组,第一个值是游标,第二个值是具体的键值对</li>
</ul>
<h2 id="dictScan中游标的实现"><a href="#dictScan中游标的实现" class="headerlink" title="dictScan中游标的实现"></a>dictScan中游标的实现</h2><p>上文中我们了解到了redis中的rehash操作叫渐进式rehash，所以当迭代一个哈希表时,存在三种情况：</p>
<ul>
<li>从迭代开始到结束,哈希表没有进行rehash</li>
<li>从迭代开始到结束,哈希表进行了rehash,但是每次迭代时,哈希表要么没开始rehash,要么已经结束了rehash</li>
<li>从迭代开始到结束,某次或某几次迭代时哈希表正在进行rehash</li>
</ul>
<p>redis中的字典进行rehash时会存在两个哈希表，ht[0]与ht[1],并且是渐进式rehash(即不会一次性全部rehash);新的键值对会存放到ht[1]中并且会逐步将ht[0]的数据转移到ht[1].全部rehash完毕后,ht[1]赋值给ht[0]然后清空ht[1].</p>
<p>因此游标的实现需要兼顾以上三种情况,以上三种情况的游标实现要求如下:</p>
<ul>
<li>第一种情况比较简单,假设redis的哈希表大小为4,则第一次游标为0,读取第一个bucket的数据,然后游标返回1,下次读取第二个bucket的位置,依次遍历</li>
<li>第二种情况比较复杂,假设redis的哈希表大小为4,如果rehash完后size变成了8.如果仍然按照上边的思路返回游标,则如下图:</li>
</ul>
<p><img src="/2021/08/25/20210825-redisScanExplain/2.png" alt="图片描述"></p>
<p>假设bucket0读完之后返回了游标1,当客户端再次带着游标1返回时哈希表已经进行完rehash,并且size扩大了一倍变成了8.redis按如下方法计算一个键的bucket:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash(key)&amp;(size<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

<p>即如果size是4时,hash(key)&amp;11,如果size是8时,hash(key)&amp;111.因此当从4扩容到8时,原先在0bucket的数据会分散到0(000)与4(100)两个bucket,bucket对应关系表如下:</p>
<p><img src="/2021/08/25/20210825-redisScanExplain/3.png" alt="图片描述"><br>从二进制来看,当size为4时,hash(key)之后取低两位即 hash(key)&amp;11即key的bucket位置,如果size为8时,bucket位置为 hash(key)&amp;111，即取低三位,当低两位为00时,如果第三位为0,则为000,如果第三位为1,则为100,正好是4.其他槽位的类似.所以如果此时继续按第一种方法遍历,第四个bucket取到的值全部为重复值</p>
<ul>
<li>第三种情况，如果返回游标1时正在进行rehash,ht[0]中的bucket 1中的部分数据可能已经rehash到 ht[1]中的bucket[1]或者bucket[5]，此时必须将ht[0]和ht[1]中的相应bucket全部遍历,否则可能会有遗漏数据</li>
</ul>
<p>所以为了兼顾以上三种情况,做到不漏数据并且尽量不重复,redis使用了一种叫做reverse binary iteration的方法.具体的游标计算代码如下，具体为什么这么做我也不知道，反正redis就是选择这么做了吗，而且效果很明显:</p>
<p><img src="/2021/08/25/20210825-redisScanExplain/4.png" alt="图片描述"><br>代码逻辑很简单,下面示例从4变为8和从4变为16以及从8变为4和从16变为4时,这种方法为何能够做到不重不漏</p>
<p><img src="/2021/08/25/20210825-redisScanExplain/5.png" alt="图片描述"><br>遍历size为4时的游标状态转移为0-2-1-3.</p>
<p>同理,size为8时的游标状态转移为0-4-2-6-1-5-3-7.</p>
<p>size为16时的游标状态转义为0-8-4-12-2-10-6-14-1-9-5-13-3-11-7-15</p>
<p><img src="/2021/08/25/20210825-redisScanExplain/6.png" alt="图片描述"></p>
<p>可以看出，当size由小变大时,所有原来的游标都能在大的hashTable中找到相应的位置,并且顺序一致,不会重复读取并且不会遗漏</p>
<p>例如size原来是4变为了8,且第二次遍历时rehash已经完成.此时游标为2,根据图2,我们知道size为4时的bucket2会rehash到size为8时的2和6.而size为4时的bucket0rehash到size为8时的0和4</p>
<p>由于bucket 0 已经遍历完,也即size为8时的0,4已经遍历,正好开始从2开始继续遍历,不重复也不会遗漏</p>
<p>继续考虑size由大变小的情况.假设size由16变为了4,分两种情况,一种是游标为0,2,1,3中的一种,此时继续读取,也不会遗漏和重复</p>
<p>但如果游标返回的不是这四种,例如返回了10,10&amp;11之后变为了2,所以会从2开始继续遍历.但由于size为16时的bucket2已经读取过,并且2,10,6,14都会rehash到size为4的bucket2,所以会造成重复读取</p>
<p>size为16时的bucket2。即有重复但不会遗漏</p>
<p><strong>总结一下:redis里边rehash从小到大时，scan系列命令不会重复也不会遗漏.而从大到小时,有可能会造成重复但不会遗漏.</strong></p>
<p>截止目前,情况1和情况2已经比较完美的处理了。情况3看看如何处理</p>
<p>情况3需要从ht[0]和ht[1]中都取出数据,主要的难点在于如何在size大的哈希表中找到应该取哪些bucket.redis代码如下:</p>
<p><img src="/2021/08/25/20210825-redisScanExplain/7.png" alt="图片描述"><br>判断条件为:</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v<span class="meta">&amp;(m0^m1)</span></span><br></pre></td></tr></table></figure>

<p>size 4的m0为00000011,size8的m1为00000111,二者异或之后取值为00000100,即取二者mask高位的值,然后&amp;v,看游标是否在高位还有值</p>
<p>下一个游标的取值方法为</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v = <span class="comment">(  ((v | m0)</span> <span class="number">+1</span>)&amp; ~<span class="name">m0</span>) | <span class="comment">( v &amp; m0)</span></span><br></pre></td></tr></table></figure>

<p>右半部分 取v的低位,左半部分取v的高位。 （v&amp;m0)取出v的低位 例如size = 4时为 v&amp;00000011</p>
<p>左半部分 （v|m0) + 1即将v的低位都置为1,然后+1之后会进位到v的高位,再次 &amp; ~m0之后即取出了v的高位</p>
<p>整体来看每次将游标v的高位加1.下边举例来看:</p>
<p>假设游标返回了2,并且正在进行rehash,此时size由4变成了8 .则m0 = 00000011 v = 00000010</p>
<p>根据公式计算出的下一个游标为 ( (( 00000010|00000011) +1 ) &amp; (11111100) )| (00000010 &amp; 00000011) = (00000100)&amp;(11111100)|(00000010) = (00000110) 正好是6</p>
<p>判断条件为 (00000010) &amp; (00000011 ^ 00000111) = (00000010) &amp; (00000100) = (00000000) 为0，结束循环</p>
<p><img src="/2021/08/25/20210825-redisScanExplain/6.jpg" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stevenhoukai.github.io/2021/08/24/20210824-redisRehash/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="steven Hou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/upload/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/24/20210824-redisRehash/" itemprop="url">Redis中的渐进式Rehash</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-24T00:00:01+08:00">
                2021-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>如果你有一个hash表，然后不停的往里面写值或者删值，随着操作的不断执行， 哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的负载因子（load factor）维持在一个合理的范围之内， 当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩。这个过程就叫做rehash，而在redis中这个rehash的过程又叫做渐进式rehash。</p>
<h2 id="Rehash原理"><a href="#Rehash原理" class="headerlink" title="Rehash原理"></a>Rehash原理</h2><p>扩展和收缩哈希表的工作可以通过执行 rehash （重新散列）操作来完成， Redis 对字典的哈希表执行 rehash 的步骤如下：</p>
<ol>
<li>为字典的<strong>ht[1]</strong>哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及<strong>ht[0]</strong>当前包含的键值对数量 （也即是ht[0].used属性的值）：<ul>
<li>如果执行的是扩展操作， 那么 <code>ht[1]</code> 的大小为第一个大于等于 <code>ht[0].used * 2</code> 的 2^n （<code>2</code> 的 <code>n</code> 次方幂），也就是说每次扩容后的大小一定是2^n，因为只有2^n -1的二进制每一位都为1；</li>
<li>如果执行的是收缩操作， 那么 <code>ht[1]</code> 的大小为第一个大于等于 <code>ht[0].used</code> 的 2^n 。</li>
</ul>
</li>
<li>将保存在 <code>ht[0]</code> 中的所有键值对 rehash 到 <code>ht[1]</code> 上面： rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 <code>ht[1]</code>哈希表的指定位置上。</li>
<li>当 <code>ht[0]</code> 包含的所有键值对都迁移到了 <code>ht[1]</code> 之后 （<code>ht[0]</code> 变为空表）， 释放 <code>ht[0]</code> ， 将 <code>ht[1]</code> 设置为 <code>ht[0]</code> ， 并在 <code>ht[1]</code> 新创建一个空白哈希表， 为下一次 rehash 做准备。</li>
</ol>
<p>举个例子， 假设程序要对图 1 所示字典的 <code>ht[0]</code> 进行扩展操作， 那么程序将执行以下步骤：</p>
<ol>
<li><code>ht[0].used</code> 当前的值为 <code>4</code> ， <code>4 * 2 = 8</code> ， 而 <code>8</code> （2^3）恰好是第一个大于等于 <code>4</code> 的 <code>2</code> 的 <code>n</code> 次方， 所以程序会将 <code>ht[1]</code> 哈希表的大小设置为 <code>8</code> 。 图 2 展示了 <code>ht[1]</code> 在分配空间之后， 字典的样子。</li>
<li>将 <code>ht[0]</code> 包含的四个键值对都 rehash 到 <code>ht[1]</code> ， 如图 3 所示。</li>
<li>释放 <code>ht[0]</code> ，并将 <code>ht[1]</code> 设置为 <code>ht[0]</code> ，然后为 <code>ht[1]</code> 分配一个空白哈希表，如图 4 所示。</li>
</ol>
<p>至此， 对哈希表的扩展操作执行完毕， 程序成功将哈希表的大小从原来的 <code>4</code> 改为了现在的 <code>8</code> 。</p>
<h2 id="Rehash图示"><a href="#Rehash图示" class="headerlink" title="Rehash图示"></a><strong>Rehash图示</strong></h2><p><img src="/2021/08/24/20210824-redisRehash/1.png" alt="图1"></p>
<center>图1 执行rehash之前</center>

<p><img src="/2021/08/24/20210824-redisRehash/2.png" alt="图2"></p>
<center>图2 为字典的ht[1]哈希表分配空间</center>

<p><img src="/2021/08/24/20210824-redisRehash/3.png" alt="图3"></p>
<center>图3 ht[0]的所有值对都已经被迁移到ht[1]</center>

<p><img src="/2021/08/24/20210824-redisRehash/4.png" alt="图4"></p>
<center>图4 完成rehash之后的字典</center>

<h2 id="哈希表的扩展与收缩"><a href="#哈希表的扩展与收缩" class="headerlink" title="哈希表的扩展与收缩"></a><strong>哈希表的扩展与收缩</strong></h2><p>当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：</p>
<ol>
<li>服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 <code>1</code> ；</li>
<li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 <code>5</code> ；</li>
</ol>
<p>其中哈希表的负载因子可以通过公式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 负载因子 = 哈希表已保存节点数量 / 哈希表大小</span><br><span class="line">load_factor = ht[0].used / ht[0].size</span><br></pre></td></tr></table></figure>

<p>计算得出。</p>
<p>比如说， 对于一个大小为 <code>4</code> ， 包含 <code>4</code> 个键值对的哈希表来说， 这个哈希表的负载因子为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load_factor = 4 / 4 = 1</span><br></pre></td></tr></table></figure>

<p>又比如说， 对于一个大小为 <code>512</code> ， 包含 <code>256</code> 个键值对的哈希表来说， 这个哈希表的负载因子为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load_factor = 256 / 512 = 0.5</span><br></pre></td></tr></table></figure>

<p>根据 BGSAVE 命令或 BGREWRITEAOF 命令是否正在执行， 服务器执行扩展操作所需的负载因子并不相同， 这是因为在执行 BGSAVE命令或 BGREWRITEAOF 命令的过程中， Redis 需要创建当前服务器进程的子进程， 而大多数操作系统都采用写时复制copy-on-write技术来优化子进程的使用效率， 所以在子进程存在期间， 服务器会提高执行扩展操作所需的负载因子， 从而尽可能地避免在子进程存在期间进行哈希表扩展操作， 这可以避免不必要的内存写入操作， 最大限度地节约内存。</p>
<p>另一方面， 当哈希表的负载因子小于 <code>0.1</code> 时， 程序自动开始对哈希表执行收缩操作。</p>
<h2 id="渐进式Rehash"><a href="#渐进式Rehash" class="headerlink" title="渐进式Rehash"></a><strong>渐进式Rehash</strong></h2><p>上面说过， 扩展或收缩哈希表需要将 <code>ht[0]</code> 里面的所有键值对 rehash 到 <code>ht[1]</code> 里面， 但是， 这个 rehash 动作<strong>并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的</strong>。</p>
<p>这样做的原因在于， 如果 <code>ht[0]</code> 里只保存着四个键值对， 那么服务器可以在瞬间就将这些键值对全部 rehash 到 <code>ht[1]</code> ； 但是， 如果哈希表里保存的键值对数量不是四个， 而是四百万、四千万甚至四亿个键值对， 那么要一次性将这些键值对全部 rehash 到 <code>ht[1]</code> 的话， 庞大的计算量可能会导致服务器在一段时间内停止服务。</p>
<p>因此， 为了避免 rehash 对服务器性能造成影响， 服务器不是一次性将 <code>ht[0]</code> 里面的所有键值对全部 rehash 到 <code>ht[1]</code> ， 而是分多次、渐进式地将 <code>ht[0]</code> 里面的键值对慢慢地 rehash 到 <code>ht[1]</code> 。</p>
<p>以下是哈希表渐进式 rehash 的详细步骤：</p>
<ol>
<li>为 <code>ht[1]</code> 分配空间， 让字典同时持有 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表。</li>
<li>在字典中维持一个索引计数器变量 <code>rehashidx</code> ， 并将它的值设置为 <code>0</code> ， 表示 rehash 工作正式开始。</li>
<li>在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 <code>ht[0]</code> 哈希表在 <code>rehashidx</code> 索引上的所有键值对 rehash 到 <code>ht[1]</code> ， 当 rehash 工作完成之后， 程序将 <code>rehashidx</code> 属性的值增一。</li>
<li>随着字典操作的不断执行， 最终在某个时间点上， <code>ht[0]</code> 的所有键值对都会被 rehash 至 <code>ht[1]</code> ， 这时程序将 <code>rehashidx</code> 属性的值设为 <code>-1</code> ， 表示 rehash 操作已完成。</li>
</ol>
<p>渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。</p>
<p>图 5 至图 10 展示了一次完整的渐进式 rehash 过程， 注意观察在整个 rehash 过程中， 字典的 <code>rehashidx</code> 属性是如何变化的。</p>
<h2 id="渐进式Rehash图示"><a href="#渐进式Rehash图示" class="headerlink" title="渐进式Rehash图示"></a><strong>渐进式Rehash图示</strong></h2><p><img src="/2021/08/24/20210824-redisRehash/5.png" alt="图1"></p>
<center>图5 准备开始rehash</center>

<p><img src="/2021/08/24/20210824-redisRehash/6.png" alt="图1"></p>
<center>图6 rehash索引0上的key value</center>

<p><img src="/2021/08/24/20210824-redisRehash/7.png" alt="图1"></p>
<center>图7 rehash索引1上的key value</center>

<p><img src="/2021/08/24/20210824-redisRehash/8.png" alt="图1"></p>
<center>图8 rehash索引2上的key value</center>

<p><img src="/2021/08/24/20210824-redisRehash/9.png" alt="图1"></p>
<center>图9 rehash索引3上的key value</center>

<p><img src="/2021/08/24/20210824-redisRehash/10.png" alt="图1"></p>
<center>图10 rehash完成</center>



<h2 id="渐进式-rehash-执行期间的哈希表操作"><a href="#渐进式-rehash-执行期间的哈希表操作" class="headerlink" title="渐进式 rehash 执行期间的哈希表操作"></a><strong>渐进式 rehash 执行期间的哈希表操作</strong></h2><p>因为在进行渐进式 rehash 的过程中， 字典会同时使用 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 <code>ht[0]</code>里面进行查找， 如果没找到的话， 就会继续到 <code>ht[1]</code> 里面进行查找， 诸如此类。</p>
<p>另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 <code>ht[1]</code> 里面， 而 <code>ht[0]</code> 则不再进行任何添加操作： 这一措施保证了 <code>ht[0]</code> 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。<strong>这里提前透漏一句，就是这个渐进式rehash的缩容操作导致了scan命令的重复值出现。</strong>下一篇会详细讨论一下。</p>
<p><img src="/2021/08/24/20210824-redisRehash/6.jpg" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stevenhoukai.github.io/2021/08/19/20210819-redisScan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="steven Hou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/upload/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/19/20210819-redisScan/" itemprop="url">获取Redis中同一前缀key踩坑记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-19T00:00:01+08:00">
                2021-08-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/golang踩坑记录/" itemprop="url" rel="index">
                    <span itemprop="name">golang踩坑记录</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>之前有一个订单购买后用户生效保护期的需求，根据当时的需求本人是将key设置好自定义前缀规则，并设置了过期时间然后统一放在了redis上面，后来需求变动，所有的保护期过期之后需要留档处理，这时候就需要把之前设置的同一前缀的保护期数据在过期之前全部转移到数据库留档，就需要将之前设置的所有保护期相关数据全部获取出来。这时的kv大概已经有了300w条左右了。</p>
<p>这里就有两个方案了keys * 和 scan</p>
<p>keys *这个虽然可以实现目的但是最好还是不要使用，因为如果线上数据过大，就会导致单线程的redis阻塞，长时间无法处理后续请求，然后你就等着被捶吧。</p>
<p>scan可以理解是keys <em>的分批次执行，简单来说就是会有一个游标记录一次扫描的结束位置，然后拿着这个游标作为下一次扫描的起始位置，反复执行，每次执行数据量不大而且每次执行时间也足够短，直到扫描完整个redis库，全程不会造成redis的无响应状况，但是需要声明一点，*</em>这个scan操作是会出现重复key值的<strong>，所以需要业务侧做好去重处理哈。本文的重点！</strong>为什么说这个scan会出现重复值，又为什么这个scan是不会漏值的？**下面就来说说本人的理解。</p>
<h2 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h2><p>下面是本人在项目中的一些用法,代码实现功能就是将自己需要的一些kv值遍历出来放进mysql进行存储，由于线上数据量较大，整个过程大约持续了30分钟，但是redis服务全程无异常状况，完美达到目的。</p>
<h3 id="核心代码示例"><a href="#核心代码示例" class="headerlink" title="核心代码示例"></a>核心代码示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">rcnn := redis.Connection()</span><br><span class="line">begin := time.Now().Unix()</span><br><span class="line">firstStrs, cursor := rcnn.Scan(<span class="number">0</span>, <span class="string">"xxxxx_service_xxxxx*"</span>, <span class="number">1000</span>).Val()</span><br><span class="line">fmt.Println(time.Now().Unix() - begin)</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> firstStrs &#123;</span><br><span class="line">    key := value</span><br><span class="line">    keyValue := rcnn.Get(key).Val()</span><br><span class="line">    ttlSeconds := <span class="keyword">int64</span>(rcnn.TTL(key).Val().Seconds())</span><br><span class="line">    tnow := time.Now().Unix()</span><br><span class="line">    memberId, _ := strconv.Atoi((strings.Split(key, <span class="string">"&amp;"</span>)[<span class="number">1</span>]))</span><br><span class="line">    orderId := strings.Split(keyValue, <span class="string">"&amp;"</span>)[<span class="number">0</span>]</span><br><span class="line">    pPeriod := &amp;protectperiod.ProtectPeriod&#123;</span><br><span class="line">        MemberId:  <span class="keyword">int64</span>(memberId),</span><br><span class="line">        OrderId:   orderId,</span><br><span class="line">        Content:   keyValue,</span><br><span class="line">        CreatedAt: tnow + ttlSeconds - <span class="number">3628800</span>,</span><br><span class="line">        ExpiredAt: tnow + ttlSeconds,</span><br><span class="line">        Status:    <span class="string">"0"</span>,</span><br><span class="line">        Source:    <span class="string">"redis"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    cErr := pPeriod.CreateNewRecord()</span><br><span class="line">    <span class="keyword">if</span> cErr != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(cErr)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> cursor != <span class="number">0</span> &#123;</span><br><span class="line">    cbegin := time.Now().Unix()</span><br><span class="line">    strs, nextCursor := rcnn.Scan(cursor, <span class="string">"xxxxx_service_xxxxx*"</span>, <span class="number">1000</span>).Val()</span><br><span class="line">    fmt.Println(time.Now().Unix() - cbegin)</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> strs &#123;</span><br><span class="line">        key := value</span><br><span class="line">        keyValue := rcnn.Get(key).Val()</span><br><span class="line">        ttlSeconds := <span class="keyword">int64</span>(rcnn.TTL(key).Val().Seconds())</span><br><span class="line">        tnow := time.Now().Unix()</span><br><span class="line">        memberId, _ := strconv.Atoi((strings.Split(key, <span class="string">"&amp;"</span>)[<span class="number">1</span>]))</span><br><span class="line">        orderId := strings.Split(keyValue, <span class="string">"&amp;"</span>)[<span class="number">0</span>]</span><br><span class="line">        pPeriod := &amp;protectperiod.ProtectPeriod&#123;</span><br><span class="line">            MemberId:  <span class="keyword">int64</span>(memberId),</span><br><span class="line">            OrderId:   orderId,</span><br><span class="line">            Content:   keyValue,</span><br><span class="line">            CreatedAt: tnow + ttlSeconds - <span class="number">3628800</span>,</span><br><span class="line">            ExpiredAt: tnow + ttlSeconds,</span><br><span class="line">            Status:    <span class="string">"0"</span>,</span><br><span class="line">            Source:    <span class="string">"redis"</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        cErr := pPeriod.CreateNewRecord()</span><br><span class="line">        <span class="keyword">if</span> cErr != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(cErr)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cursor = nextCursor</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"all Done"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h2><p>好了，在前言中有说到<strong>为什么说这个scan会出现重复值，又为什么这个scan是安全不会漏值的？</strong> 在讨论这个问题之前，我们需要先了解什么是Rehash，学过java的都知道hashmap，当hashmap中的槽不够用的时候就会在每一个槽产生过长的链表导致效率低下等问题，在hash冲突严重的时候，hashmap就会进行扩容，然后把原来的kv值转移到新的扩容的好hashmap中去，这个过程其实就是rehash。其实在redis中这一过程准确点的叫法是渐进式rehash，点此处了解什么是<a href="https://stevenhoukai.github.io/2021/08/24/20210824-redisRehash/"><strong>渐进式rehash</strong></a>, 了解完上述概念之后，我们现在再来看看<a href="https://stevenhoukai.github.io/2021/08/25/20210825-redisScanExplain/"><strong>scan命令为什么是安全不漏值而且可能会出现重复值</strong></a>的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>如果遇到线上redis需要获取大批量的kv值，用scan不会错。切记客户端一定要做好去重处理！！！</p>
<p><img src="/2021/08/19/20210819-redisScan/6.jpg" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stevenhoukai.github.io/2021/08/16/20210816-gapGolangFor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="steven Hou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/upload/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/16/20210816-gapGolangFor/" itemprop="url">Golang的for循环踩坑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-16T00:00:01+08:00">
                2021-08-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/golang踩坑记录/" itemprop="url" rel="index">
                    <span itemprop="name">golang踩坑记录</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>最近写项目用了太多的for循环，殊不知这么简单的一个操作竟然踩出大坑，记录一波！</p>
<h2 id="for循环使用"><a href="#for循环使用" class="headerlink" title="for循环使用"></a>for循环使用</h2><p>下面来看一下项目中的一些用法</p>
<h3 id="实例踩坑效果"><a href="#实例踩坑效果" class="headerlink" title="实例踩坑效果"></a>实例踩坑效果</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	newArr := []*<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		newArr = <span class="built_in">append</span>(newArr, &amp;v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> newArr &#123;</span><br><span class="line">		fmt.Println(*v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>看到这个结果的时候我其实是一脸懵逼的，这个问题起初我一个java程序员真是无法理解，后来直到我运行了如下的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	newArr := []*<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		fmt.Println(<span class="string">""</span>)</span><br><span class="line">		fmt.Printf(<span class="string">"origin addr: %p value: %v"</span>, &amp;v, v)</span><br><span class="line">		newArr = <span class="built_in">append</span>(newArr, &amp;v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> newArr &#123;</span><br><span class="line">		fmt.Println(<span class="string">""</span>)</span><br><span class="line">		fmt.Printf(<span class="string">"addr: %p  value: %v"</span>, s, *s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">origin addr: <span class="number">0xc0000a67a8</span> value: <span class="number">1</span></span><br><span class="line">origin addr: <span class="number">0xc0000a67a8</span> value: <span class="number">2</span></span><br><span class="line">origin addr: <span class="number">0xc0000a67a8</span> value: <span class="number">3</span></span><br><span class="line">addr: <span class="number">0xc0000a67a8</span>  value: <span class="number">3</span></span><br><span class="line">addr: <span class="number">0xc0000a67a8</span>  value: <span class="number">3</span></span><br><span class="line">addr: <span class="number">0xc0000a67a8</span>  value: <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>总结就是golang的for循环是通过同一个地址槽来反复接值的！！！</p>
<p><img src="/2021/08/16/20210816-gapGolangFor/6.jpg" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/upload/images/avatar.jpg" alt="steven Hou">
            
              <p class="site-author-name" itemprop="name">steven Hou</p>
              <p class="site-description motion-element" itemprop="description">dora is my precious</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/stevenhoukai" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">steven Hou</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user">访客数</i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye">总访问量</i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  








  
  





  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_sphere.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
