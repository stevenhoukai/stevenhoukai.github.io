<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="dora is my precious">
<meta name="keywords" content="golang devops java">
<meta property="og:type" content="website">
<meta property="og:title" content="迷途小书童">
<meta property="og:url" content="http://stevenhoukai.github.io/index.html">
<meta property="og:site_name" content="迷途小书童">
<meta property="og:description" content="dora is my precious">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="迷途小书童">
<meta name="twitter:description" content="dora is my precious">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://stevenhoukai.github.io/">





  <title>迷途小书童</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">迷途小书童</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">读过几年书，尘世间一枚不起眼的小书童</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stevenhoukai.github.io/2022/03/26/20220326-goslice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="史蒂芬猴">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/upload/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/03/26/20220326-goslice/" itemprop="url">slice</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-03-26T00:00:01+08:00">
                2022-03-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Golang/" itemprop="url" rel="index">
                    <span itemprop="name">Golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇我们了解了golang的string是如何玩转的，趁热打铁今天就来学习常用的slice结构，这个slice跟我们以前做java的时候用到的动态数组(List)很相似，但是又有区别，那么今天就来探究下它的原理。</p>
<h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a><strong>slice</strong></h2><h3 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a><strong>三要素</strong></h3><p>slice包含以下图示的三个核心元素，数据、已存放数据长度以及容量 :</p>
<img src="/2022/03/26/20220326-goslice/1.png" style="zoom: 80%;">

<p>举个例子如下 : </p>
<p>我们声明了一个变量intSlice，实际上这只是一个声明，底层并没有分配对应的数组进行支持，所以指向底层数组的指针data就是nil，而长度和容量都是0值。</p>
<img src="/2022/03/26/20220326-goslice/2.png" style="zoom: 80%;"> 

<p>在golang中有两种初始化slice的方式分别是make 和 new</p>
<h4 id="make"><a href="#make" class="headerlink" title="make"></a><strong>make</strong></h4><p>从下图中我们可以看到通过make的方式声明变量intSlice<strong><u>就会在底层分配一个对应的数据类型的数组</u></strong>，并将data指向底层数组的起始地址，操作1就是向slice中添加一个元素，操作2就是改变slice已经存在元素的值，操作3就是访问超过len的数据这种情况会直接panic。</p>
<img src="/2022/03/26/20220326-goslice/3.png" style="zoom: 80%;">

<h4 id="new"><a href="#new" class="headerlink" title="new"></a><strong>new</strong></h4><p>接下来就是通过new关键字声明变量，可以知道并未在底层初始化对应的数组，所以操作1直接给slice下标为0的元素赋值会直接panic，这时只有通过操作2 append操作才会在底层初始化对应的数组并将data指向底层数组的起始位置，其实这里有一点绕，slice的data指向底层的一个字符串数组，上一篇中我们讲过string的结构不记得的可以回去再看一遍，所以字符串的data还会指向另外一个底层实际存储字符编码的数组。</p>
<img src="/2022/03/26/20220326-goslice/4.png" style="zoom: 80%;">

<p>通过以上对比我们发现其实两者还是有很大区别的，两者虽然都可以用来声明slice变量，但是前者会在声明变量的同时在底层分配好对应类型的数组结构而后者则不会，实际上我本人在实际的开发过程中也只会用make。make不仅可以初始化slice，还可以用在map和chan的初始化上面。</p>
<h3 id="底层数组"><a href="#底层数组" class="headerlink" title="底层数组"></a><strong>底层数组</strong></h3><p>上面一直在说底层数组，那么底层数组究竟是什么？数组其实就是一段连续的内存空间，在这一段连续的内存空间内一个挨着一个的存储着同种类型的数据，int型的slice底层其实就是一个int数组，string型的slice底层就是一个string数组，从上面说明的例子我们可以看到slice都是指向了底层数组的起始地址，但这是必须的吗？我们来看接下来的一个列子 : </p>
<p>我们先来声明一个int类型的数组arr，容量为10，数组的容量一旦声明就不能再变了，我们可以通过下面s1和s2的声明方式（左闭右开原则）将slice变量关联到同一个arr数组，可以看到s1的指向地址其实是底层数组第二个元素的地址位置，而s2的指向地址其实是底层数组第八个元素的地址位置，这其实不难理解，那么本文的核心来了，请仔细看操作 s2 = append(s2,11)（<strong><u>这个动作并不是线程安全的后面我们会细聊</u></strong>），该操作会触发扩容动作？那么什么是扩容了？slice又是怎么扩容的了？</p>
<img src="/2022/03/26/20220326-goslice/6.png" style="zoom: 80%;">

<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a><strong>扩容</strong></h3><p>上面提出了一个扩容的概念，其实这个也很好理解s2指向的底层数组已经满了无法将11存放，这时s2就需要另谋高去开辟另外的一片内存空间将自己原来的数据复制过去后再将11添加的末尾，最后s2就指向了该新内存空间的起始地址。在这个过程中我们其实会有几个疑问的，第一个我怎么知道那片新的内存空间要多大了，随便还是无限的？我能想到golang当然也能想到，扩容整体来说就是下面的三个步骤。</p>
<h4 id="步骤1-预估扩容后的容量"><a href="#步骤1-预估扩容后的容量" class="headerlink" title="步骤1 : 预估扩容后的容量"></a><strong>步骤1 : 预估扩容后的容量</strong></h4><p>这个规则其实没啥好说的，源码总结规则如下：</p>
<img src="/2022/03/26/20220326-goslice/7.png" style="zoom: 80%;">

<h4 id="步骤2-扩容后需要多大内存"><a href="#步骤2-扩容后需要多大内存" class="headerlink" title="步骤2 : 扩容后需要多大内存"></a><strong>步骤2 : 扩容后需要多大内存</strong></h4><p>这个其实跟我们的元素类型是息息相关的，但是真的就是按照下图的方式直接分配至么多内存吗？答案是否定的。</p>
<img src="/2022/03/26/20220326-goslice/8.png" style="zoom: 80%;">

<h4 id="步骤3-匹配合适的内存规格"><a href="#步骤3-匹配合适的内存规格" class="headerlink" title="步骤3 : 匹配合适的内存规格"></a><strong>步骤3 : 匹配合适的内存规格</strong></h4><p>上面这个问题简单来说就是编程语言(c除外)去申请内存并不是直接向操作系统申请的，中间还夹着一层代理人(内存管理模块)，系统启动时代理人先向os提前申请好一批内存，分成常用的规格管理起来，当golang向其申请内存空间时，代理人就会挑选对应刚大于申请空间大小的内存块并分配给申请人，这样就完成了整个的扩容动作。</p>
<img src="/2022/03/26/20220326-goslice/9.png" style="zoom: 80%;">



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我们聊了聊slice的相关原理，是不是很有趣，现在只是开篇稍微简单一点，后面会逐步深入，难度也会逐步增大，下一篇我们聊聊内存对齐哈，slice完结撒花～。</p>
<img src="/2022/03/26/20220326-goslice/5.jpg" style="zoom: 100%;">
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stevenhoukai.github.io/2022/03/24/20220324-gostring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="史蒂芬猴">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/upload/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/03/24/20220324-gostring/" itemprop="url">go的string</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-03-24T00:00:01+08:00">
                2022-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Golang/" itemprop="url" rel="index">
                    <span itemprop="name">Golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从java转golang已经一年多了，过去的一年确实也挺坎坷的，国家打压部门解散，刚在支付组有一点感觉然后就没然后了，也没事后面活水到新部门继续肝，这不刚用go重构完一个十年前的c++系统，过程之痛苦一言难尽，但是痛苦归痛苦从中还是学到了不少，例如redis，pulsar这个之前已经写过好几篇基本的文章了，后续会更新一些自己在用法上的硬核知识，啊哦跑题了，本系列的核心是golang，用了一年多的golang是时候该总结一下了，俗话说的好学而时习之才能逆水行舟， 今天的主题是string～</p>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a><strong>string</strong></h2><h3 id="比特与字节"><a href="#比特与字节" class="headerlink" title="比特与字节"></a><strong>比特与字节</strong></h3><p>一个bit或者是0或者是1，8个bit组成一个字节，全部为0代表0，全部为1代表数字255，相信这个不必多说大家都知道了，一个字节可以表示256个数字，两个字节就是65536个数字了，更多的字节就可以表示更大的数字，如下图所示 :</p>
<img src="/2022/03/24/20220324-gostring/1.png" style="zoom: 80%;">



<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a><strong>字符集</strong></h3><p>以上我们说的都是整数，那字符是怎样存储的了？一堆二进制是怎么转换成字符的了？不能直接展示那就通过数字中转一下，如下图 : 存储保持不变，多添加一层映射关系就能解决这个问题啦，尽可能多的将世界上出现的字符收录进来然后一一进行编号构建一张映射表，这个映射表就叫做字符集，下面展示了字符集的进化旅程，其实就是一个字符映射表不断完善的过程，直到最后被unicode统一规范。</p>
<img src="/2022/03/24/20220324-gostring/2.png" style="zoom: 80%;">

<h3 id="字符串存储（UTF-8）"><a href="#字符串存储（UTF-8）" class="headerlink" title="字符串存储（UTF-8）"></a><strong>字符串存储（UTF-8）</strong></h3><p>上面说明字符集，但是真的只是有了字符集就万事大吉了吗？来思考下该怎么存储 “世界aABb” ？</p>
<p>最直接的想法是不是根据字符集找到每一个字符的编号存成二进制完事儿？来看看是不是就像下面这样，乍一看没有问题，但是仔细一看不对啊有的占一个字节有的占了三个字节，那我咋知道那一长串玩意儿要怎么划分了？这个方案显然不行…</p>
<img src="/2022/03/24/20220324-gostring/3.png" style="zoom: 80%;">

<p>于是我们应该能想到第一种方案 : 定长编码</p>
<img src="/2022/03/24/20220324-gostring/4.png" style="zoom: 80%;">

<p>这个方案，乍一看没有问题，然后再仔细一看确实也没有啥问题，就是浪费的字节稍微有点多……那可以怎么解决了？这里就引出了另外一种方案 : 变长编码，如下图所示：</p>
<img src="/2022/03/24/20220324-gostring/5.png" style="zoom: 80%;">

<p>这个图看着是不是有点懵逼，没关系，容我来稍微解释一下，每个字节分为标示位和实际数据两部分，例如第一行的0??? ????,如果数据在0～127之间，对应的编码模版就是以0标示开头后7位表示实际数据，如果数据在128～2047之间数据就占两字节，每个字节分别以固定的110和10两个固定标示开头，后面的也一样，其实就是通过固定的标示位来重新组装原来的二进制数据从而降低对内存的浪费。看到这里现在应该知道最开始的那个字符串该怎么存储了吧？</p>
<img src="/2022/03/24/20220324-gostring/6.png" style="zoom: 80%;">

<p>这其实就是我们熟知的UTF-8编码，也就是golang默认的编码方式，字符集和编码方式是需要相互配合才能达到最优方案的。接下来我们就可以来了解下golang的string是如何实现的了。</p>
<h3 id="go的string"><a href="#go的string" class="headerlink" title="go的string"></a><strong>go的string</strong></h3><p>碰巧了前段时间重构c++，也了解了一下c++的string是如何实现的，来我们先来看看C语言是如何实现的，如下图 : </p>
<img src="/2022/03/24/20220324-gostring/7.png" style="zoom: 80%;">

<p>C语言如是说，会在结尾处通过 \0 的特殊字符来标示结尾，那这也就意味着存放的字符串中是无法出现 \0 这样的字符的，-_-!!!本人很坦诚的说一句这方案忒差了，所以golang并没有采用这种方案，来看看golang是如何处理的:</p>
<img src="/2022/03/24/20220324-gostring/8.png" style="zoom: 80%;">

<p>golang通过添加一个len变量来存储字符串中字节的长度，还是上面的例子”世界aABb”就应该是这样 : </p>
<img src="/2022/03/24/20220324-gostring/9.png" style="zoom: 80%;">

<p>好了关于golang的string今天就介绍到这里，对了，最后非常值得注意的一点是，无论是java或是golang，string都会被认为是不可变变量，是不允许修改的，golang编译器会把 s1:= “世界aABb”这样的变量分配到只读内存中，多个str是可以共享底层同一个数组变量的，可以重新复制这时会重新开辟一个数组空间，但是绝对不允许修改，完结撒花。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天属于是golang系列的开篇，后续的该系列也会不断完善，下一篇我们讲slice。</p>
<img src="/2022/03/24/20220324-gostring/5.jpg" style="zoom: 100%;">
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stevenhoukai.github.io/2022/03/17/20220313-protobuf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="史蒂芬猴">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/upload/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/03/17/20220313-protobuf/" itemprop="url">为什么要用protobuf？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-03-17T00:00:01+08:00">
                2022-03-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/协议/" itemprop="url" rel="index">
                    <span itemprop="name">协议</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前做java开发，服务间相互调用用的最多的就是java原生序列化和json序列化协议，然而后面去了大厂做golang开发基本都是采用pb了，刚开始以为只是规范使然，然而通过后面的学习发现pb确实是全方位领先于其他各种序列化协议的，简单来说就是pb不仅更快而且更小，下面就来细细的探讨一番。</p>
<h2 id="bp为什么这么屌"><a href="#bp为什么这么屌" class="headerlink" title="bp为什么这么屌"></a><strong>bp为什么这么屌</strong></h2><p><strong>官方测试</strong></p>
<p>那么pb究竟实战有多屌了，先看两幅官方测试报告图：</p>
<img src="/2022/03/17/20220313-protobuf/1.png" style="zoom: 100%;">

<p>​                                                                                           <u>解包耗时</u></p>
<img src="/2022/03/17/20220313-protobuf/2.png" style="zoom: 100%;">

<p>​                                                                                           <u>数据包压缩后大小</u></p>
<p>可以很明显的看到，一条消息数据，用<code>protobuf</code>序列化后的大小是<code>json</code>的10分之一，是<code>xml</code>格式的20分之一，但是性能却是它们的5~100倍。</p>
<p><strong>为什么用pb对数据包压缩后更小</strong></p>
<p>下面以<code>json</code>数据为基础出发，通过一步一步的对它进行优化，来理解<code>protobuf</code>的实现原理。</p>
<p>例如有一条信息，用<code>json</code>的表示方式如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"age"</span>: <span class="number">32</span>, <span class="attr">"name"</span>: <span class="string">"xxx"</span>,  <span class="attr">"height"</span>: <span class="number">170</span>, <span class="attr">"weight"</span>: <span class="number">106</span> &#125;</span><br></pre></td></tr></table></figure>

<p>很明显，整个json串种包含着很多可有可无的字符，例如”,” “:”等，为了把数据变的更小一点，我可能就会采取如下处理方式：</p>
<table>
<thead>
<tr>
<th align="center">32</th>
<th align="center">xxx</th>
<th align="center">170</th>
<th align="center">106</th>
</tr>
</thead>
</table>
<p>这里直接舍去了全部不必要的冗余字符，这里其实已经对数据进行了大幅缩减了，但是这时会出现一些新的问题，接收端接收到数据后咋知道32对应的是那个字段，xxx又是对应的哪个字段，也就是字段的对应问题这时是无法解决的。</p>
<p>那我们可以对字段都编个号，接收端接收到数据后就按照这个编号进行解析即可，如下：</p>
<table>
<thead>
<tr>
<th align="center">字段1：age</th>
<th align="center">字段2：name</th>
<th align="center">字段3： height</th>
<th align="center">字段4：weight</th>
</tr>
</thead>
<tbody><tr>
<td align="center">↓</td>
<td align="center">↓</td>
<td align="center">↓</td>
<td align="center">↓</td>
</tr>
<tr>
<td align="center">32</td>
<td align="center">Xxx</td>
<td align="center">170</td>
<td align="center">106</td>
</tr>
</tbody></table>
<p>这样看来就完美达成目的了</p>
<p><strong>新的问题以及解决方案</strong></p>
<p>虽然上述方案可以达到解决问题的目的，但是我们来假设一下下面的情况<code>height</code>这个字段为<code>null</code>，也就是没有值，那么传递的数据就会变成如下：</p>
<table>
<thead>
<tr>
<th align="center">32</th>
<th align="center">xxx</th>
<th align="center">106</th>
</tr>
</thead>
</table>
<p>但是在接收端，解析数据并按照顺序进行字段匹配的时候就会出问题：</p>
<table>
<thead>
<tr>
<th align="center">字段1：age</th>
<th align="center">字段2：name</th>
<th align="center">字段3： height</th>
<th align="center">字段4：weight</th>
</tr>
</thead>
<tbody><tr>
<td align="center">↓</td>
<td align="center">↓</td>
<td align="center">↓</td>
<td align="center">↓</td>
</tr>
<tr>
<td align="center">32</td>
<td align="center">xxx</td>
<td align="center">106</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>很明显数据已经乱套了，原本weight的值解析到了height字段，那为了解决这个问题，pb引入了一个名为<code>tag</code>的技术：</p>
<table>
<thead>
<tr>
<th align="center">tag|30</th>
<th align="center">tag|zhangsan</th>
<th align="center">tag|175.33</th>
<th align="center">tag|140</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>也就是说，每个字段我们都用<code>tag|value</code>的方式来存储的，在<code>tag</code>当中记录两种信息，一个是<code>value</code>对应的字段的编号，另一个是<code>value</code>的数据类型（比如是整形还是字符串等），因为<code>tag</code>中有字段编号信息，所以即使没有传递<code>height</code>字段的<code>value</code>值，根据编号也能正确的配对。细心的朋友可能已经发现了，乍一看这个方案跟json的key/value方案无异啊，绕了一圈又回到了原点？哈哈，莫急，让我慢慢道来。</p>
<p><strong>Tag的开销</strong></p>
<p>接着上面的问题我们继续……</p>
<p>这个问题其实问的相当好，<code>json</code>中的<code>key</code>其实是字符串，我们知道每个字符会占据一个字节，所以像<code>name</code>这个<code>key</code>就会占据4个字节，但在<code>protobuf</code>中，<code>tag</code>使用二进制进行存储，一般只会占据一个字节，它的核心代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeTag</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> fieldNumber, <span class="keyword">final</span> <span class="keyword">int</span> wireType)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (fieldNumber &lt;&lt; <span class="number">3</span>) | wireType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fieldNumber</code>表示后面的<code>value</code>所对应的字段的编号是多少，比如<code>fieldNumber</code>为1，就表示<code>age</code>，如果为2，就表示<code>name</code>等；<code>wireType</code>表示<code>value</code>的数据类型，以此来计算<code>value</code>占用字节的大小。在<code>protobuf</code>当中，<code>wireType</code>可以支持的字段类型如下：</p>
<img src="/2022/03/17/20220313-protobuf/3.png" style="zoom: 100%;">

<p>因为<code>tag</code>一般占用一个字节，开销还算是比较小的，所以<code>protobuf</code>整体的存储空间占用还是相对小了很多的。</p>
<p>看完上面的说辞是否还是不太理解，下面我来举个例子就很清晰了，例如上面的0-5种数据类型分别对应二进制位 000～101，排序第一的字段age生成的tag就是00001000，一个字节前5位表示序号后三位表示类型。</p>
<p>此时出现一个新问题，那么Tag分隔符为一个字节，如果传输的内容中出现相同的字节，会导致解析错误吗？这里就需要了解一下什么是Varint编码。</p>
<p><strong>Varint编码</strong></p>
<p>这里直接通过实例来进行说明更为直观，如图：</p>
<img src="/2022/03/17/20220313-protobuf/4.png" style="zoom: 100%;">

<p>图中对数字123456进行varint编码，123456用二进制表示为 <code>11110001001000000</code>，每次从低向高取7位再加上最高有效位变成 <code>11000000</code> <code>11000100</code> <code>00000111</code> 所以经过varint编码后123456占用三个字节分别为 <code>1921967</code>,同样解码的时候就逆向操作即可，通过这样的方式我们就省掉一个字节的开销，其实通常在实际项目我们传输的int一般来说都是比较小的，所以这样的设计也是非常ok的。</p>
<p><strong>Zigzag编码</strong></p>
<p>上面的设计看似完美，但是其实我们仔细思考一下，如果是-1这种负数改如何是好？</p>
<p>-1 –&gt; 11111111 11111111 11111111 11111111</p>
<p>如果继续采用上面的方式并不是一个好的选择，这里就不得不说zigzag编码方式了</p>
<p>直接看表格吧</p>
<table>
<thead>
<tr>
<th>原始的带符号数</th>
<th>zigzag编码后的表示</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>-1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>-2</td>
<td>3</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
</tr>
<tr>
<td>2147483647</td>
<td>4294967294</td>
</tr>
<tr>
<td>-2147483647</td>
<td>4294967295</td>
</tr>
</tbody></table>
<p>能看到编码方式就是  ：</p>
<p>负数 2 *|x| - 1  正数 2 * |x|  是不是很简单又很神奇。这里提一句即使使用该编码方式后续也还是会使用varint再进行编码的。</p>
<p><strong>Tag-Length-Value(TLV)</strong></p>
<p>我们之前讲的varint又或者是zigtag都是以传输数字为基础的，那如果我们传输的是字符串了？那么引出了另一主角TLV，Tag为分隔符，Length为长度但是我们同样采用varint编码的方式。</p>
<p>接下来我们回到最开始的问题，会出现解析错误的问题吗？</p>
<p>我们来尝试推导一下解析过程 : 如果一开始是要传输一个数字，我们拿到了第一个Tag，解析出它的fieldNumber和wireType，因为采用的是varint的编码方式（zigzag后也是采用varint再次进行编码的），高位为1表示下一个字节还是数字，如果为0则表示下一个字节就是Tag了。如果一开始传输的是一个字符串，那么拿到Tag后就知道接下来的是一个字符串，那么下一个字节就开始解析Length，Length同样还是使用varint编码，遇到高位为0后表示该Length解析完毕，我们就能拿到value的长度了，接下来按照长度取完字符串后，下一个字节就是Tag了。以此类推，pb永远都清楚的知道哪一个字节是Tag，所以现在还疑惑吗？</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Protobuf确实是目前最好的数据传输协议没有之一，当然我们不仅是要会用也要知道为啥要用～</p>
<img src="/2022/03/17/20220313-protobuf/5.jpg" style="zoom: 100%;">
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stevenhoukai.github.io/2022/02/19/20220219-pulsar-sub/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="史蒂芬猴">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/upload/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/02/19/20220219-pulsar-sub/" itemprop="url">Pulsar的订阅模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-02-19T00:00:01+08:00">
                2022-02-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pulsar/" itemprop="url" rel="index">
                    <span itemprop="name">pulsar</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面对pulsar整体的执行原理进行了一番介绍，下面来对使用实践相关，首先要介绍的就是订阅模式，订阅模式决定了消费者如何对一个topic/partition中的数据进行消费，了解其相关的知识对使用来说是至关重要的。</p>
<h2 id="订阅模式"><a href="#订阅模式" class="headerlink" title="订阅模式"></a>订阅模式</h2><p>为了适用不同场景的需求，Pulsar 支持四种订阅模式：分别是Exclusive(独占)、Shared(共享)、Failover(灾备)、Key_Shared(key共享)。下面分别对这四种模式进行一个介绍</p>
<img src="/2022/02/19/20220219-pulsar-sub/1.png" style="zoom: 50%;">

<p><strong>独占模式（Exclusive）</strong></p>
<p><strong>Exclusive 独占模式（默认模式）</strong>：一个 Subscription 只能与<strong>一个 Consumer</strong> 关联，<strong>没错，是一个！！</strong>！只有这个 Consumer 可以接收到 Topic 的全部消息，如果该 Consumer 出现故障了就会停止消费。</p>
<p>Exclusive 订阅模式下，同一个 Subscription 里只有一个 Consumer 能消费 Topic，如果多个 Consumer 订阅则会报错，适用于全局有序消费的场景。</p>
<img src="/2022/02/19/20220219-pulsar-sub/2.png" style="zoom: 50%;">

<p>当启动多个消费者时，就会报错。</p>
<p><strong>共享模式（Shared）</strong></p>
<p>消息默认通过轮询机制（也可以自定义）分发给不同的消费者，并且每个消息仅会被分发给一个消费者。当消费者断开连接，所有被发送给他，但没有被确认的消息将被重新安排，分发给其它存活的消费者。</p>
<img src="/2022/02/19/20220219-pulsar-sub/3.png" style="zoom: 50%;">

<p>这也是我们使用最频繁的一种消费模式，目前我重构的vdc基本都是使用这种模式，可以在管理端看到如下多个消费者消费同一个topic</p>
<img src="/2022/02/19/20220219-pulsar-sub/4.png" style="zoom: 50%;">

<p><strong>灾备模式（Failover）</strong></p>
<p>当存在多个 consumer 时，将会按字典顺序排序，第一个 consumer 被初始化为唯一接受消息的消费者。当第一个 consumer 断开时，所有的消息（未被确认和后续进入的）将会被分发给队列中的下一个 consumer。</p>
<img src="/2022/02/19/20220219-pulsar-sub/5.png" style="zoom: 50%;">

<p>这种模式跟第一种独占模式很相似，优势就是有备胎，主消费者挂了，备胎就会马上顶替上来。</p>
<p><strong>KEY 共享模式（Key_Shared）</strong></p>
<p>当存在多个 consumer 时，将根据消息的 key 进行分发，key 相同的消息只会被分发到同一个消费者。这种消费模式也是使用比较频繁，当我们需要对消息进行分类消费时我们就可以使用这种模式，举个例子我们的vdc系统需要消费多款不同的引擎的扫描结果，我们需要把引擎分类做不同的逻辑处理，这时就可以使用到这种消费模式了。</p>
<img src="/2022/02/19/20220219-pulsar-sub/6.png" style="zoom: 50%;">

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上我们总结了pulsar的四种消费模式，了解其相关的原理对于我们使用上是至关重要哈。</p>
<img src="/2022/02/19/20220219-pulsar-sub/5.jpg" style="zoom: 100%;">
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stevenhoukai.github.io/2022/02/16/20220216-pulsar-replicate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="史蒂芬猴">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/upload/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/02/16/20220216-pulsar-replicate/" itemprop="url">消息副本与存储机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-02-16T00:00:01+08:00">
                2022-02-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pulsar/" itemprop="url" rel="index">
                    <span itemprop="name">pulsar</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇文章对Pulsar的消息存储原理和ID规则进行了介绍，本篇文章来对消息副本以及存储机制来介绍一下。lets go</p>
<h2 id="消息元数据组成"><a href="#消息元数据组成" class="headerlink" title="消息元数据组成"></a>消息元数据组成</h2><p>Pulsar 中每个分区 Topic 的消息数据以 ledger 的形式存储在 BookKeeper 集群的 bookie 存储节点上，每个 ledger 包含一组 entry，而 bookie 只会按照 entry 维度进行写入、查找、获取。</p>
<blockquote>
<p>说明：</p>
<p>批量生产消息的情况下，一个 entry 中可能包含多条消息，所以 entry 和消息并不一定是一一对应的。</p>
</blockquote>
<p>Ledger 和 entry 分别对应不同的元数据。</p>
<ul>
<li>ledger 的元数据存储在 zk 上。</li>
<li>entry 除了消息数据部分之外，还包含元数据，entry 的数据存储在 bookie 存储节点上。</li>
</ul>
<img src="/2022/02/16/20220216-pulsar-replicate/1.png" style="zoom: 50%;">

<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">参数</th>
<th align="left">参数说明</th>
<th align="left">数据存放位置</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ledger</td>
<td align="left">ensemble size（E）</td>
<td align="left">每个 ledger 选用的 bookie 节点的个数</td>
<td align="left">元数据存储在 zk 上</td>
</tr>
<tr>
<td align="left">ledger</td>
<td align="left">write quorum size（Qw）</td>
<td align="left">每个 entry 需要向多少个 bookie 发送写入请求</td>
<td align="left">元数据存储在 zk 上</td>
</tr>
<tr>
<td align="left">ledger</td>
<td align="left">ack quorum size（Qa）</td>
<td align="left">收到多少个写入确认后，即可认为写入成功</td>
<td align="left">元数据存储在 zk 上</td>
</tr>
<tr>
<td align="left">ledger</td>
<td align="left">Ensembles（E）</td>
<td align="left">使用的 ensemble 列表，形式为&lt;entry id=””, ensembles=””&gt; 元组key（entry id）：使用这个 ensembles 列表开始时的 entry idvalue（ensembles）：ledger 选用的 bookie ip 列表，每个 value 中包含 ensemble size （E）个 IP每个 ledger 可能包含多个 ensemble 列表，同一时刻每个 ledger 最多只有一个 ensembles 列表在使用</td>
<td align="left">元数据存储在 zk 上</td>
</tr>
<tr>
<td align="left">Entry</td>
<td align="left">Ledger ID</td>
<td align="left">entry 所在的 ledger id</td>
<td align="left">数据存储在 bookie 存储节点上</td>
</tr>
<tr>
<td align="left">Entry</td>
<td align="left">Entry ID</td>
<td align="left">当前 entry id</td>
<td align="left">数据存储在 bookie 存储节点上</td>
</tr>
<tr>
<td align="left">Entry</td>
<td align="left">Last Add Confirmed</td>
<td align="left">创建当前 entry 的时候，已知最新的写入确认的 entry id</td>
<td align="left">数据存储在 bookie 存储节点上</td>
</tr>
<tr>
<td align="left">Entry</td>
<td align="left">Digest</td>
<td align="left">CRC</td>
<td align="left">数据存储在 bookie 存储节点上</td>
</tr>
</tbody></table>
<p>每个 ledger 在创建的时候，会在现有的 BookKeeper 集群中的可写状态的 bookie 候选节点列表中，选用 ensemble size 对应个数的 bookie 节点，如果没有足够的候选节点则会抛出 BKNotEnoughBookiesException 异常。选出候选节点后，将这些信息组成 &lt;entry id, ensembles&gt; 元组，存储到 ledger 的元数据里的 ensembles 中。</p>
<h2 id="消息副本机制"><a href="#消息副本机制" class="headerlink" title="消息副本机制"></a>消息副本机制</h2><p><strong>消息写入流程</strong></p>
<img src="/2022/02/16/20220216-pulsar-replicate/2.png" style="zoom: 60%;">

<p>客户端在写入消息时，每个 entry 会向 ledger 当前使用的 ensemble 列表中的 Qw 个 bookie 节点发送写入请求，当收到 Qa 个写确认后，即认为当前消息写入存储成功。同时会通过 LAP（lastAddPushed）和 LAC（LastAddConfirmed）分别标识当前推送的位置和已经收到存储确认的位置。</p>
<p>每个正在推送的 entry 中的 LAC 元数据值，为当前时刻创建发送 entry 请求时，已经收到最新的确认位置值。LAC 所在位置及之前的消息对读客户端是可见的。</p>
<p>同时，pulsar 通过 fencing 机制，来避免同时有多个客户端对同一个 ledger 进行写操作。这里主要适用于一个 topic/partition 的归属关系从一个 broker 变迁到另一个 broker 的场景。</p>
<p><strong>消息副本分布</strong></p>
<p>每个 entry 写入时，会根据当前消息的 entry id 和当前使用的 ensembles 列表的开始 entry id（即key值），计算出在当前 entry 需要使用 ensemble 列表中由哪组 Qw 个 bookie 节点进行写入。之后，broker 会向这些 bookie 节点发送写请求，当收到 Qa 个写确认后，即认为当前消息写入存储成功。这时至少能够保证 Qa 个消息的副本个数。</p>
<img src="/2022/02/16/20220216-pulsar-replicate/3.png" style="zoom: 50%;">

<p>如上图所示，ledger 选用了4个 bookie 节点（bookie1-4 这4个节点），每次写入3个节点，当收到2个写入确认即代表消息存储成功。当前 ledger 选中的 ensemble 从 entry 1开始，使用 bookie1、bookie2、bookie3 进行写入，写入 entry 2的时候选用 bookie2、bookie3、bookie4写入，而 entry 3 则会根据计算结果，写入 bookie3、bookie4、bookie1。</p>
<h2 id="消息恢复机制"><a href="#消息恢复机制" class="headerlink" title="消息恢复机制"></a>消息恢复机制</h2><p>Pulsar 的 BookKeeper 集群中的每个 bookie 在启动的时候，默认自动开启 recovery 的服务，这个服务会进行如下几个事情：</p>
<ol>
<li>auditorElector 审计选举。</li>
<li>replicationWorker 复制任务。</li>
<li>deathWatcher 宕机监控。</li>
</ol>
<p>BookKeeper 集群中的每个 bookie 节点，会通过 zookeeper 的临时节点机制进行选主，主 bookie 主要处理如下几个事情：</p>
<ol>
<li>负责监控 bookie 节点的变化。</li>
<li>到 zk 上面标记出宕机的 bookie 上面的 ledger 为 Underreplicated 状态。</li>
<li>检查所有的 ledger 的副本数（默认一周一个周期）。</li>
<li>Entry 副本数检查（默认未开启）。</li>
</ol>
<p>其中 ledger 中的数据是按照 Fragment 维度进行恢复的（每个 Fragment 对应 ledger 下的一组 ensemble 列表，如果一个 ledger 下有多个 ensemble 列表，则需要处理多个 Fragment）。</p>
<p>在进行恢复时，首先要判断出当前的 ledger 中的哪几个 Fragment 中的哪些存储节点需要用新的候选节点进行替换和恢复数据。当 Fragment 中关联的部分 bookie 节点上面没有对应的 entry 数据（默认是按照首、尾 entry 是否存在判断），则这个 bookie 节点需要被替换，当前的这个 Fragment 需要进行数据恢复。</p>
<p>Fragment 的数据用新的 bookie 节点进行数据恢复完毕后，更新 ledger 的元数据中当前 Fragment 对应的 ensemble 列表的原数据。</p>
<p>经过此过程，因 bookie 节点宕机引起的数据副本数减少的场景，数据的副本数会逐步的恢复成 Qw（后台指定的副本数，TDMQ 默认3副本）个。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="/2022/02/16/20220216-pulsar-replicate/5.jpg" style="zoom: 100%;">
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stevenhoukai.github.io/2022/02/15/20220215-pulsar-storage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="史蒂芬猴">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/upload/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/02/15/20220215-pulsar-storage/" itemprop="url">消息存储原理与 ID 规则</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-02-15T00:00:01+08:00">
                2022-02-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pulsar/" itemprop="url" rel="index">
                    <span itemprop="name">pulsar</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇文章对Pulsar的topic和分区做了介绍，这一篇我们就来对消息存储原理和ID规则来进行一下介绍，在本篇介绍中可能会出现一些让你非常困惑的词汇。不过不要紧我都会一一来进行解释</p>
<h2 id="消息-ID-生成规则"><a href="#消息-ID-生成规则" class="headerlink" title="消息 ID 生成规则"></a>消息 ID 生成规则</h2><p>在 Pulsar 中，每条消息都有属于的自己的唯一 ID（即 MessageID），MessageID 由四部分组成：<code>ledgerId:entryID:partition-index:batch-index</code>。其中：</p>
<ul>
<li>partition-index：指分区的编号，在非分区 topic 的时候为 -1。</li>
<li>batch-index：在非批量消息的时候为 -1。</li>
</ul>
<p>消息 ID 的生成规则由 Pulsar 的消息存储机制决定，Pulsar 中消息存储原理图如下：</p>
<img src="/2022/02/15/20220215-pulsar-storage/1.png" style="zoom: 50%;">

<p>如上图所示，在 Pulsar中，一个 Topic 的每一个分区会对应一系列的 ledger，其中只有一个 ledger 处于 open 状态即可写状态，而每个 ledger 只会存储与之对应的分区下的消息。</p>
<p>Pulsar 在存储消息时，会先找到当前分区使用的 ledger ，然后生成当前消息对应的 entry ID，entry ID 在同一个 ledger 内是递增的。每个 ledger 存在的时长或保存的 entry 个数超过阈值后会进行切换，新的消息会存储到同一个 partition 中的下一个 ledger 中。</p>
<ul>
<li>批量生产消息情况下，一个 entry 中可能包含多条消息。</li>
<li>非批量生产的情况下，一个 entry 中包含一条消息（producer 端可以配置这个参数，默认是批量的）。</li>
</ul>
<p>Ledger 只是一个逻辑概念，是数据的一种逻辑组装维度，并没有对应的实体。而 bookie 只会按照 entry 维度进行写入、查找、获取。</p>
<h2 id="分片机制详解：Legder-和-Entry"><a href="#分片机制详解：Legder-和-Entry" class="headerlink" title="分片机制详解：Legder 和 Entry"></a>分片机制详解：Legder 和 Entry</h2><p>Pulsar 中的消息数据以 ledger 的形式存储在 BookKeeper 集群的 bookie 存储节点上。Ledger 是一个只追加的数据结构，并且只有一个写入器，这个写入器负责多个 bookie 的写入。Ledger 的条目会被复制到多个 bookie 中，同时会写入相关的数据来保证数据的一致性。</p>
<p>BookKeeper 需要保存的数据包括：</p>
<ul>
<li><strong>Journals</strong><ul>
<li>journals 文件里存储了 BookKeeper 的事务日志，在任何针对 ledger 的更新发生前，都会先将这个更新的描述信息持久化到这个 journal 文件中。</li>
<li>BookKeeper 提供有单独的 sync 线程根据当前 journal 文件的大小来作 journal 文件的 rolling。</li>
</ul>
</li>
<li><strong>EntryLogFile</strong><ul>
<li>存储真正数据的文件，来自不同 ledger 的 entry 数据先缓存在内存buffer中，然后批量flush到EntryLogFile中。</li>
<li>默认情况下，所有ledger的数据都是聚合然后顺序写入到同一个EntryLog文件中，避免磁盘随机写。</li>
</ul>
</li>
<li><strong>Index 文件</strong><ul>
<li>所有 Ledger 的 entry 数据都写入相同的 EntryLog 文件中，为了加速数据读取，会作 ledgerId + entryId 到文件 offset 的映射，这个映射会缓存在内存中，称为 IndexCache。</li>
<li>IndexCache 容量达到上限时，会被 sync 线程 flush 到磁盘中。</li>
</ul>
</li>
</ul>
<img src="/2022/02/15/20220215-pulsar-storage/2.png" style="zoom: 50%;">

<p>刚开始看到这里的时候我是有点懵逼的，这都是些啥啊，但是后面仔细思考下，这个设计似乎和mysql的底层原理几乎一致，Journals相当于redolog，EntryLogFile+Index相当于bufferpool。还不明白那就接着看下面的介绍：</p>
<p><strong>Entry 数据写入</strong></p>
<ol>
<li>数据首先会同时写入 Journal（写入 Journal 的数据会实时落到磁盘）和 Memtable（读写缓存）。</li>
<li>写入 Memtable 之后，对写入请求进行响应。</li>
<li>Memtable 写满之后，会 flush 到 Entry Logger 和 Index cache，Entry Logger 中保存数据，Index cache 中保存数据的索引信息，</li>
<li>后台线程将 Entry Logger 和 Index cache 数据落到磁盘。</li>
</ol>
<p><strong>Entry 数据读取</strong></p>
<ul>
<li>Tailing read 请求：直接从 Memtable 中读取 Entry。</li>
<li>Catch-up read（滞后消费）请求：先读取 Index信息，然后索引从 Entry Logger 文件读取 Entry。</li>
</ul>
<p><strong>数据一致性保证：LastLogMark</strong></p>
<ul>
<li>写入的 EntryLog 和 Index 都是先缓存在内存中，再根据一定的条件周期性的 flush 到磁盘，这就造成了从内存到持久化到磁盘的时间间隔，如果在这间隔内 BookKeeper 进程崩溃，在重启后，我们需要根据 journal 文件内容来恢复，这个 LastLogMark 就记录了从 journal 中什么位置开始恢复。</li>
<li>它其实是存在内存中，当 IndexCache 被 flush 到磁盘后其值会被更新，LastLogMark 也会周期性持久化到磁盘文件，供 Bookkeeper 进程启动时读取来从 journal 中恢复。</li>
<li>LastLogMark 一旦被持久化到磁盘，即意味着在其之前的 Index 和 EntryLog 都已经被持久化到了磁盘，那么 journal 在这 LastLogMark 之前的数据都可以被清除了。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="/2022/02/15/20220215-pulsar-storage/5.jpg" style="zoom: 100%;">
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stevenhoukai.github.io/2022/02/14/20220214-pulsar-arch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="史蒂芬猴">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/upload/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/02/14/20220214-pulsar-arch/" itemprop="url">Pulsar Topic 和分区</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-02-14T00:00:01+08:00">
                2022-02-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pulsar/" itemprop="url" rel="index">
                    <span itemprop="name">pulsar</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本人最近正在重构一个vdc（virus detect center）系统，为了将旧系统解耦我们将原系统拆分成了很多子系统，系统之间通过mq进行交互，在这之前本人对kafka已经是有些许了解，但是这次小组决定使用pulsar来替代kafka，那么究竟pulsar有什么好，它较kafka到底有什么优势，本人接下来的一个系列篇章就会对pulsar来进行介绍，同时也会讲解实际使用中的一些用法与问题，本系列文章的前提是假定大家对kafka都是一定了解的。</p>
<h2 id="Apache-Pulsar-架构"><a href="#Apache-Pulsar-架构" class="headerlink" title="Apache Pulsar 架构"></a>Apache Pulsar 架构</h2><p>Apache Pulsar 是一个发布-订阅模型的消息系统，由 Broker、Apache BookKeeper、Producer、Consumer 等组件组成。我们知道传统mq的组成是没有Apache BookKeeper这一组件的，那么这个Apache BookKeeper究竟是何方神圣，后面我们会详细说一说</p>
<p>先看一张整体的结构图：</p>
<img src="/2022/02/14/20220214-pulsar-arch/1.png" style="zoom: 50%;">

<ul>
<li>Producer ： 消息的生产者，负责发布消息到 Topic。</li>
<li>Consumer：消息的消费者，负责从 Topic 订阅消息。</li>
<li>Broker：无状态服务层，负责接收和传递消息，集群负载均衡等工作，Broker 不会持久化保存元数据，因此可以快速的上、下线。</li>
<li>Apache BookKeeper：有状态持久层，由一组 Bookie 存储节点组成，可以持久化地存储消息。</li>
</ul>
<p>了解kafka的朋友相信一眼就能看出一些异样，那就是kafka的存储其实就是放在broker上面的，也就是说存储与计算实际上是一体的，而从上图可知 Apache Pulsar 在架构设计上采用了计算与存储分离的模式，消息发布和订阅相关的计算逻辑在 Broker 中完成，数据存储在 Apache BookKeeper 集群的 Bookie 节点上。</p>
<h2 id="Topic-与分区"><a href="#Topic-与分区" class="headerlink" title="Topic 与分区"></a>Topic 与分区</h2><p>Topic（主题）是某一种分类的名字，消息在 Topic 中可以被存储和发布。生产者往 Topic 中写消息，消费者从 Topic 中读消息。</p>
<p>Pulsar 的 Topic 分为 Partitioned Topic 和 Non-Partitioned Topic 两类，Non-Partitioned Topic 可以理解为一个分区数为1的 Topic。实际上在 Pulsar 中，Topic 是一个虚拟的概念，创建一个3分区的 Topic，实际上是创建了3个“分区Topic”，发给这个 Topic 的消息会被发往这个 Topic 对应的多个 “分区Topic”。<br>例如：生产者发送消息给一个分区数为3，名为<code>my-topic</code>的 Topic，在数据流向上是均匀或者按一定规则（如果指定了key）发送给了 <code>my-topic-partition-0</code>、<code>my-topic-partition-1</code> 和 <code>my-topic-partition-2</code> 三个“分区 Topic”。</p>
<p>分区 Topic 做数据持久化时，分区是逻辑上的概念，实际存储的单位是分片（Segment）的。</p>
<p>如下图所示，分区 Topic1-Part2 的数据由N个 Segment 组成， 每个 Segment 均匀分布并存储在 Apache BookKeeper 群集中的多个 Bookie 节点中， 每个 Segment 具有3个副本。</p>
<img src="/2022/02/14/20220214-pulsar-arch/2.png" style="zoom: 50%;">



<h2 id="物理分区与逻辑分区"><a href="#物理分区与逻辑分区" class="headerlink" title="物理分区与逻辑分区"></a>物理分区与逻辑分区</h2><p>逻辑分区和物理分区对比如下：</p>
<img src="/2022/02/14/20220214-pulsar-arch/3.png" style="zoom: 60%;">

<p><strong>物理分区：</strong>计算与存储耦合，容错需要拷贝物理分区，扩容需要迁移物理分区来达到负载均衡。</p>
<p><strong>逻辑分区</strong>：物理“分片”，计算层与存储层隔离，这种结构使得 Apache Pulsar 具备以下优点。</p>
<ul>
<li>Broker 和 Bookie 相互独立，方便实现独立的扩展以及独立的容错。</li>
<li>Broker 无状态，便于快速上、下线，更加适合于云原生场景。</li>
<li>分区存储不受限于单个节点存储容量。</li>
<li>分区数据分布均匀，单个分区数据量突出不会使整个集群出现木桶效应。</li>
<li>存储不足扩容时，能迅速利用新增节点平摊存储负载。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="/2022/02/14/20220214-pulsar-arch/5.jpg" style="zoom: 100%;">
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stevenhoukai.github.io/2021/10/10/20211010-guitar/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="史蒂芬猴">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/upload/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/10/10/20211010-guitar/" itemprop="url">和弦的构成（分析）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-10-10T00:00:01+08:00">
                2021-10-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/乐理/" itemprop="url" rel="index">
                    <span itemprop="name">乐理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>弹了有段时间的吉他的，一直对吉他乐理方面没有做一个系统的分析，今天来对常用3和弦和7和弦做一个完整的分析以及公式总结</p>
<h2 id="3和弦"><a href="#3和弦" class="headerlink" title="3和弦"></a>3和弦</h2><ul>
<li><p>大3和弦（大三度+小三度）</p>
<p>例如：<br>C和弦 组成音： 1 &lt;大三度&gt; 3 &lt;小三度&gt; 5<br>D和弦 组成音： 2 &lt;大三度&gt; 4(#) &lt;小三度&gt; 6 </p>
<p>同理可推导<br>G和弦 组成音：5 &lt;大三度&gt; 7 &lt;小三度&gt; 2^</p>
</li>
<li><p>小3和弦（小三度+大三度）</p>
<p>例如：<br>Cm和弦 组成音： 1 &lt;小三度&gt; 3(b) &lt;大三度&gt; 5<br>Dm和弦 组成音： 2 &lt;小三度&gt; 4 &lt;大三度&gt; 6</p>
<p>同理可以推导</p>
<p>Gm和弦 组成音： 5 &lt;小三度&gt; 7(b) &lt;大三度&gt; 2^</p>
</li>
<li><p>增3和弦（大三度+大三度）</p>
<p>例如：C+或者 Caug</p>
</li>
<li><p>减3和弦（小三度+小三度）</p>
<p>例如：C- 或者 Cdim</p>
</li>
</ul>
<h2 id="7和弦"><a href="#7和弦" class="headerlink" title="7和弦"></a>7和弦</h2><p>记得看中国好声音时，李荣浩说leehom的《爱错》中的bridge中那句在这少了你的世界那里的7减5和弦让他头皮发麻，这就来看看啥是7减5和弦，其实那时说7减5的时候王力宏是懵逼的，专业叫法应该叫半减7和弦。</p>
<ul>
<li><p>大小7和弦（属7和弦）（大三和弦+小7度）[小7度就是包含两个半音，大7度就是包含一个半音]</p>
<p>例如：</p>
<p>C7和弦组成音本质就是 C和弦+小7度（1 3 5 + 7(b)）</p>
<p>F7和弦组成音本质就是 F和弦+小7度（4 6 1^ + 3^(b)）</p>
</li>
<li><p>小7和弦（小三和弦+小7度）</p>
<p>例如：</p>
<p>Cm7和弦的组成音本质就是 Cm和弦+小7度 （1 3(b) 5 7(b)）</p>
</li>
<li><p>大7和弦（大三和弦+大7度）</p>
<p>例如：</p>
<p>Cmaj7和弦组成音本质就是C和弦+大7度（1 3 5 + 7）</p>
<p>Fmaj7和弦组成音本质就是F和弦+大7度 （4 6 1^ 3^）</p>
</li>
<li><p>小大7和弦（小三和弦+大7度）</p>
<p>例如：</p>
<p>Cmmaj7和弦组成音本质就是Cm和弦+大7度（1 3(b) 5 7）</p>
</li>
<li><p>半减7和弦</p>
<p>例如：</p>
<p>Bm7-5 这个和弦就是上面说到的让李荣浩头皮发麻的7-5和弦了，没错这种和弦的收缩性非常强，用到合适的地方确实会头皮发麻。</p>
<p>那么这个和弦的本质其实就是Bm和弦(7 2^ 4^(#) + 小7度 + 5音降半音 ( 7 2^ 4^ 6^)</p>
<p>所以通过公式我们也可以推到出Ammaj7-5和弦的组成音了，哈哈哈 虽然这个和弦不一定存在。</p>
</li>
</ul>
<h2 id="和弦色彩"><a href="#和弦色彩" class="headerlink" title="和弦色彩"></a>和弦色彩</h2><p>今天不打算对和弦色彩进行总结，但是要提一句的是，和弦色彩对于编配来说实在是太重要了，就好像一首歌你可以用4536251去完成，你也可以用分割和弦 5/4去代替其中的5，但是两者表达出来的色彩是完全不一样的。后面会对和弦色彩进行一次详细的记录。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>像我这种业余玩流行音乐的，和弦其实是一个非常重要的理论基础，就像我们写程序你要写好代码就一定要懂原理，老实说其实掌握一些和弦套路例如6451，4536251还有17654325(卡农和弦)低音下行这些后基本上流行乐坛百分之70的歌你都能弹唱了，无非就是一首换一首，就像你你做开发选用的是dubbo框架还是springcloud框架一样。但是如果想玩的更有趣一点就需要去了解这些框架的构成原理了。</p>
<p><img src="/2021/10/10/20211010-guitar/6.jpg" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stevenhoukai.github.io/2021/10/08/20211008-cdk/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="史蒂芬猴">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/upload/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/10/08/20211008-cdk/" itemprop="url">如何搭建一个高性能cdk系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-10-08T00:00:01+08:00">
                2021-10-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工作沉淀/" itemprop="url" rel="index">
                    <span itemprop="name">工作沉淀</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本人前不久稍稍改进了一个cdkey系统，来总结下是如何设计一个cdkey(兑换码)系统的，本文打算从以下三个方面来说。</p>
<ul>
<li>cdkey兑换</li>
<li>如何生成cdkey以及如何存储</li>
<li>如何保证高可用</li>
</ul>
<h2 id="cdkey兑换"><a href="#cdkey兑换" class="headerlink" title="cdkey兑换"></a>cdkey兑换</h2><p>cdkey本身只是一种推广售卖方式，其实不用也是可以的，不过市面上的商品一般除了正常的收费购买之外一定会伴随有cdkey售卖这样的方式。一个cdkey就对应着一个具体的商品，这也意味着cdkey是需要与商品以及订进行绑定的，举个例子，类似这样的一串字符串XXX3XXXNLMX1YEXXX就是cdkey的一个样式，是一个36进制构成的16位表达式，一般先由系统提前生成好然后下发出去售卖或者活动赠送等，兑换的时候做一些校验工作然后是生成订单流程，订单流程走完之后最后将订单号与cdkey绑定并将其状态更改成已兑换。流程如下图:</p>
<p>流程图因涉及到公司的业务流转 不方便在此贴出</p>
<h2 id="如何生成cdkey以及如何存储"><a href="#如何生成cdkey以及如何存储" class="headerlink" title="如何生成cdkey以及如何存储"></a>如何生成cdkey以及如何存储</h2><p>上一节提到目前系统的cdkey是一个36进制的16位表达式，针对36进制我们可以预先定义一个数组：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">myVal = []<span class="keyword">string</span>&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>, <span class="string">"K"</span>, <span class="string">"L"</span>, <span class="string">"M"</span>, <span class="string">"N"</span>, <span class="string">"O"</span>, <span class="string">"P"</span>,<span class="string">"Q"</span>, <span class="string">"R"</span>, <span class="string">"S"</span>, <span class="string">"T"</span>, <span class="string">"U"</span>, <span class="string">"V"</span>, <span class="string">"W"</span>, <span class="string">"X"</span>, <span class="string">"Y"</span>, <span class="string">"Z"</span>,<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>&#125;</span><br><span class="line"><span class="comment">//生成一个cdk的代码，所以是有可能一批cdk里面产生重复的，必须做好本地去重</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genOneKey</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	buf.Reset()</span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">16</span>; j++ &#123;</span><br><span class="line">		val := rand.Intn(<span class="built_in">len</span>(myVal))</span><br><span class="line">		buf.WriteString(myVal[val])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然为了安全我们也可以将上述的数组顺序随意打乱，这种方式在上一篇短链系统设计的时候已经用过一次了，只不过短链用的是64进制而已。我们也可以使用64进制来降低cdkey生成时的碰撞率，不过就cdkey而言为了美观一般就不掺杂小写字母了。本人目前的需求是需要支持大批量cdk申请的，单批次申请需要支持10w，所以我这边cdkey的生成实际是按批次生成的，这样的好处就是可以减少与数据库的网络IO，每次生成一批cdkey然后去数据库校验是否存在，存在了就重试生成一批新cdkey再校验，直到校验不存在就插入数据库然后生成下一批，反复执行直到申请数量全部生成完毕。</p>
<p>总体流程图如下：</p>
<p><img src="/2021/10/08/20211008-cdk/2.png" alt></p>
<p>接下来是单批次生成cdk详细逻辑:</p>
<p><img src="/2021/10/08/20211008-cdk/3.png" alt></p>
<p>给出表设计方案 : </p>
<p>下面的表中很多字段都是与具体业务相关的，不必过于关心，但是核心的字段在一个cdk系统中基本上都是不变的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//因为表设计也有相关敏感信息不方便在此处贴出具体字段</span><br><span class="line">//cdk订单申请表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`cdk_order`</span> (</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COMMENT</span>=<span class="string">'cdk申请单表'</span></span><br><span class="line"></span><br><span class="line">//cdk详情表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`cdk_detail`</span> (</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COMMENT</span>=<span class="string">'cdk明细表'</span></span><br></pre></td></tr></table></figure>

<h2 id="如何保证高可用"><a href="#如何保证高可用" class="headerlink" title="如何保证高可用"></a>如何保证高可用</h2><p>一般来说通过集群部署可解决系统高可用问题，但是集群部署就会导致新的问题，可能两个服务节点同时工作产生的cdkey就有可能会出现交集本地去重并不能解决问题，这里我列出了两种方案来解决这个问题，就当前情况而言本人采用了第一种方案:</p>
<ul>
<li><p>方案一：通过数据库自身来解决该问题</p>
<p>上一节介绍的方案就是了，通过数据库校验 + 事务 + 重试来解决</p>
</li>
<li><p>方案二：通过分布式锁+bloomfilter来解决这个问题</p>
<p>见方案设计图:</p>
<p><img src="/2021/10/08/20211008-cdk/4.png" alt></p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对cdk系统设计方案作了一点总结，整体的思路就是要减少碰撞，保证申请数量与实际生成数量一致，并且要防止一次性提交数据量过大，具体最后的高可用方案哪种更合适还是依据实际情况再做定夺为佳。</p>
<p><img src="/2021/10/08/20211008-cdk/5.jpg" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stevenhoukai.github.io/2021/09/27/20210927-shorturl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="史蒂芬猴">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/upload/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/09/27/20210927-shorturl/" itemprop="url">高性能短链系统的一些设计思考</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-09-27T00:00:01+08:00">
                2021-09-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工作沉淀/" itemprop="url" rel="index">
                    <span itemprop="name">工作沉淀</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近遇到一个需求，需要短时间内将大量的长链转换成短链然后再转成二维码，由于我们的短链服务是通过接口外部进行调用的，而且不能批量转换，所以这里就会出现一个情况就是短时间的大量请求接口会以失败告终，如果能自己设计一个短链系统，这个问题就能解决了。那么今天就来谈谈如何设计一个高性能短链系统。</p>
<p>本文将会从以下几个方面来进行探讨 </p>
<ul>
<li>为啥要用短链 长链存在哪些问题</li>
<li>短链是如何实现跳转的</li>
<li>如何生成短链以及如何存储</li>
<li>如何保证高性能高可用</li>
</ul>
<h2 id="为啥要用短链-长链存在哪些问题"><a href="#为啥要用短链-长链存在哪些问题" class="headerlink" title="为啥要用短链 长链存在哪些问题"></a>为啥要用短链 长链存在哪些问题</h2><p>下面是自如给我发的推送短信，点击下方蓝色的链接（短链）</p>
<p><img src="/2021/09/27/20210927-shorturl/1.png" alt="img"></p>
<p>浏览器接着会跳转到一个确认跳转页面。</p>
<p><img src="/2021/09/27/20210927-shorturl/2.jpeg" alt="img"></p>
<p>那么为啥要用短链表示，直接用长链不行吗，用短链的话有如下好外</p>
<p>1、链接变短，在对内容长度有限制的平台发文，可编辑的文字就变多了</p>
<p>最典型的就是微博，限定了只能发 140 个字，如果一串长链直接怼上去，其他可编辑的内容就所剩无几了，用短链的话，链接长度大大减少，自然可编辑的文字多了不少。</p>
<p>再比如上面的短信如果一个长链直接怼上去满屏都是一个链接，非常不美观。</p>
<p>2、像我前言中的需求需要将链接转成二维码，如果是长链的话二维码非常密集而且很难识别，短链的话就会清爽很多,如下图所示</p>
<p><img src="/2021/09/27/20210927-shorturl/3.png" alt="img"></p>
<p>3、链接太长在有些平台上无法自动识别为超链接</p>
<h2 id="短链是如何实现跳转的"><a href="#短链是如何实现跳转的" class="headerlink" title="短链是如何实现跳转的"></a>短链是如何实现跳转的</h2><p>从上文可知，短链好处多多，那么它是如何工作的呢。我们在浏览器抓下包看看</p>
<p><img src="/2021/09/27/20210927-shorturl/10.png" alt="img"></p>
<p>可以看到请求后，返回了状态码 302（重定向）与 location 值为长链的响应，然后浏览器会再请求这个长链以得到最终的响应,整个交互流程图如下</p>
<p><img src="/2021/09/27/20210927-shorturl/11.png" alt="img"></p>
<p>主要步骤就是访问短网址后重定向访问 B，那么问题来了，301 和 302 都是重定向，到底该用哪个，这里需要注意一下 301 和 302 的区别</p>
<ul>
<li>301，代表 <strong>永久重定向</strong>，也就是说第一次请求拿到长链接后，下次浏览器再去请求短链的话，不会向短网址服务器请求了，而是直接从浏览器的缓存里拿，这样在 server 层面就无法获取到短网址的点击数了，如果这个链接刚好是某个活动的链接，也就无法分析此活动的效果。所以我们一般不采用 301。</li>
<li><strong>302</strong>，代表 <strong>临时重定向</strong>，也就是说每次去请求短链都会去请求短网址服务器（除非响应中用 Cache-Control 或 Expired 暗示浏览器缓存）,这样就便于 server 统计点击数，所以虽然用 302 会给 server 增加一点压力，但在数据异常重要的今天，这点代码是值得的，所以推荐使用 302！</li>
</ul>
<h2 id="如何生成短链以及如何存储"><a href="#如何生成短链以及如何存储" class="headerlink" title="如何生成短链以及如何存储"></a>如何生成短链以及如何存储</h2><h3 id="1、Hash"><a href="#1、Hash" class="headerlink" title="1、Hash"></a>1、Hash</h3><p>短链怎么生成，我的第一反应,这不就是以不定长输入(长链)转换成定长输出(短链)【哈希的定义】，观察上面的短链很明显可以看到短链是由固定短链域名 + 长链映射成的一串字母组成(不定长输入–&gt;定长输出)，那么这个哈希函数该怎么取呢，相信肯定有很多人说用 MD5，SHA 等算法，网上确实有很多是用md5先生成32位串，然后均分4段做hash处理，最后再随机取其中之一作为最后结果，只是我在想这个md5先生成32位串是否一定有必要，而且既然是加密就意味着性能上会有损失，其实我觉得这里的重点应该是hash并不是加解密，如何提升哈希的运算速度和减少冲突概率才是重点。以下属于借鉴内容了这里推荐 Google 出品的 <strong>MurmurHash 算法</strong>，MurmurHash 是一种<strong>非加密型</strong>哈希函数，适用于一般的哈希检索操作。与其它流行的哈希函数相比，对于规律性较强的 key，MurmurHash 的随机分布特征表现更良好。非加密意味着着相比 MD5，SHA 这些函数它的性能肯定更高（实际上性能是 MD5 等加密算法的十倍以上），也正是由于它的这些优点，所以虽然它出现于 2008，但目前已经广泛应用到 Redis、MemCache、Cassandra、HBase、Lucene 等众多著名的软件中。</p>
<p>MurmurHash 提供了两种长度的哈希值，32 bit，128 bit，为了让网址尽可通地短，我们选择 32 bit 的哈希值，<strong>32 bit 能表示的最大值近 43 亿</strong>，对于中小型公司的业务而言绰绰有余。对上文提到的极客长链做 MurmurHash 计算，得到的哈希值为 3002604296，于是我们现在得到的短链为 固定短链域名+哈希值 = <a href="http://xxx.com/a/3002604296" target="_blank" rel="noopener">http://xxx.com/a/3002604296</a></p>
<p><strong>上述结果还是有点长？</strong></p>
<p>觉得10位的短链还是有点长怎么办？首先3002604296 这个结果是10进制数字，有一种方案就是将它转为 62 进制就可以缩短它的长度，10 进制转 62 进制如下，也就是按62取模，对应的余数在下面的字符串中取对应值：</p>
<p>62进制思路 : 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</p>
<p><img src="/2021/09/27/20210927-shorturl/7.png" alt="img"></p>
<p>经过上面的取模运算然后取映射值，就可以将(3002604296)10进制数字转换成 (3hcCxy)62进制，立马又缩短了4位，因此最终的短链为 <a href="http://xxx.com/a/3hcCxy，6" target="_blank" rel="noopener">http://xxx.com/a/3hcCxy，6</a> 位 62 进制数可表示 568 亿的数，应付长链转换绰绰有余，如果需要更短一点也是可以的，根据实际需求进行取舍吧，我们公司目前用的是8位<a href="https://xxx.com/r8CpSjCN" target="_blank" rel="noopener">https://xxx.com/r8CpSjCN</a></p>
<p><strong>hash冲突了怎么办？</strong></p>
<p>既然是哈希函数，那么很有可能两个不同的长链经过hash之后生成的短链是一样的，那么这个问题要怎么解决？这里给出的思路就是在长链的基础上添加随机字符串然后重试生成短链。</p>
<p>由上文知道访问短链能跳转到长链，那么长短链的关系一定是有一个地方存储的， <strong>Redis 或 Mysql</strong> ？，一般来说 Mysql 存储首选，redis缓存首选。表结构如下所示</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`long_short_url_map`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`long_url`</span> <span class="built_in">varchar</span>(<span class="number">160</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'长链'</span>,</span><br><span class="line">  <span class="string">`short_url`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'短链'</span>,</span><br><span class="line">  <span class="string">`created_at`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span></span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<p>基于上面的组件可以做出如下的设计。</p>
<ol>
<li>长链（longurl）经过 MurmurHash 后取模62得到最终短链。</li>
<li>再根据短链去 long_short_url_map 表中查找看是否存在相关记录，如果不存在，将长链与短链对应关系插入数据库中，存储。</li>
<li><strong>如果存在，说明已经有相关记录了，此时在长串上拼接一个自定义好的字段，比如「duplicate+RandomNum」，「longurl + duplicate+RandomNum」去重试第一步操作，如果最后还是重复就继续重拾，如果没有重复了就把原longurl和短链的关系存储即可</strong>。</li>
</ol>
<p>上面的步骤是没有加入缓存的，插入一条记录是需要经过两次(甚至三次(概率微乎其微)) sql 查询（1.根据短链查记录是否存在 2.将长短链对应关系插入数据库中），像我前言中的需求在高并发下，明显还是会有瓶颈出现的。一般数据库和应用服务（只做计算不做存储）会部署在两台不同的 server 上，执行两条 sql 就需要两次网络通信，<strong>这两次网络通信与两次 sql 执行是整个短链系统的性能瓶颈所在</strong>！</p>
<p>引入缓存减少第一次的sql查询？</p>
<p>很显然插入数据那一次的sql肯定没跑了，无论怎样那一次的sql都是要执行的</p>
<ol>
<li>方案一 : 给短链字段 short_url 加上<strong>唯一索引</strong>，把唯一性校验直接交给数据库去做，可行但是数据库压力很大（唯一索引懂的都懂）</li>
<li>方案二 : 数据量很大的情况下，冲突的概率会增大，此时我们可以使用加<strong>Bloomfilter</strong>(缓存)来进行优化。</li>
</ol>
<p><strong>用所有生成的短网址构建布隆过滤器</strong>，当一个新的长链生成短链后，先将此短链在Bloomfilter中进行查找，如果不存在，说明 db 里不存在此短网址，可以插入，插入db之前先将短链放入Bloomfilter。Bloomfilter是一种非常省内存的数据结构，长度为 10 亿的布隆过滤器，只需要 125 M 的内存空间。</p>
<p>综上，如果用哈希函数来设计，总体的设计思路如下</p>
<p><img src="/2021/09/27/20210927-shorturl/5.png" alt="img"></p>
<p>用哈希算法生成的短链其实已经能满足我们的业务需求，本人目前工作中遇到的短链就是用hash生成的只不过保留的是8位。其实还有另外一种是通过自增序列</p>
<h3 id="2、Sequence"><a href="#2、Sequence" class="headerlink" title="2、Sequence"></a>2、Sequence</h3><p>待完善</p>
<h2 id="高性能短链的架构设计"><a href="#高性能短链的架构设计" class="headerlink" title="高性能短链的架构设计"></a>高性能短链的架构设计</h2><p>在电商公司，经常有很多活动，秒杀，抢红包等等，在某个时间点的 QPS 会很高，考虑到这种情况，可以引入了 <strong>openResty</strong>，它是一个基于 Nginx 与 Lua 的高性能 Web 平台，由于 Nginx 的非阻塞 IO 模型，使用 openResty 可以轻松支持 100 w + 的并发数，一般情况下你只要部署一台即可，不过为了避免单点故障，两台为宜，同时 openResty 也自带了缓存机制，集成了 redis 这些缓存模块，也可以直接连 mysql。不需要再通过业务层连这些中间件，性能自然会高不少</p>
<p><img src="/2021/09/27/20210927-shorturl/6.png" alt="img"></p>
<p>上图所示，使用 openResty 可以直接跳过了业务层这一步，直达缓存层与数据库层，对性能也有大量提升。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对短链设计方案作了一点总结，文中涉及到像Bloomfilter，openResty 等技术，后续再去详细讨论。值得说明的是Bloomfilter的确是一个强大的缓存层有必要好好学习一番。</p>
<p><img src="/2021/09/27/20210927-shorturl/6.jpg" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/upload/images/avatar.jpg" alt="史蒂芬猴">
            
              <p class="site-author-name" itemprop="name">史蒂芬猴</p>
              <p class="site-description motion-element" itemprop="description">dora is my precious</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">44</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/stevenhoukai" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">史蒂芬猴</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user">访客数</i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye">总访问量</i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  








  
  





  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_sphere.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
