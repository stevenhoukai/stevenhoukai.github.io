<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="dora is my precious">
<meta name="keywords" content="java golang">
<meta property="og:type" content="website">
<meta property="og:title" content="迷途小书童">
<meta property="og:url" content="http://stevenhoukai.github.io/index.html">
<meta property="og:site_name" content="迷途小书童">
<meta property="og:description" content="dora is my precious">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="迷途小书童">
<meta name="twitter:description" content="dora is my precious">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://stevenhoukai.github.io/">





  <title>迷途小书童</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">迷途小书童</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">读过几年书，尘世间一枚不起眼的小书童</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stevenhoukai.github.io/2021/09/03/20210903-goroutinepool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="steven Hou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/upload/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/09/03/20210903-goroutinepool/" itemprop="url">简易协程池</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-09-03T00:00:01+08:00">
                2021-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Golang/" itemprop="url" rel="index">
                    <span itemprop="name">Golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Go 的 goroutine 提供了一种较线程而言更廉价的方式处理并发场景, go 使用二级线程的模式, 将 goroutine 以 M:N 的形式复用到系统线程上, 节省了 cpu 调度的开销, 也避免了用户级线程（协程）进行系统调用时阻塞整个系统线程的问题。</p>
<p>但在实际的开发中如果待执行的tasks数量过多，可能带来的问题就是goroutine数量激增进而导致调度性能下降、GC 频繁、内存暴涨, 引发一系列问题。在面临这样的场景时, 限制 goroutine 的数量、重用 goroutine 显然很有价值。所以可以通过一个goroutine池来对所有的tasks进行排队执行，类似下面就是一个简单的goroutine池，通过定量的goroutine来进行任务的消费。设计下面的协程池有三个重点问题是需要重点考虑到的<br>1.如何确保任务全部都被消费完？<br>2.子goroutine发生panic如何处理？<br>3.子goroutine如果全部发生panic了怎么办？放任死锁吗？</p>
<p>这里并没考虑子goroutine执行时间太长的问题，主要原因我们可以自定义子goroutine的数量，我更希望的是任务能够执行完全而不是任务什么时候执行完，任务执行时间太长应该是业务侧的问题。</p>
<h2 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">import <span class="comment">(</span></span><br><span class="line"><span class="comment">    "sync"</span></span><br><span class="line"><span class="comment">    "sync/atomic"</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    "git.code.oa.com/trpc-go/trpc-go/errs"</span></span><br><span class="line"><span class="comment">    "git.code.oa.com/trpc-go/trpc-go/log"</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//自定义简单协程池 统一管理并发协程</span></span><br><span class="line"><span class="comment">//整体思路:定量的协程从同一个任务队列循环消费任务</span></span><br><span class="line"><span class="comment">//缺点:目前功能对协程超时情况存在缺陷 初始化函数中没有对初始化数量进行校验</span></span><br><span class="line">type Pool struct &#123;</span><br><span class="line">    TaskQueue      chan func() error //任务队列</span><br><span class="line">    WorkerNumber   int               //初始化worker数量</span><br><span class="line">    TaskNumber     int               //待消费任务数量</span><br><span class="line">    ResultQuene    chan error        //返回结果队列</span><br><span class="line">    FinishCallback func()            //全部任务消费完成的回调函数</span><br><span class="line">    runningWorkers int64             //运行中的worker数</span><br><span class="line">    sync.Mutex</span><br><span class="line">    <span class="comment">// PanicHandler   func(interface&#123;&#125;) //协程panic的处理函数 防止协程panic后导致主协程崩溃</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//初始化 根据自定义需求设定worker数量以及任务队列长度</span></span><br><span class="line">func (self *Pool) Init(WorkerNumber int, TaskNumber int) &#123;</span><br><span class="line">    self.WorkerNumber = WorkerNumber</span><br><span class="line">    self.TaskNumber = TaskNumber</span><br><span class="line">    self.TaskQueue = make(chan func() error, TaskNumber)</span><br><span class="line">    self.ResultQuene = make(chan error, TaskNumber)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//开启worker的消费动作</span></span><br><span class="line">func (self *Pool) Start() &#123;</span><br><span class="line">    <span class="comment">//默认开启 WorkerNumber个goruntine</span></span><br><span class="line">    for i := 0; i &lt; self.WorkerNumber; i++ &#123;</span><br><span class="line">        self.runGroutine()</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//获取每个任务的处理结果</span></span><br><span class="line">    for j := 0; j &lt; self.TaskNumber; j++ &#123;</span><br><span class="line">        err, ok := &lt;-self.ResultQue<span class="symbol">ne</span></span><br><span class="line">        //这里可以通过自定义决定是否上报日志</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            break</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if err != nil &#123;</span><br><span class="line">                log.Error<span class="comment">(err.Error()</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//结束时的回调函数 可以做一些通知操作等等</span></span><br><span class="line">    if self.FinishCallback != nil &#123;</span><br><span class="line">        self.FinishCallback()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//运行一个groutine 开始消费任务</span></span><br><span class="line">func (self *Pool) runGroutine() &#123; // runningWorkers + 1</span><br><span class="line">    self.incRunningWorkers() //worker运行ing数量原子自增1</span><br><span class="line">    go func() &#123;</span><br><span class="line">        defer func() &#123;</span><br><span class="line">            self.decRunningWorkers() //worker运行ing数量原子自减1</span><br><span class="line">            if r := recover(); r != nil &#123;</span><br><span class="line">                <span class="comment">// if self.PanicHandler != nil &#123;</span></span><br><span class="line">                <span class="comment">//  self.PanicHandler(r)</span></span><br><span class="line">                <span class="comment">// &#125; else &#123;</span></span><br><span class="line">                <span class="comment">//  log.Printf("Worker panic: %s\n", r)</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                err := errs.New(Panic_Sub_Goroutine, "子协程panic") //子协程panic是会导致主协程挂掉的，这一步也是必须进行捕获处理</span><br><span class="line">                self.ResultQuene &lt;- err</span><br><span class="line">            &#125;</span><br><span class="line">            self.checkWorker<span class="comment">()</span> <span class="comment">// 兜底机制，避免worker全部panic后没有worker消费队列中的数据,理论上这一步非常重要！否则有可能出现死锁状态</span></span><br><span class="line">        &#125;<span class="comment">()</span></span><br><span class="line">        for &#123;</span><br><span class="line">            select &#123;</span><br><span class="line">            case task, ok := &lt;-self.TaskQueue:</span><br><span class="line">                <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                    break</span><br><span class="line">                &#125;</span><br><span class="line">                err := task<span class="comment">()</span></span><br><span class="line">                self.ResultQuene &lt;- err</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">()</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func (self *Pool) incRunningWorkers() &#123; // runningWorkers + 1</span><br><span class="line">    atomic.AddI<span class="symbol">nt64</span><span class="comment">(&amp;self.runningWorkers, 1)</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func (self *Pool) decRunningWorkers() &#123; // runningWorkers - 1</span><br><span class="line">    atomic.AddI<span class="symbol">nt64</span><span class="comment">(&amp;self.runningWorkers, -1)</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func (self *Pool) GetRunningWorkers() int64 &#123;</span><br><span class="line">    return atomic.LoadInt64(&amp;self.runningWorkers)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func (self *Pool) checkWorker() &#123;</span><br><span class="line">    self.Lock<span class="comment">()</span></span><br><span class="line">    defer self.Unlock()</span><br><span class="line"> </span><br><span class="line">    if self.GetRunningWorkers() == 0 &amp;&amp; len(self.TaskQueue) &gt; 0 &#123;</span><br><span class="line">        self.runGroutine()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//关闭通道避免内存泄漏</span></span><br><span class="line">func (self *Pool) Stop() &#123;</span><br><span class="line">    close<span class="comment">(self.TaskQueue)</span></span><br><span class="line">    close<span class="comment">(self.ResultQuene)</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//任务入队</span></span><br><span class="line">func (self *Pool) AddTask(task func() error) &#123;</span><br><span class="line">    self.TaskQueue &lt;- task</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//执行结束后的回调</span></span><br><span class="line">func (self *Pool) SetFinishCallback(fun func()) &#123;</span><br><span class="line">    self.FinishCallback = fun</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ctx := context.Background()</span><br><span class="line">ids := make<span class="comment">([]int32, 0)</span></span><br><span class="line">var pool comm.Pool</span><br><span class="line">pool.Init(50, len(ids))</span><br><span class="line">count := int32(0)</span><br><span class="line">for _, id := range ids &#123;</span><br><span class="line">    idValue := id</span><br><span class="line">    pool.AddTask<span class="comment">(func()</span> error &#123;</span><br><span class="line">        return func(innerId int32) error &#123;</span><br><span class="line">            err := DoSomething(innerId)</span><br><span class="line">            if err != nil &#123;</span><br><span class="line">                log.ErrorContextf(ctx, "DoSomething failed, id:%d err:%s", innerId, err.Error())</span><br><span class="line">                return nil</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//以上执行无问题，完成数就+1</span></span><br><span class="line">            atomic.AddI<span class="symbol">nt32</span><span class="comment">(&amp;count, 1)</span></span><br><span class="line">            return nil</span><br><span class="line">        &#125;<span class="comment">(int32(idValue)</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//回调</span></span><br><span class="line">pool.SetFinishCallback(func() &#123;</span><br><span class="line">    <span class="comment">//自定义通知操作</span></span><br><span class="line">    fmt.Println("all done")</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//开始执行</span></span><br><span class="line">pool.Start<span class="comment">()</span></span><br><span class="line"><span class="comment">//关闭资源</span></span><br><span class="line">pool.Stop<span class="comment">()</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>池化管理自己的goroutine是非常有必要的，可以帮助我们提升开发效率降低异常风险！所以赶紧把你的goroutine管理起来吧</p>
<p><img src="/2021/09/03/20210903-goroutinepool/6.jpg" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stevenhoukai.github.io/2021/08/25/20210825-redisScanExplain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="steven Hou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/upload/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/25/20210825-redisScanExplain/" itemprop="url">Redis的scan命令解释</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-25T00:00:01+08:00">
                2021-08-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="scan的种类"><a href="#scan的种类" class="headerlink" title="scan的种类"></a>scan的种类</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原文地址:https://segmentfault.com/a/1190000018218584</span><br><span class="line"><span class="selector-tag">SCAN</span> <span class="selector-tag">cursor</span> <span class="selector-attr">[MATCH pattern]</span> <span class="selector-attr">[COUNT count]</span></span><br><span class="line"><span class="selector-tag">SSCAN</span> <span class="selector-tag">KEY</span> <span class="selector-tag">cursor</span> <span class="selector-attr">[MATCH pattern]</span> <span class="selector-attr">[COUNT count]</span></span><br><span class="line">HSCAN  KEY cursor [MATCH pattern] [COUNT count</span><br><span class="line"><span class="selector-tag">ZSCAN</span> <span class="selector-tag">KEY</span> <span class="selector-tag">cursor</span> <span class="selector-attr">[MATCH pattern]</span> <span class="selector-attr">[COUNT count]</span></span><br></pre></td></tr></table></figure>

<p>scan:迭代当前库</p>
<p>sscan:迭代一个 set 类型</p>
<p>hscan:迭代一个hash类型,并返回相应的值</p>
<p>zscan:迭代一个sorted set，并且返回相应的分数</p>
<p>知道redis是单进程单线程模型,keys和smembers这种命令可能会阻塞服务器,导致redis有可能出现长时间无法响应其他命令的情况,所以出现了scan系列的命令,通过返回一个游标，可以增量式迭代。</p>
<h2 id="scan类型命令的实现"><a href="#scan类型命令的实现" class="headerlink" title="scan类型命令的实现"></a>scan类型命令的实现</h2><p>scan,sscan,hscan,zsan分别有自己的命令入口,入口中会进行参数检测和游标赋值,然后进入统一的入口函数:scanGenericCommand,以hscan命令为例:</p>
<p><img src="/2021/08/25/20210825-redisScanExplain/1.png" alt="图片描述"><br>scanGenericCommand主要分四步:</p>
<ul>
<li>解析count和match参数.如果没有指定count,默认返回10条数据</li>
<li>开始迭代集合,如果key保存为ziplist或者intset,则一次性返回所有数据,没有游标(游标值直接返回0).由于redis设计只有数据量比较小的时候才会保存为ziplist或者intset,所以此处不会影响性能.</li>
</ul>
<p>游标在保存为hash的时候发挥作用,具体入口函数为dictScan,下文详细描述。</p>
<ul>
<li>根据match参数过滤返回值,并且如果这个键已经过期也会直接过滤掉(redis中键过期之后并不会立即删除)</li>
<li>返回结果到客户端,是一个数组,第一个值是游标,第二个值是具体的键值对</li>
</ul>
<h2 id="dictScan中游标的实现"><a href="#dictScan中游标的实现" class="headerlink" title="dictScan中游标的实现"></a>dictScan中游标的实现</h2><p>上文中我们了解到了redis中的rehash操作叫渐进式rehash，所以当迭代一个哈希表时,存在三种情况：</p>
<ul>
<li>从迭代开始到结束,哈希表没有进行rehash</li>
<li>从迭代开始到结束,哈希表进行了rehash,但是每次迭代时,哈希表要么没开始rehash,要么已经结束了rehash</li>
<li>从迭代开始到结束,某次或某几次迭代时哈希表正在进行rehash</li>
</ul>
<p>redis中的字典进行rehash时会存在两个哈希表，ht[0]与ht[1],并且是渐进式rehash(即不会一次性全部rehash);新的键值对会存放到ht[1]中并且会逐步将ht[0]的数据转移到ht[1].全部rehash完毕后,ht[1]赋值给ht[0]然后清空ht[1].</p>
<p>因此游标的实现需要兼顾以上三种情况,以上三种情况的游标实现要求如下:</p>
<ul>
<li>第一种情况比较简单,假设redis的哈希表大小为4,则第一次游标为0,读取第一个bucket的数据,然后游标返回1,下次读取第二个bucket的位置,依次遍历</li>
<li>第二种情况比较复杂,假设redis的哈希表大小为4,如果rehash完后size变成了8.如果仍然按照上边的思路返回游标,则如下图:</li>
</ul>
<p><img src="/2021/08/25/20210825-redisScanExplain/2.png" alt="图片描述"></p>
<p>假设bucket0读完之后返回了游标1,当客户端再次带着游标1返回时哈希表已经进行完rehash,并且size扩大了一倍变成了8.redis按如下方法计算一个键的bucket:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash(key)&amp;(size<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

<p>即如果size是4时,hash(key)&amp;11,如果size是8时,hash(key)&amp;111.因此当从4扩容到8时,原先在0bucket的数据会分散到0(000)与4(100)两个bucket,bucket对应关系表如下:</p>
<p><img src="/2021/08/25/20210825-redisScanExplain/3.png" alt="图片描述"><br>从二进制来看,当size为4时,hash(key)之后取低两位即 hash(key)&amp;11即key的bucket位置,如果size为8时,bucket位置为 hash(key)&amp;111，即取低三位,当低两位为00时,如果第三位为0,则为000,如果第三位为1,则为100,正好是4.其他槽位的类似.所以如果此时继续按第一种方法遍历,第四个bucket取到的值全部为重复值</p>
<ul>
<li>第三种情况，如果返回游标1时正在进行rehash,ht[0]中的bucket 1中的部分数据可能已经rehash到 ht[1]中的bucket[1]或者bucket[5]，此时必须将ht[0]和ht[1]中的相应bucket全部遍历,否则可能会有遗漏数据</li>
</ul>
<p>所以为了兼顾以上三种情况,做到不漏数据并且尽量不重复,redis使用了一种叫做reverse binary iteration的方法.具体的游标计算代码如下，具体为什么这么做我也不知道，反正redis就是选择这么做了吗，而且效果很明显:</p>
<p><img src="/2021/08/25/20210825-redisScanExplain/4.png" alt="图片描述"><br>代码逻辑很简单,下面示例从4变为8和从4变为16以及从8变为4和从16变为4时,这种方法为何能够做到不重不漏</p>
<p><img src="/2021/08/25/20210825-redisScanExplain/5.png" alt="图片描述"><br>遍历size为4时的游标状态转移为0-2-1-3.</p>
<p>同理,size为8时的游标状态转移为0-4-2-6-1-5-3-7.</p>
<p>size为16时的游标状态转义为0-8-4-12-2-10-6-14-1-9-5-13-3-11-7-15</p>
<p><img src="/2021/08/25/20210825-redisScanExplain/6.png" alt="图片描述"></p>
<p>可以看出，当size由小变大时,所有原来的游标都能在大的hashTable中找到相应的位置,并且顺序一致,不会重复读取并且不会遗漏</p>
<p>例如size原来是4变为了8,且第二次遍历时rehash已经完成.此时游标为2,根据图2,我们知道size为4时的bucket2会rehash到size为8时的2和6.而size为4时的bucket0rehash到size为8时的0和4</p>
<p>由于bucket 0 已经遍历完,也即size为8时的0,4已经遍历,正好开始从2开始继续遍历,不重复也不会遗漏</p>
<p>继续考虑size由大变小的情况.假设size由16变为了4,分两种情况,一种是游标为0,2,1,3中的一种,此时继续读取,也不会遗漏和重复</p>
<p>但如果游标返回的不是这四种,例如返回了10,10&amp;11之后变为了2,所以会从2开始继续遍历.但由于size为16时的bucket2已经读取过,并且2,10,6,14都会rehash到size为4的bucket2,所以会造成重复读取</p>
<p>size为16时的bucket2。即有重复但不会遗漏</p>
<p><strong>总结一下:redis里边rehash从小到大时，scan系列命令不会重复也不会遗漏.而从大到小时,有可能会造成重复但不会遗漏.</strong></p>
<p>截止目前,情况1和情况2已经比较完美的处理了。情况3看看如何处理</p>
<p>情况3需要从ht[0]和ht[1]中都取出数据,主要的难点在于如何在size大的哈希表中找到应该取哪些bucket.redis代码如下:</p>
<p><img src="/2021/08/25/20210825-redisScanExplain/7.png" alt="图片描述"><br>判断条件为:</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v<span class="meta">&amp;(m0^m1)</span></span><br></pre></td></tr></table></figure>

<p>size 4的m0为00000011,size8的m1为00000111,二者异或之后取值为00000100,即取二者mask高位的值,然后&amp;v,看游标是否在高位还有值</p>
<p>下一个游标的取值方法为</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v = <span class="comment">(  ((v | m0)</span> <span class="number">+1</span>)&amp; ~<span class="name">m0</span>) | <span class="comment">( v &amp; m0)</span></span><br></pre></td></tr></table></figure>

<p>右半部分 取v的低位,左半部分取v的高位。 （v&amp;m0)取出v的低位 例如size = 4时为 v&amp;00000011</p>
<p>左半部分 （v|m0) + 1即将v的低位都置为1,然后+1之后会进位到v的高位,再次 &amp; ~m0之后即取出了v的高位</p>
<p>整体来看每次将游标v的高位加1.下边举例来看:</p>
<p>假设游标返回了2,并且正在进行rehash,此时size由4变成了8 .则m0 = 00000011 v = 00000010</p>
<p>根据公式计算出的下一个游标为 ( (( 00000010|00000011) +1 ) &amp; (11111100) )| (00000010 &amp; 00000011) = (00000100)&amp;(11111100)|(00000010) = (00000110) 正好是6</p>
<p>判断条件为 (00000010) &amp; (00000011 ^ 00000111) = (00000010) &amp; (00000100) = (00000000) 为0，结束循环</p>
<p><img src="/2021/08/25/20210825-redisScanExplain/6.jpg" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stevenhoukai.github.io/2021/08/24/20210824-redisRehash/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="steven Hou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/upload/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/24/20210824-redisRehash/" itemprop="url">Redis中的渐进式Rehash</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-24T00:00:01+08:00">
                2021-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>如果你有一个hash表，然后不停的往里面写值或者删值，随着操作的不断执行， 哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的负载因子（load factor）维持在一个合理的范围之内， 当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩。这个过程就叫做rehash，而在redis中这个rehash的过程又叫做渐进式rehash。</p>
<h2 id="Rehash原理"><a href="#Rehash原理" class="headerlink" title="Rehash原理"></a>Rehash原理</h2><p>扩展和收缩哈希表的工作可以通过执行 rehash （重新散列）操作来完成， Redis 对字典的哈希表执行 rehash 的步骤如下：</p>
<ol>
<li>为字典的<strong>ht[1]</strong>哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及<strong>ht[0]</strong>当前包含的键值对数量 （也即是ht[0].used属性的值）：<ul>
<li>如果执行的是扩展操作， 那么 <code>ht[1]</code> 的大小为第一个大于等于 <code>ht[0].used * 2</code> 的 2^n （<code>2</code> 的 <code>n</code> 次方幂），也就是说每次扩容后的大小一定是2^n，因为只有2^n -1的二进制每一位都为1；</li>
<li>如果执行的是收缩操作， 那么 <code>ht[1]</code> 的大小为第一个大于等于 <code>ht[0].used</code> 的 2^n 。</li>
</ul>
</li>
<li>将保存在 <code>ht[0]</code> 中的所有键值对 rehash 到 <code>ht[1]</code> 上面： rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 <code>ht[1]</code>哈希表的指定位置上。</li>
<li>当 <code>ht[0]</code> 包含的所有键值对都迁移到了 <code>ht[1]</code> 之后 （<code>ht[0]</code> 变为空表）， 释放 <code>ht[0]</code> ， 将 <code>ht[1]</code> 设置为 <code>ht[0]</code> ， 并在 <code>ht[1]</code> 新创建一个空白哈希表， 为下一次 rehash 做准备。</li>
</ol>
<p>举个例子， 假设程序要对图 1 所示字典的 <code>ht[0]</code> 进行扩展操作， 那么程序将执行以下步骤：</p>
<ol>
<li><code>ht[0].used</code> 当前的值为 <code>4</code> ， <code>4 * 2 = 8</code> ， 而 <code>8</code> （2^3）恰好是第一个大于等于 <code>4</code> 的 <code>2</code> 的 <code>n</code> 次方， 所以程序会将 <code>ht[1]</code> 哈希表的大小设置为 <code>8</code> 。 图 2 展示了 <code>ht[1]</code> 在分配空间之后， 字典的样子。</li>
<li>将 <code>ht[0]</code> 包含的四个键值对都 rehash 到 <code>ht[1]</code> ， 如图 3 所示。</li>
<li>释放 <code>ht[0]</code> ，并将 <code>ht[1]</code> 设置为 <code>ht[0]</code> ，然后为 <code>ht[1]</code> 分配一个空白哈希表，如图 4 所示。</li>
</ol>
<p>至此， 对哈希表的扩展操作执行完毕， 程序成功将哈希表的大小从原来的 <code>4</code> 改为了现在的 <code>8</code> 。</p>
<h2 id="Rehash图示"><a href="#Rehash图示" class="headerlink" title="Rehash图示"></a><strong>Rehash图示</strong></h2><p><img src="/2021/08/24/20210824-redisRehash/1.png" alt="图1"></p>
<center>图1 执行rehash之前</center>

<p><img src="/2021/08/24/20210824-redisRehash/2.png" alt="图2"></p>
<center>图2 为字典的ht[1]哈希表分配空间</center>

<p><img src="/2021/08/24/20210824-redisRehash/3.png" alt="图3"></p>
<center>图3 ht[0]的所有值对都已经被迁移到ht[1]</center>

<p><img src="/2021/08/24/20210824-redisRehash/4.png" alt="图4"></p>
<center>图4 完成rehash之后的字典</center>

<h2 id="哈希表的扩展与收缩"><a href="#哈希表的扩展与收缩" class="headerlink" title="哈希表的扩展与收缩"></a><strong>哈希表的扩展与收缩</strong></h2><p>当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：</p>
<ol>
<li>服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 <code>1</code> ；</li>
<li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 <code>5</code> ；</li>
</ol>
<p>其中哈希表的负载因子可以通过公式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 负载因子 = 哈希表已保存节点数量 / 哈希表大小</span><br><span class="line">load_factor = ht[0].used / ht[0].size</span><br></pre></td></tr></table></figure>

<p>计算得出。</p>
<p>比如说， 对于一个大小为 <code>4</code> ， 包含 <code>4</code> 个键值对的哈希表来说， 这个哈希表的负载因子为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load_factor = 4 / 4 = 1</span><br></pre></td></tr></table></figure>

<p>又比如说， 对于一个大小为 <code>512</code> ， 包含 <code>256</code> 个键值对的哈希表来说， 这个哈希表的负载因子为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load_factor = 256 / 512 = 0.5</span><br></pre></td></tr></table></figure>

<p>根据 BGSAVE 命令或 BGREWRITEAOF 命令是否正在执行， 服务器执行扩展操作所需的负载因子并不相同， 这是因为在执行 BGSAVE命令或 BGREWRITEAOF 命令的过程中， Redis 需要创建当前服务器进程的子进程， 而大多数操作系统都采用写时复制copy-on-write技术来优化子进程的使用效率， 所以在子进程存在期间， 服务器会提高执行扩展操作所需的负载因子， 从而尽可能地避免在子进程存在期间进行哈希表扩展操作， 这可以避免不必要的内存写入操作， 最大限度地节约内存。</p>
<p>另一方面， 当哈希表的负载因子小于 <code>0.1</code> 时， 程序自动开始对哈希表执行收缩操作。</p>
<h2 id="渐进式Rehash"><a href="#渐进式Rehash" class="headerlink" title="渐进式Rehash"></a><strong>渐进式Rehash</strong></h2><p>上面说过， 扩展或收缩哈希表需要将 <code>ht[0]</code> 里面的所有键值对 rehash 到 <code>ht[1]</code> 里面， 但是， 这个 rehash 动作<strong>并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的</strong>。</p>
<p>这样做的原因在于， 如果 <code>ht[0]</code> 里只保存着四个键值对， 那么服务器可以在瞬间就将这些键值对全部 rehash 到 <code>ht[1]</code> ； 但是， 如果哈希表里保存的键值对数量不是四个， 而是四百万、四千万甚至四亿个键值对， 那么要一次性将这些键值对全部 rehash 到 <code>ht[1]</code> 的话， 庞大的计算量可能会导致服务器在一段时间内停止服务。</p>
<p>因此， 为了避免 rehash 对服务器性能造成影响， 服务器不是一次性将 <code>ht[0]</code> 里面的所有键值对全部 rehash 到 <code>ht[1]</code> ， 而是分多次、渐进式地将 <code>ht[0]</code> 里面的键值对慢慢地 rehash 到 <code>ht[1]</code> 。</p>
<p>以下是哈希表渐进式 rehash 的详细步骤：</p>
<ol>
<li>为 <code>ht[1]</code> 分配空间， 让字典同时持有 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表。</li>
<li>在字典中维持一个索引计数器变量 <code>rehashidx</code> ， 并将它的值设置为 <code>0</code> ， 表示 rehash 工作正式开始。</li>
<li>在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 <code>ht[0]</code> 哈希表在 <code>rehashidx</code> 索引上的所有键值对 rehash 到 <code>ht[1]</code> ， 当 rehash 工作完成之后， 程序将 <code>rehashidx</code> 属性的值增一。</li>
<li>随着字典操作的不断执行， 最终在某个时间点上， <code>ht[0]</code> 的所有键值对都会被 rehash 至 <code>ht[1]</code> ， 这时程序将 <code>rehashidx</code> 属性的值设为 <code>-1</code> ， 表示 rehash 操作已完成。</li>
</ol>
<p>渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。</p>
<p>图 5 至图 10 展示了一次完整的渐进式 rehash 过程， 注意观察在整个 rehash 过程中， 字典的 <code>rehashidx</code> 属性是如何变化的。</p>
<h2 id="渐进式Rehash图示"><a href="#渐进式Rehash图示" class="headerlink" title="渐进式Rehash图示"></a><strong>渐进式Rehash图示</strong></h2><p><img src="/2021/08/24/20210824-redisRehash/5.png" alt="图1"></p>
<center>图5 准备开始rehash</center>

<p><img src="/2021/08/24/20210824-redisRehash/6.png" alt="图1"></p>
<center>图6 rehash索引0上的key value</center>

<p><img src="/2021/08/24/20210824-redisRehash/7.png" alt="图1"></p>
<center>图7 rehash索引1上的key value</center>

<p><img src="/2021/08/24/20210824-redisRehash/8.png" alt="图1"></p>
<center>图8 rehash索引2上的key value</center>

<p><img src="/2021/08/24/20210824-redisRehash/9.png" alt="图1"></p>
<center>图9 rehash索引3上的key value</center>

<p><img src="/2021/08/24/20210824-redisRehash/10.png" alt="图1"></p>
<center>图10 rehash完成</center>



<h2 id="渐进式-rehash-执行期间的哈希表操作"><a href="#渐进式-rehash-执行期间的哈希表操作" class="headerlink" title="渐进式 rehash 执行期间的哈希表操作"></a><strong>渐进式 rehash 执行期间的哈希表操作</strong></h2><p>因为在进行渐进式 rehash 的过程中， 字典会同时使用 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 <code>ht[0]</code>里面进行查找， 如果没找到的话， 就会继续到 <code>ht[1]</code> 里面进行查找， 诸如此类。</p>
<p>另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 <code>ht[1]</code> 里面， 而 <code>ht[0]</code> 则不再进行任何添加操作： 这一措施保证了 <code>ht[0]</code> 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。<strong>这里提前透漏一句，就是这个渐进式rehash的缩容操作导致了scan命令的重复值出现。</strong>下一篇会详细讨论一下。</p>
<p><img src="/2021/08/24/20210824-redisRehash/6.jpg" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stevenhoukai.github.io/2021/08/19/20210819-redisScan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="steven Hou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/upload/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/19/20210819-redisScan/" itemprop="url">获取Redis中同一前缀key踩坑记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-19T00:00:01+08:00">
                2021-08-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/golang踩坑记录/" itemprop="url" rel="index">
                    <span itemprop="name">golang踩坑记录</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>之前有一个订单购买后用户生效保护期的需求，根据当时的需求本人是将key设置好自定义前缀规则，并设置了过期时间然后统一放在了redis上面，后来需求变动，所有的保护期过期之后需要留档处理，这时候就需要把之前设置的同一前缀的保护期数据在过期之前全部转移到数据库留档，就需要将之前设置的所有保护期相关数据全部获取出来。这时的kv大概已经有了300w条左右了。</p>
<p>这里就有两个方案了keys * 和 scan</p>
<p>keys *这个虽然可以实现目的但是最好还是不要使用，因为如果线上数据过大，就会导致单线程的redis阻塞，长时间无法处理后续请求，然后你就等着被捶吧。</p>
<p>scan可以理解是keys <em>的分批次执行，简单来说就是会有一个游标记录一次扫描的结束位置，然后拿着这个游标作为下一次扫描的起始位置，反复执行，每次执行数据量不大而且每次执行时间也足够短，直到扫描完整个redis库，全程不会造成redis的无响应状况，但是需要声明一点，*</em>这个scan操作是会出现重复key值的<strong>，所以需要业务侧做好去重处理哈。本文的重点！</strong>为什么说这个scan会出现重复值，又为什么这个scan是不会漏值的？**下面就来说说本人的理解。</p>
<h2 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h2><p>下面是本人在项目中的一些用法,代码实现功能就是将自己需要的一些kv值遍历出来放进mysql进行存储，由于线上数据量较大，整个过程大约持续了30分钟，但是redis服务全程无异常状况，完美达到目的。</p>
<h3 id="核心代码示例"><a href="#核心代码示例" class="headerlink" title="核心代码示例"></a>核心代码示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">rcnn := redis.Connection()</span><br><span class="line">begin := time.Now().Unix()</span><br><span class="line">firstStrs, cursor := rcnn.Scan(<span class="number">0</span>, <span class="string">"xxxxx_service_xxxxx*"</span>, <span class="number">1000</span>).Val()</span><br><span class="line">fmt.Println(time.Now().Unix() - begin)</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> firstStrs &#123;</span><br><span class="line">    key := value</span><br><span class="line">    keyValue := rcnn.Get(key).Val()</span><br><span class="line">    ttlSeconds := <span class="keyword">int64</span>(rcnn.TTL(key).Val().Seconds())</span><br><span class="line">    tnow := time.Now().Unix()</span><br><span class="line">    memberId, _ := strconv.Atoi((strings.Split(key, <span class="string">"&amp;"</span>)[<span class="number">1</span>]))</span><br><span class="line">    orderId := strings.Split(keyValue, <span class="string">"&amp;"</span>)[<span class="number">0</span>]</span><br><span class="line">    pPeriod := &amp;protectperiod.ProtectPeriod&#123;</span><br><span class="line">        MemberId:  <span class="keyword">int64</span>(memberId),</span><br><span class="line">        OrderId:   orderId,</span><br><span class="line">        Content:   keyValue,</span><br><span class="line">        CreatedAt: tnow + ttlSeconds - <span class="number">3628800</span>,</span><br><span class="line">        ExpiredAt: tnow + ttlSeconds,</span><br><span class="line">        Status:    <span class="string">"0"</span>,</span><br><span class="line">        Source:    <span class="string">"redis"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    cErr := pPeriod.CreateNewRecord()</span><br><span class="line">    <span class="keyword">if</span> cErr != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(cErr)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> cursor != <span class="number">0</span> &#123;</span><br><span class="line">    cbegin := time.Now().Unix()</span><br><span class="line">    strs, nextCursor := rcnn.Scan(cursor, <span class="string">"xxxxx_service_xxxxx*"</span>, <span class="number">1000</span>).Val()</span><br><span class="line">    fmt.Println(time.Now().Unix() - cbegin)</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> strs &#123;</span><br><span class="line">        key := value</span><br><span class="line">        keyValue := rcnn.Get(key).Val()</span><br><span class="line">        ttlSeconds := <span class="keyword">int64</span>(rcnn.TTL(key).Val().Seconds())</span><br><span class="line">        tnow := time.Now().Unix()</span><br><span class="line">        memberId, _ := strconv.Atoi((strings.Split(key, <span class="string">"&amp;"</span>)[<span class="number">1</span>]))</span><br><span class="line">        orderId := strings.Split(keyValue, <span class="string">"&amp;"</span>)[<span class="number">0</span>]</span><br><span class="line">        pPeriod := &amp;protectperiod.ProtectPeriod&#123;</span><br><span class="line">            MemberId:  <span class="keyword">int64</span>(memberId),</span><br><span class="line">            OrderId:   orderId,</span><br><span class="line">            Content:   keyValue,</span><br><span class="line">            CreatedAt: tnow + ttlSeconds - <span class="number">3628800</span>,</span><br><span class="line">            ExpiredAt: tnow + ttlSeconds,</span><br><span class="line">            Status:    <span class="string">"0"</span>,</span><br><span class="line">            Source:    <span class="string">"redis"</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        cErr := pPeriod.CreateNewRecord()</span><br><span class="line">        <span class="keyword">if</span> cErr != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(cErr)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cursor = nextCursor</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"all Done"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h2><p>好了，在前言中有说到<strong>为什么说这个scan会出现重复值，又为什么这个scan是安全不会漏值的？</strong> 在讨论这个问题之前，我们需要先了解什么是Rehash，学过java的都知道hashmap，当hashmap中的槽不够用的时候就会在每一个槽产生过长的链表导致效率低下等问题，在hash冲突严重的时候，hashmap就会进行扩容，然后把原来的kv值转移到新的扩容的好hashmap中去，这个过程其实就是rehash。其实在redis中这一过程准确点的叫法是渐进式rehash，点此处了解什么是<a href="https://stevenhoukai.github.io/2021/08/24/20210824-redisRehash/"><strong>渐进式rehash</strong></a>, 了解完上述概念之后，我们现在再来看看<a href="https://stevenhoukai.github.io/2021/08/25/20210825-redisScanExplain/"><strong>scan命令为什么是安全不漏值而且可能会出现重复值</strong></a>的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>如果遇到线上redis需要获取大批量的kv值，用scan不会错。切记客户端一定要做好去重处理！！！</p>
<p><img src="/2021/08/19/20210819-redisScan/6.jpg" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stevenhoukai.github.io/2021/08/16/20210816-gapGolangFor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="steven Hou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/upload/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/16/20210816-gapGolangFor/" itemprop="url">Golang的for循环踩坑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-16T00:00:01+08:00">
                2021-08-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/golang踩坑记录/" itemprop="url" rel="index">
                    <span itemprop="name">golang踩坑记录</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>最近写项目用了太多的for循环，殊不知这么简单的一个操作竟然踩出大坑，记录一波！</p>
<h2 id="for循环使用"><a href="#for循环使用" class="headerlink" title="for循环使用"></a>for循环使用</h2><p>下面来看一下项目中的一些用法</p>
<h3 id="实例踩坑效果"><a href="#实例踩坑效果" class="headerlink" title="实例踩坑效果"></a>实例踩坑效果</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	newArr := []*<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		newArr = <span class="built_in">append</span>(newArr, &amp;v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> newArr &#123;</span><br><span class="line">		fmt.Println(*v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>看到这个结果的时候我其实是一脸懵逼的，这个问题起初我一个java程序员真是无法理解，后来直到我运行了如下的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	newArr := []*<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		fmt.Println(<span class="string">""</span>)</span><br><span class="line">		fmt.Printf(<span class="string">"origin addr: %p value: %v"</span>, &amp;v, v)</span><br><span class="line">		newArr = <span class="built_in">append</span>(newArr, &amp;v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> newArr &#123;</span><br><span class="line">		fmt.Println(<span class="string">""</span>)</span><br><span class="line">		fmt.Printf(<span class="string">"addr: %p  value: %v"</span>, s, *s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">origin addr: <span class="number">0xc0000a67a8</span> value: <span class="number">1</span></span><br><span class="line">origin addr: <span class="number">0xc0000a67a8</span> value: <span class="number">2</span></span><br><span class="line">origin addr: <span class="number">0xc0000a67a8</span> value: <span class="number">3</span></span><br><span class="line">addr: <span class="number">0xc0000a67a8</span>  value: <span class="number">3</span></span><br><span class="line">addr: <span class="number">0xc0000a67a8</span>  value: <span class="number">3</span></span><br><span class="line">addr: <span class="number">0xc0000a67a8</span>  value: <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>总结就是golang的for循环是通过同一个地址槽来反复接值的！！！</p>
<p><img src="/2021/08/16/20210816-gapGolangFor/6.jpg" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stevenhoukai.github.io/2021/08/12/20210812-explainCount/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="steven Hou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/upload/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/12/20210812-explainCount/" itemprop="url">count(1)、count(*)、count(列)有什么区别？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-12T00:00:01+08:00">
                2021-08-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>不知不觉入职tencent已经半年了，期间一直都在忙着适应golang还有新的业务新的微服务框架，从java转到golang有所适有所不适吧，但总体来说问题不大，所以就很久没有更新了，但是没关系，工作中遇到的问题小弟我都有一一记录，后面全部补上。今天主要来对sql统计中的count进行一下总结。</p>
<h2 id="count-1-and-count"><a href="#count-1-and-count" class="headerlink" title="count(1) and count(*)"></a><strong>count(1) and count(*)</strong></h2><p>当表的数据量大些时，对表作分析之后，使用count(1)还要比使用count(*)用时多了！ </p>
<p>从执行计划来看，count(1)和count(<em>)的效果是一样的。但是在表做过分析之后，count(1)会比count(</em>)的用时少些（1w以内数据量），不过差不了多少。 </p>
<p>如果count(1)是聚索引,id,那肯定是count(1)快。但是差的很小的。 </p>
<p>因为count(<em>),自动会优化指定到那一个字段。所以没必要去count(1)，用count(</em>)，sql会帮你完成优化的 因此：count(1)和count(*)基本没有差别！</p>
<h2 id="count-1-and-count-字段"><a href="#count-1-and-count-字段" class="headerlink" title="count(1) and count(字段)"></a><strong>count(1) and count(字段)</strong></h2><p>两者的主要区别是</p>
<ol>
<li>count(1) 会统计表中的所有的记录数，包含字段为null 的记录。</li>
<li>count(字段) 会统计该字段在表中出现的次数，忽略字段为null 的情况。即不统计字段为null 的记录。 </li>
</ol>
<p><strong>count(*) 和 count(1)和count(列名)区别</strong> </p>
<p>执行效果上： </p>
<ul>
<li>count(<em>)包括了所有的列，相当于行数，在统计结果的时候，*</em>不会忽略列值为NULL** </li>
<li>count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，<strong>不会忽略列值为NULL</strong> </li>
<li>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，<strong>即某个字段值为NULL时，不统计</strong>。</li>
</ul>
<p>执行效率上： </p>
<ul>
<li>列名为主键，count(列名)会比count(1)快 </li>
<li>列名不为主键，count(1)会比count(列名)快 </li>
<li>如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*） </li>
<li>如果有主键，则 select count（主键）的执行效率是最优的 </li>
<li>如果表只有一个字段，则 select count（*）最优。</li>
</ul>
<h3 id="实例查看效果"><a href="#实例查看效果" class="headerlink" title="实例查看效果"></a>实例查看效果</h3><p>下面来看看一个列子吧</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table counttest(name char(<span class="number">1</span>), age char(<span class="number">2</span>));</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.03</span> sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; insert into counttest values -&gt; (<span class="string">'a'</span>, <span class="string">'14'</span>),(<span class="string">'a'</span>, <span class="string">'15'</span>), (<span class="string">'a'</span>, <span class="string">'15'</span>), -&gt; (<span class="string">'b'</span>, NULL), (<span class="string">'b'</span>, <span class="string">'16'</span>), -&gt; (<span class="string">'c'</span>, <span class="string">'17'</span>), -&gt; (<span class="string">'d'</span>, null), -&gt;(<span class="string">'e'</span>, <span class="string">'');</span></span><br><span class="line"><span class="string">Query OK, 8 rows affected (0.01 sec)</span></span><br><span class="line"><span class="string">Records: 8  Duplicates: 0  Warnings: 0</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">mysql&gt; select * from counttest;</span></span><br><span class="line"><span class="string">+------+------+</span></span><br><span class="line"><span class="string">| name | age  |</span></span><br><span class="line"><span class="string">+------+------+</span></span><br><span class="line"><span class="string">| a | 14   |</span></span><br><span class="line"><span class="string">| a | 15   |</span></span><br><span class="line"><span class="string">| a | 15   |</span></span><br><span class="line"><span class="string">| b | NULL |</span></span><br><span class="line"><span class="string">| b | 16   |</span></span><br><span class="line"><span class="string">| c | 17   |</span></span><br><span class="line"><span class="string">| d | NULL |</span></span><br><span class="line"><span class="string">| e | |</span></span><br><span class="line"><span class="string">+------+------+</span></span><br><span class="line"><span class="string">8 rows in set (0.00 sec)</span></span><br><span class="line"><span class="string">mysql&gt; select name, count(name), count(1), count(*), count(age), count(distinct(age)) -&gt; from counttest -&gt; group by name;</span></span><br><span class="line"><span class="string">+------+-------------+----------+----------+------------+----------------------+</span></span><br><span class="line"><span class="string">| name | count(name) | count(1) | count(*) | count(age) | count(distinct(age)) |</span></span><br><span class="line"><span class="string">+------+-------------+----------+----------+------------+----------------------+</span></span><br><span class="line"><span class="string">| a | 3 | 3 | 3 | 3 | 2 |</span></span><br><span class="line"><span class="string">| b | 2 | 2 | 2 | 1 | 1 |</span></span><br><span class="line"><span class="string">| c | 1 | 1 | 1 | 1 | 1 |</span></span><br><span class="line"><span class="string">| d | 1 | 1 | 1 | 0 | 0 |</span></span><br><span class="line"><span class="string">| e | 1 | 1 | 1 | 1 | 1 |</span></span><br><span class="line"><span class="string">+------+-------------+----------+----------+------------+----------------------+</span></span><br><span class="line"><span class="string">5 rows in set (0.00 sec)</span></span><br></pre></td></tr></table></figure>

<p>好记性不如烂笔头哈～</p>
<p><img src="/2021/08/12/20210812-explainCount/6.jpg" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stevenhoukai.github.io/2020/12/29/20201229-goroutine2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="steven Hou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/upload/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/29/20201229-goroutine2/" itemprop="url">goroutine与线程的关系</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-29T00:00:01+08:00">
                2020-12-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Golang并发编程/" itemprop="url" rel="index">
                    <span itemprop="name">Golang并发编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>学到这里，我们需要了解一下OS线程一般都是有属于自己的线程栈内存（通常为2MB）。一个goroutine栈在刚启动的时候确实很小的（通常是2KB），所以一次性创建10w个goroutine也是没有问题的，随着运行goroutine栈最大可达到1GB。goroutine属于用户态线程，go语言在runtime层面通过实现了一个GPM机制来对goroutine进行调度。</p>
<h2 id="goroutine的调度机制"><a href="#goroutine的调度机制" class="headerlink" title="goroutine的调度机制"></a><strong>goroutine的调度</strong>机制</h2><p>首先来大致解释下什么是GPM</p>
<p><strong>G：就是goroutine，包含goroutine信息以及与所在P的绑定等信息</strong></p>
<p><strong>P：管理着一组goroutine的队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址以及地址边界），P内部对自己管理的一些列G进行调度，当自己管理的队列消费完了还会去全局队列中取，如果全局队列也消费完了还会去其他的P中取任务</strong></p>
<p><strong>M：是Golang中对os内核线程的抽象，M与内核线程一般就是11对应的关系，goroutine最终都是会在M上进行执行的</strong></p>
<p>我们来稍微理解一下这个GPM模型，本人会觉得与java中的线程池模型还是很相似的，只是本人研究的java线程池中并无全局队列以及去其他队列抢任务的概念出现，了解j<strong><a href="https://www.baidu.com" target="_blank" rel="noopener">JAVA中线程池工作原理</a></strong>戳这里。在GPM中，P和M通常也是11对应的，但这并不是绝对的，可以这么通俗的来理解一个队列P对应一个os线程M，os线程由操作系统cpu运行，然后P来对队列中的任务goroutine进行调度，让每一个goroutine在os线程上不停的来回切换运行（准确一点的表达：P管理着一组G挂载在M上运行，当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G挂载在新建的M上去。当旧的G阻塞完成或者认为其已经死掉时那么就会回收旧的M）。</p>
<h2 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="GOMAXPROCS"></a><strong>GOMAXPROCS</strong></h2><p>​    在前言中我们说了G的内存大小以及创建数量等问题，那么P由这方面的限制吗？P的个数是通过runtime.GOMAXPROCS设定（最大256），Go1.5版本之后默认为物理线程数。在并发量大的时候会适当增加一些P和M，但是也不会太多，切换太频繁也没有太多必要。</p>
<h3 id="实例查看效果"><a href="#实例查看效果" class="headerlink" title="实例查看效果"></a>实例查看效果</h3><p>Go运行时的调度器使用<code>GOMAXPROCS</code>参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核cpu上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。</p>
<p>Go语言中可以通过<code>runtime.GOMAXPROCS()</code>函数设置当前程序并发时占用的CPU逻辑核心数。</p>
<p>Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。</p>
<p>我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，这里我们来举个例子看看。</p>
<h4 id="例1"><a href="#例1" class="headerlink" title="例1:"></a>例1:</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">"A:"</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">"B:"</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> a()</span><br><span class="line">	<span class="keyword">go</span> b()</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">modora#: <span class="keyword">go</span> run ./main.<span class="keyword">go</span></span><br><span class="line">B: <span class="number">1</span></span><br><span class="line">B: <span class="number">2</span></span><br><span class="line">B: <span class="number">3</span></span><br><span class="line">B: <span class="number">4</span></span><br><span class="line">B: <span class="number">5</span></span><br><span class="line">B: <span class="number">6</span></span><br><span class="line">B: <span class="number">7</span></span><br><span class="line">B: <span class="number">8</span></span><br><span class="line">B: <span class="number">9</span></span><br><span class="line">A: <span class="number">1</span></span><br><span class="line">A: <span class="number">2</span></span><br><span class="line">A: <span class="number">3</span></span><br><span class="line">A: <span class="number">4</span></span><br><span class="line">A: <span class="number">5</span></span><br><span class="line">A: <span class="number">6</span></span><br><span class="line">A: <span class="number">7</span></span><br><span class="line">A: <span class="number">8</span></span><br><span class="line">A: <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>上面例子中我们设置了runtime.GOMAXPROCS()为1，也就是说GPM模型中最多一个OS线程在运行，可以很明显的看到Agoroutine和Bgoroutine是串行打印，原因也很简单，两个goroutine在一个OS线程上进行调度的。下面我们将runtime.GOMAXPROCS()设置成2，两个goroutine在两个OS线程上进行调度，这里其实可以理解在OS线程层面并行。</p>
<h4 id="例2"><a href="#例2" class="headerlink" title="例2:"></a>例2:</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">"A:"</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">"B:"</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	runtime.GOMAXPROCS(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> a()</span><br><span class="line">	<span class="keyword">go</span> b()</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">执行结果：</span><br><span class="line">modora#: <span class="keyword">go</span> run ./main.<span class="keyword">go</span></span><br><span class="line">A: <span class="number">1</span></span><br><span class="line">A: <span class="number">2</span></span><br><span class="line">A: <span class="number">3</span></span><br><span class="line">A: <span class="number">4</span></span><br><span class="line">A: <span class="number">5</span></span><br><span class="line">A: <span class="number">6</span></span><br><span class="line">A: <span class="number">7</span></span><br><span class="line">A: <span class="number">8</span></span><br><span class="line">B: <span class="number">1</span></span><br><span class="line">B: <span class="number">2</span></span><br><span class="line">B: <span class="number">3</span></span><br><span class="line">B: <span class="number">4</span></span><br><span class="line">B: <span class="number">5</span></span><br><span class="line">B: <span class="number">6</span></span><br><span class="line">B: <span class="number">7</span></span><br><span class="line">B: <span class="number">8</span></span><br><span class="line">B: <span class="number">9</span></span><br><span class="line">A: <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>再次运行上述代码，发现AB变成了交替打印。各种意味自行理解哈～</p>
<p><img src="/2020/12/29/20201229-goroutine2/6.jpg" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stevenhoukai.github.io/2020/12/18/20201218-HexoTransferWindowsToMac/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="steven Hou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/upload/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/18/20201218-HexoTransferWindowsToMac/" itemprop="url">hexo迁移（Windows -> Mac）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-18T00:00:01+08:00">
                2020-12-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hexo/" itemprop="url" rel="index">
                    <span itemprop="name">Hexo</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Hexo迁移（Windows-gt-Mac）"><a href="#Hexo迁移（Windows-gt-Mac）" class="headerlink" title="Hexo迁移（Windows -&gt; Mac）"></a>Hexo迁移（Windows -&gt; Mac）</h2><p>最近因工作需要换了台mac，需要将windows上面的hexo全数转移至新机，记录一下整个过程。</p>
<h3 id="1-找到自己Windows的hexo根目录"><a href="#1-找到自己Windows的hexo根目录" class="headerlink" title="1.找到自己Windows的hexo根目录"></a>1.找到自己Windows的hexo根目录</h3><h3 id="2-在-Mac-安装git和node-js"><a href="#2-在-Mac-安装git和node-js" class="headerlink" title="2.在 Mac 安装git和node.js"></a>2.在 Mac 安装git和node.js</h3><p>首先在自己电脑上装好node和git（首先确保brew安装好了） </p>
<p><code>brew install git</code></p>
<p><code>brew install node</code></p>
<h3 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3.安装hexo"></a>3.安装hexo</h3><p><em>用node.js来安装，这里可能会安装失败，我这里是切换npm源才成功</em></p>
<p><code>npm config set registry https://registry.npm.taobao.org</code></p>
<p><code>npm install -g hexo-cli</code> </p>
<h3 id="4-初始化hexo目录"><a href="#4-初始化hexo目录" class="headerlink" title="4.初始化hexo目录"></a><strong>4.初始化hexo目录</strong></h3><p>新建一个hexo目录，mkdir blog，cd blog</p>
<p><code>hexo init</code><br>在用<code>hexo s</code></p>
<p>测试是否成功，打开<code>localhost:4000</code>查看本地 </p>
<h3 id="5-生成SSH密钥，关联github"><a href="#5-生成SSH密钥，关联github" class="headerlink" title="5.生成SSH密钥，关联github"></a>5.生成SSH密钥，关联github</h3><p>先查看本地的SSH key: <code>cd ~/.ssh</code><br>(我是新买的mac，这一步需要直接先走安装）<br>$ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com" target="_blank" rel="noopener">youremail@example.com</a>“  后面那个是注册邮箱</p>
<p>进入.ssh文件夹： <code>cd ~/.ssh</code>，然后打开里面的 id_rsa.pub文件，里面的内容就是 SSH key，复制全部内容；</p>
<p>网页打开 github 的设置：Settings -&gt; SSH and GPG keys，点击绿色的按钮 New SSH key，然后在输入框中输入刚才复制的内容；</p>
<p>保存后，github 会向你的邮箱发送一个验证链接（记得要去登录邮箱验证，不然之后的 hexo d 部署会一直不成功的！）；</p>
<p>可以先测试一下是否成功：ssh <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>，<br>看到以下即成功：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; PTY allocation request failed on channel 0</span><br><span class="line">&gt; Hi gjincai! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br><span class="line">&gt; Connection to github.com closed.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="6-文件配置转移"><a href="#6-文件配置转移" class="headerlink" title="6.文件配置转移"></a>6.文件配置转移</h3><p>windows 下的博客根目录 hexo，复制该目录下的：<code>_config.yml</code>, <code>scaffolds</code>, <code>source</code>, <code>themes</code>；<br>mac 下的博客根目录 hexo，把刚才复制的内容，直接覆盖替换相同的文件文件夹。</p>
<h3 id="7-设置个人信息"><a href="#7-设置个人信息" class="headerlink" title="7.设置个人信息"></a>7.设置个人信息</h3><p><code>git config --global user.name &quot;yourname&quot;</code></p>
<p><code>git config --global user.email youremail@example.com</code></p>
<p>到这就好了，和往常一样hexo g   hexo d(或者直接hexo g -d)发布文章吧！结果会提示ERROR Deployer not found: git</p>
<p>安装以下再尝试：<code>npm install hexo-deployer-git --save（若提示有关权限不足的，加sudo，反正我是遇到了）</code></p>
<h3 id="8-最重要！！！！！！！"><a href="#8-最重要！！！！！！！" class="headerlink" title="8.最重要！！！！！！！"></a>8.最重要！！！！！！！</h3><p>以上是通常情况下的解决方案，本人遇到这个问题其实比较棘手并没有那么的顺利：本人旧机Window安装的node是v10.15.3，hexo版本是v3.9.0；要知道hexo最新版本已经是v5.2.0，跟旧版本相比有了很大的改动，比如主题安装，变化还是比较多的。所以最好是确定node版本在12或13或者以下版本，hexo版本最好也保持一致，否则会出现deploy d失败的情况，可以通过nvm安装多版本node解决即可</p>
<p><img src="/2020/12/18/20201218-HexoTransferWindowsToMac/6.jpg" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stevenhoukai.github.io/2020/12/04/20201204-goroutine/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="steven Hou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/upload/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/04/20201204-goroutine/" itemprop="url">goroutine</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-04T00:00:01+08:00">
                2020-12-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Golang并发编程/" itemprop="url" rel="index">
                    <span itemprop="name">Golang并发编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>之前学JAVA并发编程的时候，了解到了cpu内存模型、JMM、竞态资源、同步关键字synchronized、可见性以及指令重排关键字volatile再到后面的AQS源码等等。可以说JAVA的并发编程体系是非常完善的，但据说golang是天生就具备并发性能的语言，今天就来好好学习一下golang并发编程中的第一个重要概念goroutine。</p>
<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a><strong>并发与并行</strong></h2><p>相信学过并发编程的同学一定对这两个概念不陌生，我这里就只举两个非常简单形象的例子来描述一下：</p>
<p><strong>并发：假如你是一个渣男，某一天晚上你用微信轮流不停的和两个女朋友聊天</strong></p>
<p><strong>并行：你和你老弟都是好男人，某一天晚上你们都在用微信和自己女朋友聊天</strong></p>
<p>Java中通过Thread实现并发，GoLang中的并发则通过goroutine实现。goroutine类似于线程，属于用户态的线程，我们可以根据需要创建成千上万个goroutine并发工作。goroutine是由Golang的运行时调度完成的，而线程是由操作系统调度完成。</p>
<p>golang还提供channel在多个goroutine间进行通信。goroutine和channel是Go语言秉承的CSP(Communicating Sequential Process)并发模式的重要实现基础</p>
<h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a><strong>goroutine</strong></h2><p>在JAVA中要实现并发编程的时候，通常需要自己维护一个Threadpool，并且需要自己去包装一个又一个的任务(runnable or callable其实本质还是用户态Thread)往这个池子中丢任务，线程池根据自己的工作机制来运行这个任务或者阻塞这个任务又或者拒绝这个任务，今天我们不讨论JAVA线程池，有兴趣的朋友可以看我另外一篇文章，<strong><a href="https://www.baidu.com" target="_blank" rel="noopener">JAVA中线程池工作原理</a></strong>点这里查看。</p>
<p><code>goroutine</code>的概念类似于线程，但 <code>goroutine</code>是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。</p>
<p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能 –<code>goroutine</code>，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个<code>goroutine</code>去执行这个函数就可以了，就是这么简单粗暴。</p>
<h3 id="use-goroutine"><a href="#use-goroutine" class="headerlink" title="use goroutine"></a>use goroutine</h3><p>Go语言中使用<code>goroutine</code>非常简单，只需要在调用函数的时候在前面加上<code>go</code>关键字，就可以为一个函数创建一个<code>goroutine</code>。一个<code>goroutine</code>必定对应一个函数，可以创建多个<code>goroutine</code>去执行相同的函数。</p>
<h4 id="启动单个goroutine"><a href="#启动单个goroutine" class="headerlink" title="启动单个goroutine"></a>启动单个goroutine</h4><p>Golang中启动goroutine的方式非常简单，只需要在调用的函数（普通函数和匿名函数）前面加上一个<code>go</code>关键字。如下示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"Hello stephen!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	hello()</span><br><span class="line">	fmt.Println(<span class="string">"main stephen over!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例中hello函数和下面的语句是串行的，执行的结果是打印完<code>Hello stephen!</code>后打印<code>main stephen done!</code>。</p>
<p>下面我们在调用hello函数前面加上关键字<code>go</code>，也就是启动一个goroutine去执行hello这个函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> hello() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">	fmt.Println(<span class="string">"main stephen done!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一次的执行结果只打印了<code>main stephen done!</code>，并没有打印<code>Hello stephen!</code>。为什么呢？在程序启动时，Go程序就会为<code>main()</code>函数创建第一个默认的<code>goroutine</code>，这个goroutine。当main()函数返回的时候该<code>goroutine</code>就结束了，所有在<code>main()</code>函数中启动的<code>goroutine</code>会一同结束，<code>main</code>函数所在的<code>goroutine</code>就像是打着降龙十八掌的乔峰，乔峰运功十八条龙(sub goroutines)在空气里穿梭，乔峰收工，十八条龙在空气中消失。这样好理解了吧。所以我们要想办法让main函数等一等hello函数，java中我们可以通过Thread.sleep()或者while(true)，而golang这里最简单粗暴的方式就是<code>time.Sleep</code>了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> hello() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">	fmt.Println(<span class="string">"main stephen done!"</span>)</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上面的代码你会发现，这一次先打印<code>main stephen done!</code>，然后紧接着打印<code>Hello stephen !</code>。这里会先打印<code>main stephen done!</code>是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的<code>goroutine</code>是继续执行的。</p>
<h4 id="启动多个goroutine-引出WaitGroup"><a href="#启动多个goroutine-引出WaitGroup" class="headerlink" title="启动多个goroutine(引出WaitGroup)"></a>启动多个goroutine(引出WaitGroup)</h4><p>了解到如何启动单个goroutine后，那么启动多个goroutine同理如下，同样我们需要main goroutine在一系列的sub goroutine执行完之前保持存活状态，这里就引入了一个新的概念WaitGroup，这个东西我在学习java并发编程的时也是有发现类似功能的组件的，比如AQS的直接产物CountDownLatch或者间接产物CyclicBarrier，原理也比较有趣，有兴趣了解其工作原理的<strong><a href="https://www.baidu.com" target="_blank" rel="noopener">戳这里</a></strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done() <span class="comment">// goroutine结束就登记-1</span></span><br><span class="line">	fmt.Println(<span class="string">"Hello stephen!"</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>) <span class="comment">// 启动一个goroutine就登记+1</span></span><br><span class="line">		<span class="keyword">go</span> hello(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait() <span class="comment">// 等待所有登记的goroutine都结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上述代码，你会发现执行的打印结果每一次都是不一样的，原因也很简单，因为后台的goroutine的调度是随机的~，好了今天我们初步的了解了goroutine的一些基本概念和基本用法，下一篇来详细讨论一下GMP调度模型，学习一下goroutine调度背后的故事。</p>
<p><img src="/2020/12/04/20201204-goroutine/6.jpg" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://stevenhoukai.github.io/2020/11/28/20201128-golangprectice2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="steven Hou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/upload/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="迷途小书童">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/28/20201128-golangprectice2/" itemprop="url">Golang练习二</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-11-28T00:00:01+08:00">
                2020-11-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Golang/" itemprop="url" rel="index">
                    <span itemprop="name">Golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>学习Golang的过程中，练习必不可少，俗话说的好 Talk is cheap,show me the code，学完Golang基本语法，是需要适当做一些练习加深理解的，虽然很很很简单！但是本人Java转go，语法还是要多熟悉，秉承多写一遍就多一次理解的原则，开始吧~</p>
<ul>
<li><h4 id="练习4"><a href="#练习4" class="headerlink" title="练习4"></a><strong>练习4</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//练习4</span><br><span class="line">  //打印9*9乘法口诀表</span><br><span class="line">  package main</span><br><span class="line">  </span><br><span class="line">  import &quot;fmt&quot;</span><br><span class="line">  </span><br><span class="line">  /*</span><br><span class="line">   * 练习4 打印乘法乘法口诀表</span><br><span class="line">   */</span><br><span class="line">  </span><br><span class="line">  func test4() &#123;</span><br><span class="line">  	for i := 1; i &lt;= 9; i++ &#123;</span><br><span class="line">  		for j := 1; j &lt;= 9; j++ &#123;</span><br><span class="line">  			if j &lt;= i &#123;</span><br><span class="line">  				fmt.Printf(&quot;%v * %v = %v &quot;, i, j, i*j)</span><br><span class="line">  			&#125;</span><br><span class="line">  		&#125;</span><br><span class="line">  		fmt.Printf(&quot;\n&quot;)</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  func main() &#123;</span><br><span class="line">  	test4()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><h4 id="练习5"><a href="#练习5" class="headerlink" title="练习5"></a><strong>练习5</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//练习5</span><br><span class="line">  //编写代码统计出字符串中每一个单词出现的次数</span><br><span class="line">  func test5() &#123;</span><br><span class="line">  	mymap := make(map[string]int)</span><br><span class="line">  	str := &quot;how do you do&quot;</span><br><span class="line">  	arr := strings.Split(str, &quot; &quot;)</span><br><span class="line">  	for _, v := range arr &#123;</span><br><span class="line">  		value, ok := mymap[v]</span><br><span class="line">  		if ok &#123;</span><br><span class="line">  			mymap[v] = value + 1</span><br><span class="line">  		&#125; else &#123;</span><br><span class="line">  			mymap[v] = 1</span><br><span class="line">  		&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	fmt.Println(mymap)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><h4 id="练习6"><a href="#练习6" class="headerlink" title="练习6"></a><strong>练习6</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func calc(index string, a, b int) int &#123;</span><br><span class="line">  	ret := a + b</span><br><span class="line">  	fmt.Println(index, a, b, ret)</span><br><span class="line">  	return ret</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  func main() &#123;</span><br><span class="line">  	x := 1</span><br><span class="line">  	y := 2</span><br><span class="line">  	defer calc(&quot;AA&quot;, x, calc(&quot;A&quot;, x, y))</span><br><span class="line">  	x = 10</span><br><span class="line">  	defer calc(&quot;BB&quot;, x, calc(&quot;B&quot;, x, y))</span><br><span class="line">  	y = 20</span><br><span class="line">  &#125;</span><br><span class="line">  //思考下输出结果？提示一下:</span><br><span class="line">  //defer注册要延迟执行的函数时该函数所有的参数都需要确定其值</span><br><span class="line">  //defer入栈出栈？</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><h4 id="练习7"><a href="#练习7" class="headerlink" title="练习7"></a><strong>练习7</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">  你有100枚金币，需要分配给以下几个人：Matthew,Sarah,Augustus,Heidi,Emilie,Peter,Giana,Adriano,Aaron,Elizabeth。</span><br><span class="line">  分配规则如下：</span><br><span class="line">  a. 名字中每包含1个&apos;e&apos;或&apos;E&apos;分1枚金币</span><br><span class="line">  b. 名字中每包含1个&apos;i&apos;或&apos;I&apos;分2枚金币</span><br><span class="line">  c. 名字中每包含1个&apos;o&apos;或&apos;O&apos;分3枚金币</span><br><span class="line">  d: 名字中每包含1个&apos;u&apos;或&apos;U&apos;分4枚金币</span><br><span class="line">  写一个程序，计算每个用户分到多少金币，以及最后剩余多少金币？</span><br><span class="line">  程序结构如下，请实现 ‘dispatchCoin’ 函数</span><br><span class="line">  */</span><br><span class="line">  var (</span><br><span class="line">  	coins = 100</span><br><span class="line">  	users = []string&#123;</span><br><span class="line">  		&quot;Matthew&quot;, &quot;Sarah&quot;, &quot;Augustus&quot;, &quot;Heidi&quot;, &quot;Emilie&quot;, &quot;Peter&quot;, &quot;Giana&quot;, &quot;Adriano&quot;, &quot;Aaron&quot;, &quot;Elizabeth&quot;,</span><br><span class="line">  	&#125;</span><br><span class="line">  	distribution = make(map[string]int, len(users))</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  func dispatchCoin() int &#123;</span><br><span class="line">  	for _, v := range users &#123;</span><br><span class="line">  		var count = 0</span><br><span class="line">  		for _, val := range v &#123;</span><br><span class="line">  			switch val &#123;</span><br><span class="line">  			case &apos;e&apos;:</span><br><span class="line">  				count++</span><br><span class="line">  			case &apos;E&apos;:</span><br><span class="line">  				count++</span><br><span class="line">  			case &apos;i&apos;:</span><br><span class="line">  				count = count + 2</span><br><span class="line">  			case &apos;I&apos;:</span><br><span class="line">  				count = count + 2</span><br><span class="line">  			case &apos;o&apos;:</span><br><span class="line">  				count = count + 3</span><br><span class="line">  			case &apos;O&apos;:</span><br><span class="line">  				count = count + 3</span><br><span class="line">  			case &apos;u&apos;:</span><br><span class="line">  				count = count + 4</span><br><span class="line">  			case &apos;U&apos;:</span><br><span class="line">  				count = count + 4</span><br><span class="line">  			&#125;</span><br><span class="line">  		&#125;</span><br><span class="line">  		distribution[v] = count</span><br><span class="line">  		coins = coins - count</span><br><span class="line">  	&#125;</span><br><span class="line">  	fmt.Println(distribution)</span><br><span class="line">  	return coins</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  func main() &#123;</span><br><span class="line">  	left := dispatchCoin()</span><br><span class="line">  	fmt.Println(&quot;剩下：&quot;, left)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>  Talk is cheap,show me the code~</p>
<p>  <img src="/2020/11/28/20201128-golangprectice2/1.jpeg" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/upload/images/avatar.jpg" alt="steven Hou">
            
              <p class="site-author-name" itemprop="name">steven Hou</p>
              <p class="site-description motion-element" itemprop="description">dora is my precious</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/stevenhoukai" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">steven Hou</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user">访客数</i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye">总访问量</i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  








  
  





  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_sphere.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
