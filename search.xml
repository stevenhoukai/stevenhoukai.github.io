<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>slice</title>
    <url>/2022/03/26/20220326-goslice/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇我们了解了golang的string是如何玩转的，趁热打铁今天就来学习常用的slice结构，这个slice跟我们以前做java的时候用到的动态数组(List)很相似，但是又有区别，那么今天就来探究下它的原理。</p>
<h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a><strong>slice</strong></h2><h3 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a><strong>三要素</strong></h3><p>slice包含以下图示的三个核心元素，数据、已存放数据长度以及容量 :</p>
<img src="/2022/03/26/20220326-goslice/1.png" style="zoom: 80%;">

<p>举个例子如下 : </p>
<p>我们声明了一个变量intSlice，实际上这只是一个声明，底层并没有分配对应的数组进行支持，所以指向底层数组的指针data就是nil，而长度和容量都是0值。</p>
<img src="/2022/03/26/20220326-goslice/2.png" style="zoom: 80%;"> 

<p>在golang中有两种初始化slice的方式分别是make 和 new</p>
<h4 id="make"><a href="#make" class="headerlink" title="make"></a><strong>make</strong></h4><p>从下图中我们可以看到通过make的方式声明变量intSlice<strong><u>就会在底层分配一个对应的数据类型的数组</u></strong>，并将data指向底层数组的起始地址，操作1就是向slice中添加一个元素，操作2就是改变slice已经存在元素的值，操作3就是访问超过len的数据这种情况会直接panic。</p>
<img src="/2022/03/26/20220326-goslice/3.png" style="zoom: 80%;">

<h4 id="new"><a href="#new" class="headerlink" title="new"></a><strong>new</strong></h4><p>接下来就是通过new关键字声明变量，可以知道并未在底层初始化对应的数组，所以操作1直接给slice下标为0的元素赋值会直接panic，这时只有通过操作2 append操作才会在底层初始化对应的数组并将data指向底层数组的起始位置，其实这里有一点绕，slice的data指向底层的一个字符串数组，上一篇中我们讲过string的结构不记得的可以回去再看一遍，所以字符串的data还会指向另外一个底层实际存储字符编码的数组。</p>
<img src="/2022/03/26/20220326-goslice/4.png" style="zoom: 80%;">

<p>通过以上对比我们发现其实两者还是有很大区别的，两者虽然都可以用来声明slice变量，但是前者会在声明变量的同时在底层分配好对应类型的数组结构而后者则不会，实际上我本人在实际的开发过程中也只会用make。make不仅可以初始化slice，还可以用在map和chan的初始化上面。</p>
<h3 id="底层数组"><a href="#底层数组" class="headerlink" title="底层数组"></a><strong>底层数组</strong></h3><p>上面一直在说底层数组，那么底层数组究竟是什么？数组其实就是一段连续的内存空间，在这一段连续的内存空间内一个挨着一个的存储着同种类型的数据，int型的slice底层其实就是一个int数组，string型的slice底层就是一个string数组，从上面说明的例子我们可以看到slice都是指向了底层数组的起始地址，但这是必须的吗？我们来看接下来的一个列子 : </p>
<p>我们先来声明一个int类型的数组arr，容量为10，数组的容量一旦声明就不能再变了，我们可以通过下面s1和s2的声明方式（左闭右开原则）将slice变量关联到同一个arr数组，可以看到s1的指向地址其实是底层数组第二个元素的地址位置，而s2的指向地址其实是底层数组第八个元素的地址位置，这其实不难理解，那么本文的核心来了，请仔细看操作 s2 = append(s2,11)（<strong><u>这个动作并不是线程安全的后面我们会细聊</u></strong>），该操作会触发扩容动作？那么什么是扩容了？slice又是怎么扩容的了？</p>
<img src="/2022/03/26/20220326-goslice/6.png" style="zoom: 80%;">

<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a><strong>扩容</strong></h3><p>上面提出了一个扩容的概念，其实这个也很好理解s2指向的底层数组已经满了无法将11存放，这时s2就需要另谋高去开辟另外的一片内存空间将自己原来的数据复制过去后再将11添加的末尾，最后s2就指向了该新内存空间的起始地址。在这个过程中我们其实会有几个疑问的，第一个我怎么知道那片新的内存空间要多大了，随便还是无限的？我能想到golang当然也能想到，扩容整体来说就是下面的三个步骤。</p>
<h4 id="步骤1-预估扩容后的容量"><a href="#步骤1-预估扩容后的容量" class="headerlink" title="步骤1 : 预估扩容后的容量"></a><strong>步骤1 : 预估扩容后的容量</strong></h4><p>这个规则其实没啥好说的，源码总结规则如下：</p>
<img src="/2022/03/26/20220326-goslice/7.png" style="zoom: 80%;">

<h4 id="步骤2-扩容后需要多大内存"><a href="#步骤2-扩容后需要多大内存" class="headerlink" title="步骤2 : 扩容后需要多大内存"></a><strong>步骤2 : 扩容后需要多大内存</strong></h4><p>这个其实跟我们的元素类型是息息相关的，但是真的就是按照下图的方式直接分配至么多内存吗？答案是否定的。</p>
<img src="/2022/03/26/20220326-goslice/8.png" style="zoom: 80%;">

<h4 id="步骤3-匹配合适的内存规格"><a href="#步骤3-匹配合适的内存规格" class="headerlink" title="步骤3 : 匹配合适的内存规格"></a><strong>步骤3 : 匹配合适的内存规格</strong></h4><p>上面这个问题简单来说就是编程语言(c除外)去申请内存并不是直接向操作系统申请的，中间还夹着一层代理人(内存管理模块)，系统启动时代理人先向os提前申请好一批内存，分成常用的规格管理起来，当golang向其申请内存空间时，代理人就会挑选对应刚大于申请空间大小的内存块并分配给申请人，这样就完成了整个的扩容动作。</p>
<img src="/2022/03/26/20220326-goslice/9.png" style="zoom: 80%;">



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我们聊了聊slice的相关原理，是不是很有趣，现在只是开篇稍微简单一点，后面会逐步深入，难度也会逐步增大，下一篇我们聊聊内存对齐哈，slice完结撒花～。</p>
<img src="/2022/03/26/20220326-goslice/5.jpg" style="zoom: 100%;">]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>go的string</title>
    <url>/2022/03/24/20220324-gostring/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从java转golang已经一年多了，过去的一年确实也挺坎坷的，国家打压部门解散，刚在支付组有一点感觉然后就没然后了，也没事后面活水到新部门继续肝，这不刚用go重构完一个十年前的c++系统，过程之痛苦一言难尽，但是痛苦归痛苦从中还是学到了不少，例如redis，pulsar这个之前已经写过好几篇基本的文章了，后续会更新一些自己在用法上的硬核知识，啊哦跑题了，本系列的核心是golang，用了一年多的golang是时候该总结一下了，俗话说的好学而时习之才能逆水行舟， 今天的主题是string～</p>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a><strong>string</strong></h2><h3 id="比特与字节"><a href="#比特与字节" class="headerlink" title="比特与字节"></a><strong>比特与字节</strong></h3><p>一个bit或者是0或者是1，8个bit组成一个字节，全部为0代表0，全部为1代表数字255，相信这个不必多说大家都知道了，一个字节可以表示256个数字，两个字节就是65536个数字了，更多的字节就可以表示更大的数字，如下图所示 :</p>
<img src="/2022/03/24/20220324-gostring/1.png" style="zoom: 80%;">



<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a><strong>字符集</strong></h3><p>以上我们说的都是整数，那字符是怎样存储的了？一堆二进制是怎么转换成字符的了？不能直接展示那就通过数字中转一下，如下图 : 存储保持不变，多添加一层映射关系就能解决这个问题啦，尽可能多的将世界上出现的字符收录进来然后一一进行编号构建一张映射表，这个映射表就叫做字符集，下面展示了字符集的进化旅程，其实就是一个字符映射表不断完善的过程，直到最后被unicode统一规范。</p>
<img src="/2022/03/24/20220324-gostring/2.png" style="zoom: 80%;">

<h3 id="字符串存储（UTF-8）"><a href="#字符串存储（UTF-8）" class="headerlink" title="字符串存储（UTF-8）"></a><strong>字符串存储（UTF-8）</strong></h3><p>上面说明字符集，但是真的只是有了字符集就万事大吉了吗？来思考下该怎么存储 “世界aABb” ？</p>
<p>最直接的想法是不是根据字符集找到每一个字符的编号存成二进制完事儿？来看看是不是就像下面这样，乍一看没有问题，但是仔细一看不对啊有的占一个字节有的占了三个字节，那我咋知道那一长串玩意儿要怎么划分了？这个方案显然不行…</p>
<img src="/2022/03/24/20220324-gostring/3.png" style="zoom: 80%;">

<p>于是我们应该能想到第一种方案 : 定长编码</p>
<img src="/2022/03/24/20220324-gostring/4.png" style="zoom: 80%;">

<p>这个方案，乍一看没有问题，然后再仔细一看确实也没有啥问题，就是浪费的字节稍微有点多……那可以怎么解决了？这里就引出了另外一种方案 : 变长编码，如下图所示：</p>
<img src="/2022/03/24/20220324-gostring/5.png" style="zoom: 80%;">

<p>这个图看着是不是有点懵逼，没关系，容我来稍微解释一下，每个字节分为标示位和实际数据两部分，例如第一行的0??? ????,如果数据在0～127之间，对应的编码模版就是以0标示开头后7位表示实际数据，如果数据在128～2047之间数据就占两字节，每个字节分别以固定的110和10两个固定标示开头，后面的也一样，其实就是通过固定的标示位来重新组装原来的二进制数据从而降低对内存的浪费。看到这里现在应该知道最开始的那个字符串该怎么存储了吧？</p>
<img src="/2022/03/24/20220324-gostring/6.png" style="zoom: 80%;">

<p>这其实就是我们熟知的UTF-8编码，也就是golang默认的编码方式，字符集和编码方式是需要相互配合才能达到最优方案的。接下来我们就可以来了解下golang的string是如何实现的了。</p>
<h3 id="go的string"><a href="#go的string" class="headerlink" title="go的string"></a><strong>go的string</strong></h3><p>碰巧了前段时间重构c++，也了解了一下c++的string是如何实现的，来我们先来看看C语言是如何实现的，如下图 : </p>
<img src="/2022/03/24/20220324-gostring/7.png" style="zoom: 80%;">

<p>C语言如是说，会在结尾处通过 \0 的特殊字符来标示结尾，那这也就意味着存放的字符串中是无法出现 \0 这样的字符的，-_-!!!本人很坦诚的说一句这方案忒差了，所以golang并没有采用这种方案，来看看golang是如何处理的:</p>
<img src="/2022/03/24/20220324-gostring/8.png" style="zoom: 80%;">

<p>golang通过添加一个len变量来存储字符串中字节的长度，还是上面的例子”世界aABb”就应该是这样 : </p>
<img src="/2022/03/24/20220324-gostring/9.png" style="zoom: 80%;">

<p>好了关于golang的string今天就介绍到这里，对了，最后非常值得注意的一点是，无论是java或是golang，string都会被认为是不可变变量，是不允许修改的，golang编译器会把 s1:= “世界aABb”这样的变量分配到只读内存中，多个str是可以共享底层同一个数组变量的，可以重新复制这时会重新开辟一个数组空间，但是绝对不允许修改，完结撒花。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天属于是golang系列的开篇，后续的该系列也会不断完善，下一篇我们讲slice。</p>
<img src="/2022/03/24/20220324-gostring/5.jpg" style="zoom: 100%;">]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么要用protobuf？</title>
    <url>/2022/03/17/20220313-protobuf/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前做java开发，服务间相互调用用的最多的就是java原生序列化和json序列化协议，然而后面去了大厂做golang开发基本都是采用pb了，刚开始以为只是规范使然，然而通过后面的学习发现pb确实是全方位领先于其他各种序列化协议的，简单来说就是pb不仅更快而且更小，下面就来细细的探讨一番。</p>
<h2 id="bp为什么这么屌"><a href="#bp为什么这么屌" class="headerlink" title="bp为什么这么屌"></a><strong>bp为什么这么屌</strong></h2><p><strong>官方测试</strong></p>
<p>那么pb究竟实战有多屌了，先看两幅官方测试报告图：</p>
<img src="/2022/03/17/20220313-protobuf/1.png" style="zoom: 100%;">

<p>​                                                                                           <u>解包耗时</u></p>
<img src="/2022/03/17/20220313-protobuf/2.png" style="zoom: 100%;">

<p>​                                                                                           <u>数据包压缩后大小</u></p>
<p>可以很明显的看到，一条消息数据，用<code>protobuf</code>序列化后的大小是<code>json</code>的10分之一，是<code>xml</code>格式的20分之一，但是性能却是它们的5~100倍。</p>
<p><strong>为什么用pb对数据包压缩后更小</strong></p>
<p>下面以<code>json</code>数据为基础出发，通过一步一步的对它进行优化，来理解<code>protobuf</code>的实现原理。</p>
<p>例如有一条信息，用<code>json</code>的表示方式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"age"</span>: <span class="number">32</span>, <span class="attr">"name"</span>: <span class="string">"xxx"</span>,  <span class="attr">"height"</span>: <span class="number">170</span>, <span class="attr">"weight"</span>: <span class="number">106</span> &#125;</span><br></pre></td></tr></table></figure>

<p>很明显，整个json串种包含着很多可有可无的字符，例如”,” “:”等，为了把数据变的更小一点，我可能就会采取如下处理方式：</p>
<table>
<thead>
<tr>
<th align="center">32</th>
<th align="center">xxx</th>
<th align="center">170</th>
<th align="center">106</th>
</tr>
</thead>
</table>
<p>这里直接舍去了全部不必要的冗余字符，这里其实已经对数据进行了大幅缩减了，但是这时会出现一些新的问题，接收端接收到数据后咋知道32对应的是那个字段，xxx又是对应的哪个字段，也就是字段的对应问题这时是无法解决的。</p>
<p>那我们可以对字段都编个号，接收端接收到数据后就按照这个编号进行解析即可，如下：</p>
<table>
<thead>
<tr>
<th align="center">字段1：age</th>
<th align="center">字段2：name</th>
<th align="center">字段3： height</th>
<th align="center">字段4：weight</th>
</tr>
</thead>
<tbody><tr>
<td align="center">↓</td>
<td align="center">↓</td>
<td align="center">↓</td>
<td align="center">↓</td>
</tr>
<tr>
<td align="center">32</td>
<td align="center">Xxx</td>
<td align="center">170</td>
<td align="center">106</td>
</tr>
</tbody></table>
<p>这样看来就完美达成目的了</p>
<p><strong>新的问题以及解决方案</strong></p>
<p>虽然上述方案可以达到解决问题的目的，但是我们来假设一下下面的情况<code>height</code>这个字段为<code>null</code>，也就是没有值，那么传递的数据就会变成如下：</p>
<table>
<thead>
<tr>
<th align="center">32</th>
<th align="center">xxx</th>
<th align="center">106</th>
</tr>
</thead>
</table>
<p>但是在接收端，解析数据并按照顺序进行字段匹配的时候就会出问题：</p>
<table>
<thead>
<tr>
<th align="center">字段1：age</th>
<th align="center">字段2：name</th>
<th align="center">字段3： height</th>
<th align="center">字段4：weight</th>
</tr>
</thead>
<tbody><tr>
<td align="center">↓</td>
<td align="center">↓</td>
<td align="center">↓</td>
<td align="center">↓</td>
</tr>
<tr>
<td align="center">32</td>
<td align="center">xxx</td>
<td align="center">106</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>很明显数据已经乱套了，原本weight的值解析到了height字段，那为了解决这个问题，pb引入了一个名为<code>tag</code>的技术：</p>
<table>
<thead>
<tr>
<th align="center">tag|30</th>
<th align="center">tag|zhangsan</th>
<th align="center">tag|175.33</th>
<th align="center">tag|140</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>也就是说，每个字段我们都用<code>tag|value</code>的方式来存储的，在<code>tag</code>当中记录两种信息，一个是<code>value</code>对应的字段的编号，另一个是<code>value</code>的数据类型（比如是整形还是字符串等），因为<code>tag</code>中有字段编号信息，所以即使没有传递<code>height</code>字段的<code>value</code>值，根据编号也能正确的配对。细心的朋友可能已经发现了，乍一看这个方案跟json的key/value方案无异啊，绕了一圈又回到了原点？哈哈，莫急，让我慢慢道来。</p>
<p><strong>Tag的开销</strong></p>
<p>接着上面的问题我们继续……</p>
<p>这个问题其实问的相当好，<code>json</code>中的<code>key</code>其实是字符串，我们知道每个字符会占据一个字节，所以像<code>name</code>这个<code>key</code>就会占据4个字节，但在<code>protobuf</code>中，<code>tag</code>使用二进制进行存储，一般只会占据一个字节，它的核心代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeTag</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> fieldNumber, <span class="keyword">final</span> <span class="keyword">int</span> wireType)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (fieldNumber &lt;&lt; <span class="number">3</span>) | wireType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fieldNumber</code>表示后面的<code>value</code>所对应的字段的编号是多少，比如<code>fieldNumber</code>为1，就表示<code>age</code>，如果为2，就表示<code>name</code>等；<code>wireType</code>表示<code>value</code>的数据类型，以此来计算<code>value</code>占用字节的大小。在<code>protobuf</code>当中，<code>wireType</code>可以支持的字段类型如下：</p>
<img src="/2022/03/17/20220313-protobuf/3.png" style="zoom: 100%;">

<p>因为<code>tag</code>一般占用一个字节，开销还算是比较小的，所以<code>protobuf</code>整体的存储空间占用还是相对小了很多的。</p>
<p>看完上面的说辞是否还是不太理解，下面我来举个例子就很清晰了，例如上面的0-5种数据类型分别对应二进制位 000～101，排序第一的字段age生成的tag就是00001000，一个字节前5位表示序号后三位表示类型。</p>
<p>此时出现一个新问题，那么Tag分隔符为一个字节，如果传输的内容中出现相同的字节，会导致解析错误吗？这里就需要了解一下什么是Varint编码。</p>
<p><strong>Varint编码</strong></p>
<p>这里直接通过实例来进行说明更为直观，如图：</p>
<img src="/2022/03/17/20220313-protobuf/4.png" style="zoom: 100%;">

<p>图中对数字123456进行varint编码，123456用二进制表示为 <code>11110001001000000</code>，每次从低向高取7位再加上最高有效位变成 <code>11000000</code> <code>11000100</code> <code>00000111</code> 所以经过varint编码后123456占用三个字节分别为 <code>1921967</code>,同样解码的时候就逆向操作即可，通过这样的方式我们就省掉一个字节的开销，其实通常在实际项目我们传输的int一般来说都是比较小的，所以这样的设计也是非常ok的。</p>
<p><strong>Zigzag编码</strong></p>
<p>上面的设计看似完美，但是其实我们仔细思考一下，如果是-1这种负数改如何是好？</p>
<p>-1 –&gt; 11111111 11111111 11111111 11111111</p>
<p>如果继续采用上面的方式并不是一个好的选择，这里就不得不说zigzag编码方式了</p>
<p>直接看表格吧</p>
<table>
<thead>
<tr>
<th>原始的带符号数</th>
<th>zigzag编码后的表示</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>-1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>-2</td>
<td>3</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
</tr>
<tr>
<td>2147483647</td>
<td>4294967294</td>
</tr>
<tr>
<td>-2147483647</td>
<td>4294967295</td>
</tr>
</tbody></table>
<p>能看到编码方式就是  ：</p>
<p>负数 2 *|x| - 1  正数 2 * |x|  是不是很简单又很神奇。这里提一句即使使用该编码方式后续也还是会使用varint再进行编码的。</p>
<p><strong>Tag-Length-Value(TLV)</strong></p>
<p>我们之前讲的varint又或者是zigtag都是以传输数字为基础的，那如果我们传输的是字符串了？那么引出了另一主角TLV，Tag为分隔符，Length为长度但是我们同样采用varint编码的方式。</p>
<p>接下来我们回到最开始的问题，会出现解析错误的问题吗？</p>
<p>我们来尝试推导一下解析过程 : 如果一开始是要传输一个数字，我们拿到了第一个Tag，解析出它的fieldNumber和wireType，因为采用的是varint的编码方式（zigzag后也是采用varint再次进行编码的），高位为1表示下一个字节还是数字，如果为0则表示下一个字节就是Tag了。如果一开始传输的是一个字符串，那么拿到Tag后就知道接下来的是一个字符串，那么下一个字节就开始解析Length，Length同样还是使用varint编码，遇到高位为0后表示该Length解析完毕，我们就能拿到value的长度了，接下来按照长度取完字符串后，下一个字节就是Tag了。以此类推，pb永远都清楚的知道哪一个字节是Tag，所以现在还疑惑吗？</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Protobuf确实是目前最好的数据传输协议没有之一，当然我们不仅是要会用也要知道为啥要用～</p>
<img src="/2022/03/17/20220313-protobuf/5.jpg" style="zoom: 100%;">]]></content>
      <categories>
        <category>协议</category>
      </categories>
      <tags>
        <tag>protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title>Pulsar的订阅模式</title>
    <url>/2022/02/19/20220219-pulsar-sub/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面对pulsar整体的执行原理进行了一番介绍，下面来对使用实践相关，首先要介绍的就是订阅模式，订阅模式决定了消费者如何对一个topic/partition中的数据进行消费，了解其相关的知识对使用来说是至关重要的。</p>
<h2 id="订阅模式"><a href="#订阅模式" class="headerlink" title="订阅模式"></a>订阅模式</h2><p>为了适用不同场景的需求，Pulsar 支持四种订阅模式：分别是Exclusive(独占)、Shared(共享)、Failover(灾备)、Key_Shared(key共享)。下面分别对这四种模式进行一个介绍</p>
<img src="/2022/02/19/20220219-pulsar-sub/1.png" style="zoom: 50%;">

<p><strong>独占模式（Exclusive）</strong></p>
<p><strong>Exclusive 独占模式（默认模式）</strong>：一个 Subscription 只能与<strong>一个 Consumer</strong> 关联，<strong>没错，是一个！！</strong>！只有这个 Consumer 可以接收到 Topic 的全部消息，如果该 Consumer 出现故障了就会停止消费。</p>
<p>Exclusive 订阅模式下，同一个 Subscription 里只有一个 Consumer 能消费 Topic，如果多个 Consumer 订阅则会报错，适用于全局有序消费的场景。</p>
<img src="/2022/02/19/20220219-pulsar-sub/2.png" style="zoom: 50%;">

<p>当启动多个消费者时，就会报错。</p>
<p><strong>共享模式（Shared）</strong></p>
<p>消息默认通过轮询机制（也可以自定义）分发给不同的消费者，并且每个消息仅会被分发给一个消费者。当消费者断开连接，所有被发送给他，但没有被确认的消息将被重新安排，分发给其它存活的消费者。</p>
<img src="/2022/02/19/20220219-pulsar-sub/3.png" style="zoom: 50%;">

<p>这也是我们使用最频繁的一种消费模式，目前我重构的vdc基本都是使用这种模式，可以在管理端看到如下多个消费者消费同一个topic</p>
<img src="/2022/02/19/20220219-pulsar-sub/4.png" style="zoom: 50%;">

<p><strong>灾备模式（Failover）</strong></p>
<p>当存在多个 consumer 时，将会按字典顺序排序，第一个 consumer 被初始化为唯一接受消息的消费者。当第一个 consumer 断开时，所有的消息（未被确认和后续进入的）将会被分发给队列中的下一个 consumer。</p>
<img src="/2022/02/19/20220219-pulsar-sub/5.png" style="zoom: 50%;">

<p>这种模式跟第一种独占模式很相似，优势就是有备胎，主消费者挂了，备胎就会马上顶替上来。</p>
<p><strong>KEY 共享模式（Key_Shared）</strong></p>
<p>当存在多个 consumer 时，将根据消息的 key 进行分发，key 相同的消息只会被分发到同一个消费者。这种消费模式也是使用比较频繁，当我们需要对消息进行分类消费时我们就可以使用这种模式，举个例子我们的vdc系统需要消费多款不同的引擎的扫描结果，我们需要把引擎分类做不同的逻辑处理，这时就可以使用到这种消费模式了。</p>
<img src="/2022/02/19/20220219-pulsar-sub/6.png" style="zoom: 50%;">

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上我们总结了pulsar的四种消费模式，了解其相关的原理对于我们使用上是至关重要哈。</p>
<img src="/2022/02/19/20220219-pulsar-sub/5.jpg" style="zoom: 100%;">]]></content>
      <categories>
        <category>pulsar</category>
      </categories>
      <tags>
        <tag>pulsar</tag>
      </tags>
  </entry>
  <entry>
    <title>消息副本与存储机制</title>
    <url>/2022/02/16/20220216-pulsar-replicate/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇文章对Pulsar的消息存储原理和ID规则进行了介绍，本篇文章来对消息副本以及存储机制来介绍一下。lets go</p>
<h2 id="消息元数据组成"><a href="#消息元数据组成" class="headerlink" title="消息元数据组成"></a>消息元数据组成</h2><p>Pulsar 中每个分区 Topic 的消息数据以 ledger 的形式存储在 BookKeeper 集群的 bookie 存储节点上，每个 ledger 包含一组 entry，而 bookie 只会按照 entry 维度进行写入、查找、获取。</p>
<blockquote>
<p>说明：</p>
<p>批量生产消息的情况下，一个 entry 中可能包含多条消息，所以 entry 和消息并不一定是一一对应的。</p>
</blockquote>
<p>Ledger 和 entry 分别对应不同的元数据。</p>
<ul>
<li>ledger 的元数据存储在 zk 上。</li>
<li>entry 除了消息数据部分之外，还包含元数据，entry 的数据存储在 bookie 存储节点上。</li>
</ul>
<img src="/2022/02/16/20220216-pulsar-replicate/1.png" style="zoom: 50%;">

<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">参数</th>
<th align="left">参数说明</th>
<th align="left">数据存放位置</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ledger</td>
<td align="left">ensemble size（E）</td>
<td align="left">每个 ledger 选用的 bookie 节点的个数</td>
<td align="left">元数据存储在 zk 上</td>
</tr>
<tr>
<td align="left">ledger</td>
<td align="left">write quorum size（Qw）</td>
<td align="left">每个 entry 需要向多少个 bookie 发送写入请求</td>
<td align="left">元数据存储在 zk 上</td>
</tr>
<tr>
<td align="left">ledger</td>
<td align="left">ack quorum size（Qa）</td>
<td align="left">收到多少个写入确认后，即可认为写入成功</td>
<td align="left">元数据存储在 zk 上</td>
</tr>
<tr>
<td align="left">ledger</td>
<td align="left">Ensembles（E）</td>
<td align="left">使用的 ensemble 列表，形式为&lt;entry id=””, ensembles=””&gt; 元组key（entry id）：使用这个 ensembles 列表开始时的 entry idvalue（ensembles）：ledger 选用的 bookie ip 列表，每个 value 中包含 ensemble size （E）个 IP每个 ledger 可能包含多个 ensemble 列表，同一时刻每个 ledger 最多只有一个 ensembles 列表在使用</td>
<td align="left">元数据存储在 zk 上</td>
</tr>
<tr>
<td align="left">Entry</td>
<td align="left">Ledger ID</td>
<td align="left">entry 所在的 ledger id</td>
<td align="left">数据存储在 bookie 存储节点上</td>
</tr>
<tr>
<td align="left">Entry</td>
<td align="left">Entry ID</td>
<td align="left">当前 entry id</td>
<td align="left">数据存储在 bookie 存储节点上</td>
</tr>
<tr>
<td align="left">Entry</td>
<td align="left">Last Add Confirmed</td>
<td align="left">创建当前 entry 的时候，已知最新的写入确认的 entry id</td>
<td align="left">数据存储在 bookie 存储节点上</td>
</tr>
<tr>
<td align="left">Entry</td>
<td align="left">Digest</td>
<td align="left">CRC</td>
<td align="left">数据存储在 bookie 存储节点上</td>
</tr>
</tbody></table>
<p>每个 ledger 在创建的时候，会在现有的 BookKeeper 集群中的可写状态的 bookie 候选节点列表中，选用 ensemble size 对应个数的 bookie 节点，如果没有足够的候选节点则会抛出 BKNotEnoughBookiesException 异常。选出候选节点后，将这些信息组成 &lt;entry id, ensembles&gt; 元组，存储到 ledger 的元数据里的 ensembles 中。</p>
<h2 id="消息副本机制"><a href="#消息副本机制" class="headerlink" title="消息副本机制"></a>消息副本机制</h2><p><strong>消息写入流程</strong></p>
<img src="/2022/02/16/20220216-pulsar-replicate/2.png" style="zoom: 60%;">

<p>客户端在写入消息时，每个 entry 会向 ledger 当前使用的 ensemble 列表中的 Qw 个 bookie 节点发送写入请求，当收到 Qa 个写确认后，即认为当前消息写入存储成功。同时会通过 LAP（lastAddPushed）和 LAC（LastAddConfirmed）分别标识当前推送的位置和已经收到存储确认的位置。</p>
<p>每个正在推送的 entry 中的 LAC 元数据值，为当前时刻创建发送 entry 请求时，已经收到最新的确认位置值。LAC 所在位置及之前的消息对读客户端是可见的。</p>
<p>同时，pulsar 通过 fencing 机制，来避免同时有多个客户端对同一个 ledger 进行写操作。这里主要适用于一个 topic/partition 的归属关系从一个 broker 变迁到另一个 broker 的场景。</p>
<p><strong>消息副本分布</strong></p>
<p>每个 entry 写入时，会根据当前消息的 entry id 和当前使用的 ensembles 列表的开始 entry id（即key值），计算出在当前 entry 需要使用 ensemble 列表中由哪组 Qw 个 bookie 节点进行写入。之后，broker 会向这些 bookie 节点发送写请求，当收到 Qa 个写确认后，即认为当前消息写入存储成功。这时至少能够保证 Qa 个消息的副本个数。</p>
<img src="/2022/02/16/20220216-pulsar-replicate/3.png" style="zoom: 50%;">

<p>如上图所示，ledger 选用了4个 bookie 节点（bookie1-4 这4个节点），每次写入3个节点，当收到2个写入确认即代表消息存储成功。当前 ledger 选中的 ensemble 从 entry 1开始，使用 bookie1、bookie2、bookie3 进行写入，写入 entry 2的时候选用 bookie2、bookie3、bookie4写入，而 entry 3 则会根据计算结果，写入 bookie3、bookie4、bookie1。</p>
<h2 id="消息恢复机制"><a href="#消息恢复机制" class="headerlink" title="消息恢复机制"></a>消息恢复机制</h2><p>Pulsar 的 BookKeeper 集群中的每个 bookie 在启动的时候，默认自动开启 recovery 的服务，这个服务会进行如下几个事情：</p>
<ol>
<li>auditorElector 审计选举。</li>
<li>replicationWorker 复制任务。</li>
<li>deathWatcher 宕机监控。</li>
</ol>
<p>BookKeeper 集群中的每个 bookie 节点，会通过 zookeeper 的临时节点机制进行选主，主 bookie 主要处理如下几个事情：</p>
<ol>
<li>负责监控 bookie 节点的变化。</li>
<li>到 zk 上面标记出宕机的 bookie 上面的 ledger 为 Underreplicated 状态。</li>
<li>检查所有的 ledger 的副本数（默认一周一个周期）。</li>
<li>Entry 副本数检查（默认未开启）。</li>
</ol>
<p>其中 ledger 中的数据是按照 Fragment 维度进行恢复的（每个 Fragment 对应 ledger 下的一组 ensemble 列表，如果一个 ledger 下有多个 ensemble 列表，则需要处理多个 Fragment）。</p>
<p>在进行恢复时，首先要判断出当前的 ledger 中的哪几个 Fragment 中的哪些存储节点需要用新的候选节点进行替换和恢复数据。当 Fragment 中关联的部分 bookie 节点上面没有对应的 entry 数据（默认是按照首、尾 entry 是否存在判断），则这个 bookie 节点需要被替换，当前的这个 Fragment 需要进行数据恢复。</p>
<p>Fragment 的数据用新的 bookie 节点进行数据恢复完毕后，更新 ledger 的元数据中当前 Fragment 对应的 ensemble 列表的原数据。</p>
<p>经过此过程，因 bookie 节点宕机引起的数据副本数减少的场景，数据的副本数会逐步的恢复成 Qw（后台指定的副本数，TDMQ 默认3副本）个。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="/2022/02/16/20220216-pulsar-replicate/5.jpg" style="zoom: 100%;">]]></content>
      <categories>
        <category>pulsar</category>
      </categories>
      <tags>
        <tag>pulsar</tag>
      </tags>
  </entry>
  <entry>
    <title>消息存储原理与 ID 规则</title>
    <url>/2022/02/15/20220215-pulsar-storage/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇文章对Pulsar的topic和分区做了介绍，这一篇我们就来对消息存储原理和ID规则来进行一下介绍，在本篇介绍中可能会出现一些让你非常困惑的词汇。不过不要紧我都会一一来进行解释</p>
<h2 id="消息-ID-生成规则"><a href="#消息-ID-生成规则" class="headerlink" title="消息 ID 生成规则"></a>消息 ID 生成规则</h2><p>在 Pulsar 中，每条消息都有属于的自己的唯一 ID（即 MessageID），MessageID 由四部分组成：<code>ledgerId:entryID:partition-index:batch-index</code>。其中：</p>
<ul>
<li>partition-index：指分区的编号，在非分区 topic 的时候为 -1。</li>
<li>batch-index：在非批量消息的时候为 -1。</li>
</ul>
<p>消息 ID 的生成规则由 Pulsar 的消息存储机制决定，Pulsar 中消息存储原理图如下：</p>
<img src="/2022/02/15/20220215-pulsar-storage/1.png" style="zoom: 50%;">

<p>如上图所示，在 Pulsar中，一个 Topic 的每一个分区会对应一系列的 ledger，其中只有一个 ledger 处于 open 状态即可写状态，而每个 ledger 只会存储与之对应的分区下的消息。</p>
<p>Pulsar 在存储消息时，会先找到当前分区使用的 ledger ，然后生成当前消息对应的 entry ID，entry ID 在同一个 ledger 内是递增的。每个 ledger 存在的时长或保存的 entry 个数超过阈值后会进行切换，新的消息会存储到同一个 partition 中的下一个 ledger 中。</p>
<ul>
<li>批量生产消息情况下，一个 entry 中可能包含多条消息。</li>
<li>非批量生产的情况下，一个 entry 中包含一条消息（producer 端可以配置这个参数，默认是批量的）。</li>
</ul>
<p>Ledger 只是一个逻辑概念，是数据的一种逻辑组装维度，并没有对应的实体。而 bookie 只会按照 entry 维度进行写入、查找、获取。</p>
<h2 id="分片机制详解：Legder-和-Entry"><a href="#分片机制详解：Legder-和-Entry" class="headerlink" title="分片机制详解：Legder 和 Entry"></a>分片机制详解：Legder 和 Entry</h2><p>Pulsar 中的消息数据以 ledger 的形式存储在 BookKeeper 集群的 bookie 存储节点上。Ledger 是一个只追加的数据结构，并且只有一个写入器，这个写入器负责多个 bookie 的写入。Ledger 的条目会被复制到多个 bookie 中，同时会写入相关的数据来保证数据的一致性。</p>
<p>BookKeeper 需要保存的数据包括：</p>
<ul>
<li><strong>Journals</strong><ul>
<li>journals 文件里存储了 BookKeeper 的事务日志，在任何针对 ledger 的更新发生前，都会先将这个更新的描述信息持久化到这个 journal 文件中。</li>
<li>BookKeeper 提供有单独的 sync 线程根据当前 journal 文件的大小来作 journal 文件的 rolling。</li>
</ul>
</li>
<li><strong>EntryLogFile</strong><ul>
<li>存储真正数据的文件，来自不同 ledger 的 entry 数据先缓存在内存buffer中，然后批量flush到EntryLogFile中。</li>
<li>默认情况下，所有ledger的数据都是聚合然后顺序写入到同一个EntryLog文件中，避免磁盘随机写。</li>
</ul>
</li>
<li><strong>Index 文件</strong><ul>
<li>所有 Ledger 的 entry 数据都写入相同的 EntryLog 文件中，为了加速数据读取，会作 ledgerId + entryId 到文件 offset 的映射，这个映射会缓存在内存中，称为 IndexCache。</li>
<li>IndexCache 容量达到上限时，会被 sync 线程 flush 到磁盘中。</li>
</ul>
</li>
</ul>
<img src="/2022/02/15/20220215-pulsar-storage/2.png" style="zoom: 50%;">

<p>刚开始看到这里的时候我是有点懵逼的，这都是些啥啊，但是后面仔细思考下，这个设计似乎和mysql的底层原理几乎一致，Journals相当于redolog，EntryLogFile+Index相当于bufferpool。还不明白那就接着看下面的介绍：</p>
<p><strong>Entry 数据写入</strong></p>
<ol>
<li>数据首先会同时写入 Journal（写入 Journal 的数据会实时落到磁盘）和 Memtable（读写缓存）。</li>
<li>写入 Memtable 之后，对写入请求进行响应。</li>
<li>Memtable 写满之后，会 flush 到 Entry Logger 和 Index cache，Entry Logger 中保存数据，Index cache 中保存数据的索引信息，</li>
<li>后台线程将 Entry Logger 和 Index cache 数据落到磁盘。</li>
</ol>
<p><strong>Entry 数据读取</strong></p>
<ul>
<li>Tailing read 请求：直接从 Memtable 中读取 Entry。</li>
<li>Catch-up read（滞后消费）请求：先读取 Index信息，然后索引从 Entry Logger 文件读取 Entry。</li>
</ul>
<p><strong>数据一致性保证：LastLogMark</strong></p>
<ul>
<li>写入的 EntryLog 和 Index 都是先缓存在内存中，再根据一定的条件周期性的 flush 到磁盘，这就造成了从内存到持久化到磁盘的时间间隔，如果在这间隔内 BookKeeper 进程崩溃，在重启后，我们需要根据 journal 文件内容来恢复，这个 LastLogMark 就记录了从 journal 中什么位置开始恢复。</li>
<li>它其实是存在内存中，当 IndexCache 被 flush 到磁盘后其值会被更新，LastLogMark 也会周期性持久化到磁盘文件，供 Bookkeeper 进程启动时读取来从 journal 中恢复。</li>
<li>LastLogMark 一旦被持久化到磁盘，即意味着在其之前的 Index 和 EntryLog 都已经被持久化到了磁盘，那么 journal 在这 LastLogMark 之前的数据都可以被清除了。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="/2022/02/15/20220215-pulsar-storage/5.jpg" style="zoom: 100%;">]]></content>
      <categories>
        <category>pulsar</category>
      </categories>
      <tags>
        <tag>pulsar</tag>
      </tags>
  </entry>
  <entry>
    <title>Pulsar Topic 和分区</title>
    <url>/2022/02/14/20220214-pulsar-arch/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本人最近正在重构一个vdc（virus detect center）系统，为了将旧系统解耦我们将原系统拆分成了很多子系统，系统之间通过mq进行交互，在这之前本人对kafka已经是有些许了解，但是这次小组决定使用pulsar来替代kafka，那么究竟pulsar有什么好，它较kafka到底有什么优势，本人接下来的一个系列篇章就会对pulsar来进行介绍，同时也会讲解实际使用中的一些用法与问题，本系列文章的前提是假定大家对kafka都是一定了解的。</p>
<h2 id="Apache-Pulsar-架构"><a href="#Apache-Pulsar-架构" class="headerlink" title="Apache Pulsar 架构"></a>Apache Pulsar 架构</h2><p>Apache Pulsar 是一个发布-订阅模型的消息系统，由 Broker、Apache BookKeeper、Producer、Consumer 等组件组成。我们知道传统mq的组成是没有Apache BookKeeper这一组件的，那么这个Apache BookKeeper究竟是何方神圣，后面我们会详细说一说</p>
<p>先看一张整体的结构图：</p>
<img src="/2022/02/14/20220214-pulsar-arch/1.png" style="zoom: 50%;">

<ul>
<li>Producer ： 消息的生产者，负责发布消息到 Topic。</li>
<li>Consumer：消息的消费者，负责从 Topic 订阅消息。</li>
<li>Broker：无状态服务层，负责接收和传递消息，集群负载均衡等工作，Broker 不会持久化保存元数据，因此可以快速的上、下线。</li>
<li>Apache BookKeeper：有状态持久层，由一组 Bookie 存储节点组成，可以持久化地存储消息。</li>
</ul>
<p>了解kafka的朋友相信一眼就能看出一些异样，那就是kafka的存储其实就是放在broker上面的，也就是说存储与计算实际上是一体的，而从上图可知 Apache Pulsar 在架构设计上采用了计算与存储分离的模式，消息发布和订阅相关的计算逻辑在 Broker 中完成，数据存储在 Apache BookKeeper 集群的 Bookie 节点上。</p>
<h2 id="Topic-与分区"><a href="#Topic-与分区" class="headerlink" title="Topic 与分区"></a>Topic 与分区</h2><p>Topic（主题）是某一种分类的名字，消息在 Topic 中可以被存储和发布。生产者往 Topic 中写消息，消费者从 Topic 中读消息。</p>
<p>Pulsar 的 Topic 分为 Partitioned Topic 和 Non-Partitioned Topic 两类，Non-Partitioned Topic 可以理解为一个分区数为1的 Topic。实际上在 Pulsar 中，Topic 是一个虚拟的概念，创建一个3分区的 Topic，实际上是创建了3个“分区Topic”，发给这个 Topic 的消息会被发往这个 Topic 对应的多个 “分区Topic”。<br>例如：生产者发送消息给一个分区数为3，名为<code>my-topic</code>的 Topic，在数据流向上是均匀或者按一定规则（如果指定了key）发送给了 <code>my-topic-partition-0</code>、<code>my-topic-partition-1</code> 和 <code>my-topic-partition-2</code> 三个“分区 Topic”。</p>
<p>分区 Topic 做数据持久化时，分区是逻辑上的概念，实际存储的单位是分片（Segment）的。</p>
<p>如下图所示，分区 Topic1-Part2 的数据由N个 Segment 组成， 每个 Segment 均匀分布并存储在 Apache BookKeeper 群集中的多个 Bookie 节点中， 每个 Segment 具有3个副本。</p>
<img src="/2022/02/14/20220214-pulsar-arch/2.png" style="zoom: 50%;">



<h2 id="物理分区与逻辑分区"><a href="#物理分区与逻辑分区" class="headerlink" title="物理分区与逻辑分区"></a>物理分区与逻辑分区</h2><p>逻辑分区和物理分区对比如下：</p>
<img src="/2022/02/14/20220214-pulsar-arch/3.png" style="zoom: 60%;">

<p><strong>物理分区：</strong>计算与存储耦合，容错需要拷贝物理分区，扩容需要迁移物理分区来达到负载均衡。</p>
<p><strong>逻辑分区</strong>：物理“分片”，计算层与存储层隔离，这种结构使得 Apache Pulsar 具备以下优点。</p>
<ul>
<li>Broker 和 Bookie 相互独立，方便实现独立的扩展以及独立的容错。</li>
<li>Broker 无状态，便于快速上、下线，更加适合于云原生场景。</li>
<li>分区存储不受限于单个节点存储容量。</li>
<li>分区数据分布均匀，单个分区数据量突出不会使整个集群出现木桶效应。</li>
<li>存储不足扩容时，能迅速利用新增节点平摊存储负载。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="/2022/02/14/20220214-pulsar-arch/5.jpg" style="zoom: 100%;">]]></content>
      <categories>
        <category>pulsar</category>
      </categories>
      <tags>
        <tag>pulsar</tag>
      </tags>
  </entry>
  <entry>
    <title>和弦的构成（分析）</title>
    <url>/2021/10/10/20211010-guitar/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>弹了有段时间的吉他的，一直对吉他乐理方面没有做一个系统的分析，今天来对常用3和弦和7和弦做一个完整的分析以及公式总结</p>
<h2 id="3和弦"><a href="#3和弦" class="headerlink" title="3和弦"></a>3和弦</h2><ul>
<li><p>大3和弦（大三度+小三度）</p>
<p>例如：<br>C和弦 组成音： 1 &lt;大三度&gt; 3 &lt;小三度&gt; 5<br>D和弦 组成音： 2 &lt;大三度&gt; 4(#) &lt;小三度&gt; 6 </p>
<p>同理可推导<br>G和弦 组成音：5 &lt;大三度&gt; 7 &lt;小三度&gt; 2^</p>
</li>
<li><p>小3和弦（小三度+大三度）</p>
<p>例如：<br>Cm和弦 组成音： 1 &lt;小三度&gt; 3(b) &lt;大三度&gt; 5<br>Dm和弦 组成音： 2 &lt;小三度&gt; 4 &lt;大三度&gt; 6</p>
<p>同理可以推导</p>
<p>Gm和弦 组成音： 5 &lt;小三度&gt; 7(b) &lt;大三度&gt; 2^</p>
</li>
<li><p>增3和弦（大三度+大三度）</p>
<p>例如：C+或者 Caug</p>
</li>
<li><p>减3和弦（小三度+小三度）</p>
<p>例如：C- 或者 Cdim</p>
</li>
</ul>
<h2 id="7和弦"><a href="#7和弦" class="headerlink" title="7和弦"></a>7和弦</h2><p>记得看中国好声音时，李荣浩说leehom的《爱错》中的bridge中那句在这少了你的世界那里的7减5和弦让他头皮发麻，这就来看看啥是7减5和弦，其实那时说7减5的时候王力宏是懵逼的，专业叫法应该叫半减7和弦。</p>
<ul>
<li><p>大小7和弦（属7和弦）（大三和弦+小7度）[小7度就是包含两个半音，大7度就是包含一个半音]</p>
<p>例如：</p>
<p>C7和弦组成音本质就是 C和弦+小7度（1 3 5 + 7(b)）</p>
<p>F7和弦组成音本质就是 F和弦+小7度（4 6 1^ + 3^(b)）</p>
</li>
<li><p>小7和弦（小三和弦+小7度）</p>
<p>例如：</p>
<p>Cm7和弦的组成音本质就是 Cm和弦+小7度 （1 3(b) 5 7(b)）</p>
</li>
<li><p>大7和弦（大三和弦+大7度）</p>
<p>例如：</p>
<p>Cmaj7和弦组成音本质就是C和弦+大7度（1 3 5 + 7）</p>
<p>Fmaj7和弦组成音本质就是F和弦+大7度 （4 6 1^ 3^）</p>
</li>
<li><p>小大7和弦（小三和弦+大7度）</p>
<p>例如：</p>
<p>Cmmaj7和弦组成音本质就是Cm和弦+大7度（1 3(b) 5 7）</p>
</li>
<li><p>半减7和弦</p>
<p>例如：</p>
<p>Bm7-5 这个和弦就是上面说到的让李荣浩头皮发麻的7-5和弦了，没错这种和弦的收缩性非常强，用到合适的地方确实会头皮发麻。</p>
<p>那么这个和弦的本质其实就是Bm和弦(7 2^ 4^(#) + 小7度 + 5音降半音 ( 7 2^ 4^ 6^)</p>
<p>所以通过公式我们也可以推到出Ammaj7-5和弦的组成音了，哈哈哈 虽然这个和弦不一定存在。</p>
</li>
</ul>
<h2 id="和弦色彩"><a href="#和弦色彩" class="headerlink" title="和弦色彩"></a>和弦色彩</h2><p>今天不打算对和弦色彩进行总结，但是要提一句的是，和弦色彩对于编配来说实在是太重要了，就好像一首歌你可以用4536251去完成，你也可以用分割和弦 5/4去代替其中的5，但是两者表达出来的色彩是完全不一样的。后面会对和弦色彩进行一次详细的记录。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>像我这种业余玩流行音乐的，和弦其实是一个非常重要的理论基础，就像我们写程序你要写好代码就一定要懂原理，老实说其实掌握一些和弦套路例如6451，4536251还有17654325(卡农和弦)低音下行这些后基本上流行乐坛百分之70的歌你都能弹唱了，无非就是一首换一首，就像你你做开发选用的是dubbo框架还是springcloud框架一样。但是如果想玩的更有趣一点就需要去了解这些框架的构成原理了。</p>
<p><img src="/2021/10/10/20211010-guitar/6.jpg" alt></p>
]]></content>
      <categories>
        <category>乐理</category>
      </categories>
      <tags>
        <tag>guitar</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建一个高性能cdk系统</title>
    <url>/2021/10/08/20211008-cdk/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本人前不久稍稍改进了一个cdkey系统，来总结下是如何设计一个cdkey(兑换码)系统的，本文打算从以下三个方面来说。</p>
<ul>
<li>cdkey兑换</li>
<li>如何生成cdkey以及如何存储</li>
<li>如何保证高可用</li>
</ul>
<h2 id="cdkey兑换"><a href="#cdkey兑换" class="headerlink" title="cdkey兑换"></a>cdkey兑换</h2><p>cdkey本身只是一种推广售卖方式，其实不用也是可以的，不过市面上的商品一般除了正常的收费购买之外一定会伴随有cdkey售卖这样的方式。一个cdkey就对应着一个具体的商品，这也意味着cdkey是需要与商品以及订进行绑定的，举个例子，类似这样的一串字符串XXX3XXXNLMX1YEXXX就是cdkey的一个样式，是一个36进制构成的16位表达式，一般先由系统提前生成好然后下发出去售卖或者活动赠送等，兑换的时候做一些校验工作然后是生成订单流程，订单流程走完之后最后将订单号与cdkey绑定并将其状态更改成已兑换。流程如下图:</p>
<p>流程图因涉及到公司的业务流转 不方便在此贴出</p>
<h2 id="如何生成cdkey以及如何存储"><a href="#如何生成cdkey以及如何存储" class="headerlink" title="如何生成cdkey以及如何存储"></a>如何生成cdkey以及如何存储</h2><p>上一节提到目前系统的cdkey是一个36进制的16位表达式，针对36进制我们可以预先定义一个数组：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">myVal = []<span class="keyword">string</span>&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>, <span class="string">"K"</span>, <span class="string">"L"</span>, <span class="string">"M"</span>, <span class="string">"N"</span>, <span class="string">"O"</span>, <span class="string">"P"</span>,<span class="string">"Q"</span>, <span class="string">"R"</span>, <span class="string">"S"</span>, <span class="string">"T"</span>, <span class="string">"U"</span>, <span class="string">"V"</span>, <span class="string">"W"</span>, <span class="string">"X"</span>, <span class="string">"Y"</span>, <span class="string">"Z"</span>,<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>&#125;</span><br><span class="line"><span class="comment">//生成一个cdk的代码，所以是有可能一批cdk里面产生重复的，必须做好本地去重</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genOneKey</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	buf.Reset()</span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">16</span>; j++ &#123;</span><br><span class="line">		val := rand.Intn(<span class="built_in">len</span>(myVal))</span><br><span class="line">		buf.WriteString(myVal[val])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然为了安全我们也可以将上述的数组顺序随意打乱，这种方式在上一篇短链系统设计的时候已经用过一次了，只不过短链用的是64进制而已。我们也可以使用64进制来降低cdkey生成时的碰撞率，不过就cdkey而言为了美观一般就不掺杂小写字母了。本人目前的需求是需要支持大批量cdk申请的，单批次申请需要支持10w，所以我这边cdkey的生成实际是按批次生成的，这样的好处就是可以减少与数据库的网络IO，每次生成一批cdkey然后去数据库校验是否存在，存在了就重试生成一批新cdkey再校验，直到校验不存在就插入数据库然后生成下一批，反复执行直到申请数量全部生成完毕。</p>
<p>总体流程图如下：</p>
<p><img src="/2021/10/08/20211008-cdk/2.png" alt></p>
<p>接下来是单批次生成cdk详细逻辑:</p>
<p><img src="/2021/10/08/20211008-cdk/3.png" alt></p>
<p>给出表设计方案 : </p>
<p>下面的表中很多字段都是与具体业务相关的，不必过于关心，但是核心的字段在一个cdk系统中基本上都是不变的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//因为表设计也有相关敏感信息不方便在此处贴出具体字段</span><br><span class="line">//cdk订单申请表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`cdk_order`</span> (</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COMMENT</span>=<span class="string">'cdk申请单表'</span></span><br><span class="line"></span><br><span class="line">//cdk详情表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`cdk_detail`</span> (</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COMMENT</span>=<span class="string">'cdk明细表'</span></span><br></pre></td></tr></table></figure>

<h2 id="如何保证高可用"><a href="#如何保证高可用" class="headerlink" title="如何保证高可用"></a>如何保证高可用</h2><p>一般来说通过集群部署可解决系统高可用问题，但是集群部署就会导致新的问题，可能两个服务节点同时工作产生的cdkey就有可能会出现交集本地去重并不能解决问题，这里我列出了两种方案来解决这个问题，就当前情况而言本人采用了第一种方案:</p>
<ul>
<li><p>方案一：通过数据库自身来解决该问题</p>
<p>上一节介绍的方案就是了，通过数据库校验 + 事务 + 重试来解决</p>
</li>
<li><p>方案二：通过分布式锁+bloomfilter来解决这个问题</p>
<p>见方案设计图:</p>
<p><img src="/2021/10/08/20211008-cdk/4.png" alt></p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对cdk系统设计方案作了一点总结，整体的思路就是要减少碰撞，保证申请数量与实际生成数量一致，并且要防止一次性提交数据量过大，具体最后的高可用方案哪种更合适还是依据实际情况再做定夺为佳。</p>
<p><img src="/2021/10/08/20211008-cdk/5.jpg" alt></p>
]]></content>
      <categories>
        <category>工作沉淀</category>
      </categories>
      <tags>
        <tag>系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能短链系统的一些设计思考</title>
    <url>/2021/09/27/20210927-shorturl/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近遇到一个需求，需要短时间内将大量的长链转换成短链然后再转成二维码，由于我们的短链服务是通过接口外部进行调用的，而且不能批量转换，所以这里就会出现一个情况就是短时间的大量请求接口会以失败告终，如果能自己设计一个短链系统，这个问题就能解决了。那么今天就来谈谈如何设计一个高性能短链系统。</p>
<p>本文将会从以下几个方面来进行探讨 </p>
<ul>
<li>为啥要用短链 长链存在哪些问题</li>
<li>短链是如何实现跳转的</li>
<li>如何生成短链以及如何存储</li>
<li>如何保证高性能高可用</li>
</ul>
<h2 id="为啥要用短链-长链存在哪些问题"><a href="#为啥要用短链-长链存在哪些问题" class="headerlink" title="为啥要用短链 长链存在哪些问题"></a>为啥要用短链 长链存在哪些问题</h2><p>下面是自如给我发的推送短信，点击下方蓝色的链接（短链）</p>
<p><img src="/2021/09/27/20210927-shorturl/1.png" alt="img"></p>
<p>浏览器接着会跳转到一个确认跳转页面。</p>
<p><img src="/2021/09/27/20210927-shorturl/2.jpeg" alt="img"></p>
<p>那么为啥要用短链表示，直接用长链不行吗，用短链的话有如下好外</p>
<p>1、链接变短，在对内容长度有限制的平台发文，可编辑的文字就变多了</p>
<p>最典型的就是微博，限定了只能发 140 个字，如果一串长链直接怼上去，其他可编辑的内容就所剩无几了，用短链的话，链接长度大大减少，自然可编辑的文字多了不少。</p>
<p>再比如上面的短信如果一个长链直接怼上去满屏都是一个链接，非常不美观。</p>
<p>2、像我前言中的需求需要将链接转成二维码，如果是长链的话二维码非常密集而且很难识别，短链的话就会清爽很多,如下图所示</p>
<p><img src="/2021/09/27/20210927-shorturl/3.png" alt="img"></p>
<p>3、链接太长在有些平台上无法自动识别为超链接</p>
<h2 id="短链是如何实现跳转的"><a href="#短链是如何实现跳转的" class="headerlink" title="短链是如何实现跳转的"></a>短链是如何实现跳转的</h2><p>从上文可知，短链好处多多，那么它是如何工作的呢。我们在浏览器抓下包看看</p>
<p><img src="/2021/09/27/20210927-shorturl/10.png" alt="img"></p>
<p>可以看到请求后，返回了状态码 302（重定向）与 location 值为长链的响应，然后浏览器会再请求这个长链以得到最终的响应,整个交互流程图如下</p>
<p><img src="/2021/09/27/20210927-shorturl/11.png" alt="img"></p>
<p>主要步骤就是访问短网址后重定向访问 B，那么问题来了，301 和 302 都是重定向，到底该用哪个，这里需要注意一下 301 和 302 的区别</p>
<ul>
<li>301，代表 <strong>永久重定向</strong>，也就是说第一次请求拿到长链接后，下次浏览器再去请求短链的话，不会向短网址服务器请求了，而是直接从浏览器的缓存里拿，这样在 server 层面就无法获取到短网址的点击数了，如果这个链接刚好是某个活动的链接，也就无法分析此活动的效果。所以我们一般不采用 301。</li>
<li><strong>302</strong>，代表 <strong>临时重定向</strong>，也就是说每次去请求短链都会去请求短网址服务器（除非响应中用 Cache-Control 或 Expired 暗示浏览器缓存）,这样就便于 server 统计点击数，所以虽然用 302 会给 server 增加一点压力，但在数据异常重要的今天，这点代码是值得的，所以推荐使用 302！</li>
</ul>
<h2 id="如何生成短链以及如何存储"><a href="#如何生成短链以及如何存储" class="headerlink" title="如何生成短链以及如何存储"></a>如何生成短链以及如何存储</h2><h3 id="1、Hash"><a href="#1、Hash" class="headerlink" title="1、Hash"></a>1、Hash</h3><p>短链怎么生成，我的第一反应,这不就是以不定长输入(长链)转换成定长输出(短链)【哈希的定义】，观察上面的短链很明显可以看到短链是由固定短链域名 + 长链映射成的一串字母组成(不定长输入–&gt;定长输出)，那么这个哈希函数该怎么取呢，相信肯定有很多人说用 MD5，SHA 等算法，网上确实有很多是用md5先生成32位串，然后均分4段做hash处理，最后再随机取其中之一作为最后结果，只是我在想这个md5先生成32位串是否一定有必要，而且既然是加密就意味着性能上会有损失，其实我觉得这里的重点应该是hash并不是加解密，如何提升哈希的运算速度和减少冲突概率才是重点。以下属于借鉴内容了这里推荐 Google 出品的 <strong>MurmurHash 算法</strong>，MurmurHash 是一种<strong>非加密型</strong>哈希函数，适用于一般的哈希检索操作。与其它流行的哈希函数相比，对于规律性较强的 key，MurmurHash 的随机分布特征表现更良好。非加密意味着着相比 MD5，SHA 这些函数它的性能肯定更高（实际上性能是 MD5 等加密算法的十倍以上），也正是由于它的这些优点，所以虽然它出现于 2008，但目前已经广泛应用到 Redis、MemCache、Cassandra、HBase、Lucene 等众多著名的软件中。</p>
<p>MurmurHash 提供了两种长度的哈希值，32 bit，128 bit，为了让网址尽可通地短，我们选择 32 bit 的哈希值，<strong>32 bit 能表示的最大值近 43 亿</strong>，对于中小型公司的业务而言绰绰有余。对上文提到的极客长链做 MurmurHash 计算，得到的哈希值为 3002604296，于是我们现在得到的短链为 固定短链域名+哈希值 = <a href="http://xxx.com/a/3002604296" target="_blank" rel="noopener">http://xxx.com/a/3002604296</a></p>
<p><strong>上述结果还是有点长？</strong></p>
<p>觉得10位的短链还是有点长怎么办？首先3002604296 这个结果是10进制数字，有一种方案就是将它转为 62 进制就可以缩短它的长度，10 进制转 62 进制如下，也就是按62取模，对应的余数在下面的字符串中取对应值：</p>
<p>62进制思路 : 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</p>
<p><img src="/2021/09/27/20210927-shorturl/7.png" alt="img"></p>
<p>经过上面的取模运算然后取映射值，就可以将(3002604296)10进制数字转换成 (3hcCxy)62进制，立马又缩短了4位，因此最终的短链为 <a href="http://xxx.com/a/3hcCxy，6" target="_blank" rel="noopener">http://xxx.com/a/3hcCxy，6</a> 位 62 进制数可表示 568 亿的数，应付长链转换绰绰有余，如果需要更短一点也是可以的，根据实际需求进行取舍吧，我们公司目前用的是8位<a href="https://xxx.com/r8CpSjCN" target="_blank" rel="noopener">https://xxx.com/r8CpSjCN</a></p>
<p><strong>hash冲突了怎么办？</strong></p>
<p>既然是哈希函数，那么很有可能两个不同的长链经过hash之后生成的短链是一样的，那么这个问题要怎么解决？这里给出的思路就是在长链的基础上添加随机字符串然后重试生成短链。</p>
<p>由上文知道访问短链能跳转到长链，那么长短链的关系一定是有一个地方存储的， <strong>Redis 或 Mysql</strong> ？，一般来说 Mysql 存储首选，redis缓存首选。表结构如下所示</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`long_short_url_map`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`long_url`</span> <span class="built_in">varchar</span>(<span class="number">160</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'长链'</span>,</span><br><span class="line">  <span class="string">`short_url`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'短链'</span>,</span><br><span class="line">  <span class="string">`created_at`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span></span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<p>基于上面的组件可以做出如下的设计。</p>
<ol>
<li>长链（longurl）经过 MurmurHash 后取模62得到最终短链。</li>
<li>再根据短链去 long_short_url_map 表中查找看是否存在相关记录，如果不存在，将长链与短链对应关系插入数据库中，存储。</li>
<li><strong>如果存在，说明已经有相关记录了，此时在长串上拼接一个自定义好的字段，比如「duplicate+RandomNum」，「longurl + duplicate+RandomNum」去重试第一步操作，如果最后还是重复就继续重拾，如果没有重复了就把原longurl和短链的关系存储即可</strong>。</li>
</ol>
<p>上面的步骤是没有加入缓存的，插入一条记录是需要经过两次(甚至三次(概率微乎其微)) sql 查询（1.根据短链查记录是否存在 2.将长短链对应关系插入数据库中），像我前言中的需求在高并发下，明显还是会有瓶颈出现的。一般数据库和应用服务（只做计算不做存储）会部署在两台不同的 server 上，执行两条 sql 就需要两次网络通信，<strong>这两次网络通信与两次 sql 执行是整个短链系统的性能瓶颈所在</strong>！</p>
<p>引入缓存减少第一次的sql查询？</p>
<p>很显然插入数据那一次的sql肯定没跑了，无论怎样那一次的sql都是要执行的</p>
<ol>
<li>方案一 : 给短链字段 short_url 加上<strong>唯一索引</strong>，把唯一性校验直接交给数据库去做，可行但是数据库压力很大（唯一索引懂的都懂）</li>
<li>方案二 : 数据量很大的情况下，冲突的概率会增大，此时我们可以使用加<strong>Bloomfilter</strong>(缓存)来进行优化。</li>
</ol>
<p><strong>用所有生成的短网址构建布隆过滤器</strong>，当一个新的长链生成短链后，先将此短链在Bloomfilter中进行查找，如果不存在，说明 db 里不存在此短网址，可以插入，插入db之前先将短链放入Bloomfilter。Bloomfilter是一种非常省内存的数据结构，长度为 10 亿的布隆过滤器，只需要 125 M 的内存空间。</p>
<p>综上，如果用哈希函数来设计，总体的设计思路如下</p>
<p><img src="/2021/09/27/20210927-shorturl/5.png" alt="img"></p>
<p>用哈希算法生成的短链其实已经能满足我们的业务需求，本人目前工作中遇到的短链就是用hash生成的只不过保留的是8位。其实还有另外一种是通过自增序列</p>
<h3 id="2、Sequence"><a href="#2、Sequence" class="headerlink" title="2、Sequence"></a>2、Sequence</h3><p>待完善</p>
<h2 id="高性能短链的架构设计"><a href="#高性能短链的架构设计" class="headerlink" title="高性能短链的架构设计"></a>高性能短链的架构设计</h2><p>在电商公司，经常有很多活动，秒杀，抢红包等等，在某个时间点的 QPS 会很高，考虑到这种情况，可以引入了 <strong>openResty</strong>，它是一个基于 Nginx 与 Lua 的高性能 Web 平台，由于 Nginx 的非阻塞 IO 模型，使用 openResty 可以轻松支持 100 w + 的并发数，一般情况下你只要部署一台即可，不过为了避免单点故障，两台为宜，同时 openResty 也自带了缓存机制，集成了 redis 这些缓存模块，也可以直接连 mysql。不需要再通过业务层连这些中间件，性能自然会高不少</p>
<p><img src="/2021/09/27/20210927-shorturl/6.png" alt="img"></p>
<p>上图所示，使用 openResty 可以直接跳过了业务层这一步，直达缓存层与数据库层，对性能也有大量提升。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对短链设计方案作了一点总结，文中涉及到像Bloomfilter，openResty 等技术，后续再去详细讨论。值得说明的是Bloomfilter的确是一个强大的缓存层有必要好好学习一番。</p>
<p><img src="/2021/09/27/20210927-shorturl/6.jpg" alt></p>
]]></content>
      <categories>
        <category>工作沉淀</category>
      </categories>
      <tags>
        <tag>系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义简易协程池踩坑记录</title>
    <url>/2021/09/14/20210914-goroutinepoolcpubug/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇文章中完善了一个自定义协程池，正所谓不改就没事，哈哈，果然上周测试环境发版后就出问题了，本人的服务的健康检查一发新版本之后就会立马unhealthy，然后先是观察容器cpu负载竟然是100%，好家伙，登陆容器通过top命令确定了就是自己的服务导致的，然后检查了自己修改过的代码，经过半天的排查果然找到了这个病因。</p>
<h2 id="代码展示（问题代码部分）"><a href="#代码展示（问题代码部分）" class="headerlink" title="代码展示（问题代码部分）"></a>代码展示（问题代码部分）</h2><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="comment">//运行一个groutine 开始消费任务 核心的问题就出在了下面这个方法内 </span></span><br><span class="line"><span class="comment">//for循环中嵌套了select 然后通过关闭通道进行跳出</span></span><br><span class="line"><span class="comment">//然而我之前的跳出用的是break，这里就是关键了</span></span><br><span class="line"><span class="comment">//break只能是跳出当前select，外层的for循环还是继续走的，然后就进入了死循环了</span></span><br><span class="line">func (self *Pool) runGroutine() &#123; // runningWorkers + 1</span><br><span class="line">	self.incRunningWorkers() //worker运行ing数量原子自增1</span><br><span class="line">	go func() &#123;</span><br><span class="line">		defer func() &#123;</span><br><span class="line">			self.decRunningWorkers() //worker运行ing数量原子自减1</span><br><span class="line">			if r := recover(); r != nil &#123;</span><br><span class="line">				<span class="comment">// if self.PanicHandler != nil &#123;</span></span><br><span class="line">				<span class="comment">// 	self.PanicHandler(r)</span></span><br><span class="line">				<span class="comment">// &#125; else &#123;</span></span><br><span class="line">				<span class="comment">// 	log.Printf("Worker panic: %s\n", r)</span></span><br><span class="line">				<span class="comment">// &#125;</span></span><br><span class="line">				err := errs.New(Panic_Sub_Goroutine, "子协程panic") //子协程panic是会导致主协程挂掉的，这一步也是必须进行捕获处理</span><br><span class="line">				self.ResultQuene &lt;- err</span><br><span class="line">			&#125;</span><br><span class="line">			self.checkWorker<span class="comment">()</span> <span class="comment">// 兜底机制，避免worker全部panic后没有worker消费队列中的数据,理论上这一步非常重要！否则有可能出现死锁状态</span></span><br><span class="line">		&#125;<span class="comment">()</span></span><br><span class="line">		for &#123;</span><br><span class="line">			select &#123;</span><br><span class="line">			case task, ok := &lt;-self.TaskQueue:</span><br><span class="line">				<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				  <span class="comment">//break</span></span><br><span class="line">					return //这里不要用break  break只能跳出一层第二层的for循环还会继续 会直接把cpu打满</span><br><span class="line">				&#125;</span><br><span class="line">				err := task<span class="comment">()</span></span><br><span class="line">				self.ResultQuene &lt;- err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="comment">()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好在是在测试环境发布时发现了这样的问题，如果是线上出现该问题还是比较麻烦的，总结就是对select的一些用法还是不够熟悉，下一篇文章就来对golang中的select用法进行一下总结<a href="https://stevenhoukai.github.io/2021/09/14/20210914-goroutineselect/"><strong>（点此处了解select用法总结）</strong></a>。</p>
<p><img src="/2021/09/14/20210914-goroutinepoolcpubug/6.jpg" alt></p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>go的select用法总结</title>
    <url>/2021/09/14/20210914-goroutineselect/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>沿着上一篇留下来的问题继续说，来总结下golang中的select的一些用法，避免后续踩坑。</p>
<p>首先golang中的select语句格式如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch1:</span><br><span class="line">        <span class="comment">// 如果从 ch1 信道成功接收数据，则执行该分支代码</span></span><br><span class="line">    <span class="keyword">case</span> ch2 &lt;- <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// 如果成功向 ch2 信道成功发送数据，则执行该分支代码</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 如果上面都没有成功，则进入 default 分支处理流程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　</p>
<p>直观上跟switch确实是有点相似的，但实际上两者有着本质上的区别。</p>
<p>select里的case后面并不带判断条件，而是一个信道的操作，不同于switch里的case，对于从其它语言转过来的开发者来说有些需要特别注意的地方。</p>
<p>golang 的 select 就是监听 IO 操作，当 IO 操作发生时，触发相应的动作每个case语句里必须是一个IO操作，确切的说，应该是一个面向channel的IO操作。</p>
<blockquote>
<p>注：Go 语言的 <code>select</code> 语句借鉴自 Unix 的 <code>select()</code> 函数，在 Unix 中，可以通过调用 <code>select()</code> 函数来监控一系列的文件句柄，一旦其中一个文件句柄发生了 IO 动作，该 <code>select()</code> 调用就会被返回（C 语言中就是这么做的），后来该机制也被用于实现高并发的 Socket 服务器程序。Go 语言直接在语言级别支持 <code>select</code>关键字，用于处理并发编程中通道之间异步 IO 通信问题。</p>
</blockquote>
<p>注意：如果 <code>ch1</code> 或者 <code>ch2</code> 信道都阻塞的话，就会立即进入 <code>default</code> 分支，并不会阻塞。但是如果没有 <code>default</code> 语句，则会阻塞直到某个信道操作成功为止。</p>
<h3 id="重要知识点"><a href="#重要知识点" class="headerlink" title="重要知识点"></a>重要知识点</h3><ol>
<li><strong>select语句只能用于信道的读写操作</strong></li>
<li><strong>select中的case条件(非阻塞)是并发执行的，select会选择先操作成功的那个case条件去执行，如果多个同时返回，则随机选择一个执行，此时将无法保证执行顺序。对于阻塞的case语句会直到其中有信道可以操作，如果有多个信道可操作，会随机选择其中一个 case 执行</strong></li>
<li><strong>对于case条件语句中，如果存在信道值为nil的读写操作，则该分支将被忽略，可以理解为从select语句中删除了这个case语句</strong></li>
<li><strong>如果有超时条件语句，判断逻辑为如果在这个时间段内一直没有满足条件的case,则执行这个超时case。如果此段时间内出现了可操作的case,则直接执行这个case。一般用超时语句代替了default语句</strong></li>
<li><strong>对于空的select{}，会引起死锁</strong></li>
<li><strong>对于for中的select{}, 也有可能会引起cpu占用过高的问题</strong></li>
</ol>
<p>下面列出每种情况的示例代码</p>
<h3 id="1-select语句只能用于信道的读写操作"><a href="#1-select语句只能用于信道的读写操作" class="headerlink" title="1. select语句只能用于信道的读写操作"></a>1. select语句只能用于信道的读写操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"> </span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"> </span><br><span class="line">func main() &#123;</span><br><span class="line">    size := 10</span><br><span class="line">    ch := make(chan int, size)</span><br><span class="line">    for i := 0; i &lt; size; i++ &#123;</span><br><span class="line">        ch &lt;- 1</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ch2 := make(chan int, size)</span><br><span class="line">    for i := 0; i &lt; size; i++ &#123;</span><br><span class="line">        ch2 &lt;- 2</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ch3 := make(chan int, 1)</span><br><span class="line"> </span><br><span class="line">    select &#123;</span><br><span class="line">    case 3 == 3:</span><br><span class="line">        fmt.Println(&quot;equal&quot;)</span><br><span class="line">    case v := &lt;-ch:</span><br><span class="line">        fmt.Print(v)</span><br><span class="line">    case b := &lt;-ch2:</span><br><span class="line">        fmt.Print(b)</span><br><span class="line">    case ch3 &lt;- 10:</span><br><span class="line">        fmt.Print(&quot;write&quot;)</span><br><span class="line">    default:</span><br><span class="line">        fmt.Println(&quot;none&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">语句会报错</span><br><span class="line"> </span><br><span class="line">prog.go:20:9: 3 == 3 evaluated but not used</span><br><span class="line">prog.go:20:9: select case must be receive, send or assign recv&lt;br&gt;从错误信息里我们证实了第一点。</span><br></pre></td></tr></table></figure>

<p>　　</p>
<h3 id="2-select中的case语句是随机执行的"><a href="#2-select中的case语句是随机执行的" class="headerlink" title="2. select中的case语句是随机执行的"></a>2. select中的case语句是随机执行的</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"> </span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"> </span><br><span class="line">func main() &#123;</span><br><span class="line">    size := 10</span><br><span class="line">    ch := make(chan int, size)</span><br><span class="line">    for i := 0; i &lt; size; i++ &#123;</span><br><span class="line">        ch &lt;- 1</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ch2 := make(chan int, size)</span><br><span class="line">    for i := 0; i &lt; size; i++ &#123;</span><br><span class="line">        ch2 &lt;- 2</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ch3 := make(chan int, 1)</span><br><span class="line"> </span><br><span class="line">    select &#123;</span><br><span class="line">    case v := &lt;-ch:</span><br><span class="line">        fmt.Print(v)</span><br><span class="line">    case b := &lt;-ch2:</span><br><span class="line">        fmt.Print(b)</span><br><span class="line">    case ch3 &lt;- 10:</span><br><span class="line">        fmt.Print(&quot;write&quot;)</span><br><span class="line">    default:</span><br><span class="line">        fmt.Println(&quot;none&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　多次执行的话，会随机输出不同的值，分别为1,2,write。这是因为ch和ch2是并发执行会同时返回数据，所以会随机选择一个case执行，。但永远不会执行default语句，因为上面的三个case都是可以操作的信道。</p>
<h3 id="3-对于case条件语句中，如果存在通道值为nil的读写操作，则该分支将被忽略"><a href="#3-对于case条件语句中，如果存在通道值为nil的读写操作，则该分支将被忽略" class="headerlink" title="3. 对于case条件语句中，如果存在通道值为nil的读写操作，则该分支将被忽略"></a>3. 对于case条件语句中，如果存在通道值为nil的读写操作，则该分支将被忽略</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"> </span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"> </span><br><span class="line">func main() &#123;</span><br><span class="line">    var ch chan int</span><br><span class="line">    // ch = make(chan int)</span><br><span class="line">     </span><br><span class="line">    go func(c chan int) &#123;</span><br><span class="line">        c &lt;- 100</span><br><span class="line">    &#125;(ch)</span><br><span class="line"> </span><br><span class="line">    select &#123;</span><br><span class="line">    case &lt;-ch:</span><br><span class="line">        fmt.Print(&quot;ok&quot;)</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">报错</span><br><span class="line"> </span><br><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"> </span><br><span class="line">goroutine 1 [select (no cases)]:</span><br><span class="line">main.main()</span><br><span class="line">    /tmp/sandbox488456896/main.go:14 +0x60</span><br><span class="line"> </span><br><span class="line">goroutine 5 [chan send (nil chan)]:</span><br><span class="line">main.main.func1(0x0, 0x1043a070)</span><br><span class="line">    /tmp/sandbox488456896/main.go:10 +0x40</span><br><span class="line">created by main.main</span><br><span class="line">    /tmp/sandbox488456896/main.go:9 +0x40</span><br><span class="line">可以看到 “goroutine 1 [select (no cases)]” ，虽然写了case条件，但操作的是nil通道，被优化掉了。</span><br><span class="line">要解决这个问题，只能使用make()进行初始化才可以。</span><br></pre></td></tr></table></figure>

<p>　　</p>
<h3 id="4-超时用法"><a href="#4-超时用法" class="headerlink" title="4. 超时用法"></a>4. 超时用法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"> </span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">func main() &#123;</span><br><span class="line">    ch := make(chan int)</span><br><span class="line">    go func(c chan int) &#123;</span><br><span class="line">        // 修改时间后,再查看执行结果</span><br><span class="line">        time.Sleep(time.Second * 1)</span><br><span class="line">        ch &lt;- 1</span><br><span class="line">    &#125;(ch)</span><br><span class="line"> </span><br><span class="line">    select &#123;</span><br><span class="line">    case v := &lt;-ch:</span><br><span class="line">        fmt.Print(v)</span><br><span class="line">    case &lt;-time.After(2 * time.Second): // 等待 2s</span><br><span class="line">        fmt.Println(&quot;no case ok&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    time.Sleep(time.Second * 10)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">我们通过修改上面的时等待时间可以看到，如果等待时间超出&lt;2秒，则输出1，否则打印“no case ok”</span><br></pre></td></tr></table></figure>

<p>　　</p>
<h3 id="5-空select"><a href="#5-空select" class="headerlink" title="5. 空select{}"></a>5. 空select{}</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"> </span><br><span class="line">func main() &#123;</span><br><span class="line">    select &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">goroutine 1 [select (no cases)]:</span><br><span class="line">main.main()</span><br><span class="line">/root/project/practice/mytest/main.go:10 +0x20</span><br><span class="line">exit status 2</span><br><span class="line">直接死锁</span><br></pre></td></tr></table></figure>

<p>　　</p>
<h3 id="6-for中的select-引起的CPU过高的问题（上一篇踩坑记录中就是这个问题）"><a href="#6-for中的select-引起的CPU过高的问题（上一篇踩坑记录中就是这个问题）" class="headerlink" title="6. for中的select 引起的CPU过高的问题（上一篇踩坑记录中就是这个问题）"></a>6. for中的select 引起的CPU过高的问题（上一篇踩坑记录中就是这个问题）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"> </span><br><span class="line">import (</span><br><span class="line">    &quot;runtime&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">func main() &#123;</span><br><span class="line">    quit := make(chan bool)</span><br><span class="line">    for i := 0; i != runtime.NumCPU(); i++ &#123;</span><br><span class="line">        go func() &#123;</span><br><span class="line">            for &#123;</span><br><span class="line">                select &#123;</span><br><span class="line">                case &lt;-quit:</span><br><span class="line">                    break</span><br><span class="line">                default:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    time.Sleep(time.Second * 15)</span><br><span class="line">    for i := 0; i != runtime.NumCPU(); i++ &#123;</span><br><span class="line">        quit &lt;- true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　</p>
<p>上面这段代码会把所有CPU都跑满，原因就就在<code>select</code>的用法上。</p>
<p>一般来说，我们用<code>select</code>监听各个<code>case</code>的IO事件，每个<code>case</code>都是阻塞的。上面的例子中，我们希望<code>select</code>在获取到<code>quit</code>通道里面的数据时立即退出循环，但由于他在for{}里面，在第一次读取quit后，仅仅退出了select{}，并未退出for，所以下次还会继续执行select{}逻辑，此时永远是执行default，直到<code>quit</code>通道里读到数据，否则会一直在一个死循环中运行，即使放到一个<code>goroutine</code>里运行，也是会占满所有的CPU。</p>
<p>解决方法我这里总结了有三种方案：</p>
<p><strong>1.使用break + 标示位置 相当于 使用goto 跳出for循环 。</strong></p>
<p><strong>2.使用return代替break 直接结束子goroutine 。</strong></p>
<p><strong>3.使用flag，二次break跳出for循环。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们在使用每一句代码时都需要时刻保持敬畏之心，先将其原理用法都弄清楚然后再投入使用是我们开发工程师应该时刻保持的原则。谨记～</p>
<p><img src="/2021/09/14/20210914-goroutineselect/6.jpg" alt></p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>简易协程池</title>
    <url>/2021/09/03/20210903-goroutinepool/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Go 的 goroutine 提供了一种较线程而言更廉价的方式处理并发场景, go 使用二级线程的模式, 将 goroutine 以 M:N 的形式复用到系统线程上, 节省了 cpu 调度的开销, 也避免了用户级线程（协程）进行系统调用时阻塞整个系统线程的问题。</p>
<p>但在实际的开发中如果待执行的tasks数量过多，可能带来的问题就是goroutine数量激增进而导致调度性能下降、GC 频繁、内存暴涨, 引发一系列问题。在面临这样的场景时, 限制 goroutine 的数量、重用 goroutine 显然很有价值。所以可以通过一个goroutine池来对所有的tasks进行排队执行，类似下面就是一个简单的goroutine池，通过定量的goroutine来进行任务的消费。设计下面的协程池有三个重点问题是需要重点考虑到的<br>1.如何确保任务全部都被消费完？<br>2.子goroutine发生panic如何处理？<br>3.子goroutine如果全部发生panic了怎么办？放任死锁吗？</p>
<p>这里并没考虑子goroutine执行时间太长的问题，主要原因我们可以自定义子goroutine的数量，我更希望的是任务能够执行完全而不是任务什么时候执行完，任务执行时间太长应该是业务侧的问题。</p>
<h2 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h2><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">import <span class="comment">(</span></span><br><span class="line"><span class="comment">    "sync"</span></span><br><span class="line"><span class="comment">    "sync/atomic"</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    "git.code.oa.com/trpc-go/trpc-go/errs"</span></span><br><span class="line"><span class="comment">    "git.code.oa.com/trpc-go/trpc-go/log"</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//自定义简单协程池 统一管理并发协程</span></span><br><span class="line"><span class="comment">//整体思路:定量的协程从同一个任务队列循环消费任务</span></span><br><span class="line"><span class="comment">//缺点:目前功能对协程超时情况存在缺陷 初始化函数中没有对初始化数量进行校验</span></span><br><span class="line">type Pool struct &#123;</span><br><span class="line">    TaskQueue      chan func() error //任务队列</span><br><span class="line">    WorkerNumber   int               //初始化worker数量</span><br><span class="line">    TaskNumber     int               //待消费任务数量</span><br><span class="line">    ResultQuene    chan error        //返回结果队列</span><br><span class="line">    FinishCallback func()            //全部任务消费完成的回调函数</span><br><span class="line">    runningWorkers int64             //运行中的worker数</span><br><span class="line">    sync.Mutex</span><br><span class="line">    <span class="comment">// PanicHandler   func(interface&#123;&#125;) //协程panic的处理函数 防止协程panic后导致主协程崩溃</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//初始化 根据自定义需求设定worker数量以及任务队列长度</span></span><br><span class="line">func (self *Pool) Init(WorkerNumber int, TaskNumber int) &#123;</span><br><span class="line">    self.WorkerNumber = WorkerNumber</span><br><span class="line">    self.TaskNumber = TaskNumber</span><br><span class="line">    self.TaskQueue = make(chan func() error, TaskNumber)</span><br><span class="line">    self.ResultQuene = make(chan error, TaskNumber)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//开启worker的消费动作</span></span><br><span class="line">func (self *Pool) Start() &#123;</span><br><span class="line">    <span class="comment">//默认开启 WorkerNumber个goruntine</span></span><br><span class="line">    for i := 0; i &lt; self.WorkerNumber; i++ &#123;</span><br><span class="line">        self.runGroutine()</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//获取每个任务的处理结果</span></span><br><span class="line">    for j := 0; j &lt; self.TaskNumber; j++ &#123;</span><br><span class="line">        err, ok := &lt;-self.ResultQue<span class="symbol">ne</span></span><br><span class="line">        //这里可以通过自定义决定是否上报日志</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            break</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if err != nil &#123;</span><br><span class="line">                log.Error<span class="comment">(err.Error()</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//结束时的回调函数 可以做一些通知操作等等</span></span><br><span class="line">    if self.FinishCallback != nil &#123;</span><br><span class="line">        self.FinishCallback()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//运行一个groutine 开始消费任务</span></span><br><span class="line">func (self *Pool) runGroutine() &#123; // runningWorkers + 1</span><br><span class="line">    self.incRunningWorkers() //worker运行ing数量原子自增1</span><br><span class="line">    go func() &#123;</span><br><span class="line">        defer func() &#123;</span><br><span class="line">            self.decRunningWorkers() //worker运行ing数量原子自减1</span><br><span class="line">            if r := recover(); r != nil &#123;</span><br><span class="line">                <span class="comment">// if self.PanicHandler != nil &#123;</span></span><br><span class="line">                <span class="comment">//  self.PanicHandler(r)</span></span><br><span class="line">                <span class="comment">// &#125; else &#123;</span></span><br><span class="line">                <span class="comment">//  log.Printf("Worker panic: %s\n", r)</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                err := errs.New(Panic_Sub_Goroutine, "子协程panic") //子协程panic是会导致主协程挂掉的，这一步也是必须进行捕获处理</span><br><span class="line">                self.ResultQuene &lt;- err</span><br><span class="line">            &#125;</span><br><span class="line">            self.checkWorker<span class="comment">()</span> <span class="comment">// 兜底机制，避免worker全部panic后没有worker消费队列中的数据,理论上这一步非常重要！否则有可能出现死锁状态</span></span><br><span class="line">        &#125;<span class="comment">()</span></span><br><span class="line">        for &#123;</span><br><span class="line">            select &#123;</span><br><span class="line">            case task, ok := &lt;-self.TaskQueue:</span><br><span class="line">                <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                    <span class="comment">//break 这里用break导致线上遇到了一个cpu被打满的bug 下一篇文章中进行说明</span></span><br><span class="line">                    retur<span class="symbol">n</span></span><br><span class="line">                &#125;</span><br><span class="line">                err := task<span class="comment">()</span></span><br><span class="line">                self.ResultQuene &lt;- err</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">()</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func (self *Pool) incRunningWorkers() &#123; // runningWorkers + 1</span><br><span class="line">    atomic.AddI<span class="symbol">nt64</span><span class="comment">(&amp;self.runningWorkers, 1)</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func (self *Pool) decRunningWorkers() &#123; // runningWorkers - 1</span><br><span class="line">    atomic.AddI<span class="symbol">nt64</span><span class="comment">(&amp;self.runningWorkers, -1)</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func (self *Pool) GetRunningWorkers() int64 &#123;</span><br><span class="line">    return atomic.LoadInt64(&amp;self.runningWorkers)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func (self *Pool) checkWorker() &#123;</span><br><span class="line">    self.Lock<span class="comment">()</span></span><br><span class="line">    defer self.Unlock()</span><br><span class="line"> </span><br><span class="line">    if self.GetRunningWorkers() == 0 &amp;&amp; len(self.TaskQueue) &gt; 0 &#123;</span><br><span class="line">        self.runGroutine()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//关闭通道避免内存泄漏</span></span><br><span class="line">func (self *Pool) Stop() &#123;</span><br><span class="line">    close<span class="comment">(self.TaskQueue)</span></span><br><span class="line">    close<span class="comment">(self.ResultQuene)</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//任务入队</span></span><br><span class="line">func (self *Pool) AddTask(task func() error) &#123;</span><br><span class="line">    self.TaskQueue &lt;- task</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//执行结束后的回调</span></span><br><span class="line">func (self *Pool) SetFinishCallback(fun func()) &#123;</span><br><span class="line">    self.FinishCallback = fun</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">ctx := context.Background()</span><br><span class="line">ids := make<span class="comment">([]int32, 0)</span></span><br><span class="line">var pool comm.Pool</span><br><span class="line">pool.Init(50, len(ids))</span><br><span class="line">count := int32(0)</span><br><span class="line">for _, id := range ids &#123;</span><br><span class="line">    idValue := id</span><br><span class="line">    pool.AddTask<span class="comment">(func()</span> error &#123;</span><br><span class="line">        return func(innerId int32) error &#123;</span><br><span class="line">            err := DoSomething(innerId)</span><br><span class="line">            if err != nil &#123;</span><br><span class="line">                log.ErrorContextf(ctx, "DoSomething failed, id:%d err:%s", innerId, err.Error())</span><br><span class="line">                return nil</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//以上执行无问题，完成数就+1</span></span><br><span class="line">            atomic.AddI<span class="symbol">nt32</span><span class="comment">(&amp;count, 1)</span></span><br><span class="line">            return nil</span><br><span class="line">        &#125;<span class="comment">(int32(idValue)</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//回调</span></span><br><span class="line">pool.SetFinishCallback(func() &#123;</span><br><span class="line">    <span class="comment">//自定义通知操作</span></span><br><span class="line">    fmt.Println("all done")</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//开始执行</span></span><br><span class="line">pool.Start<span class="comment">()</span></span><br><span class="line"><span class="comment">//关闭资源</span></span><br><span class="line">pool.Stop<span class="comment">()</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>池化管理自己的goroutine是非常有必要的，可以帮助我们提升开发效率降低异常风险！所以赶紧把你的goroutine管理起来吧</p>
<p><img src="/2021/09/03/20210903-goroutinepool/6.jpg" alt></p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的scan命令解释</title>
    <url>/2021/08/25/20210825-redisScanExplain/</url>
    <content><![CDATA[<h2 id="scan的种类"><a href="#scan的种类" class="headerlink" title="scan的种类"></a>scan的种类</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">原文地址:https://segmentfault.com/a/1190000018218584</span><br><span class="line"><span class="selector-tag">SCAN</span> <span class="selector-tag">cursor</span> <span class="selector-attr">[MATCH pattern]</span> <span class="selector-attr">[COUNT count]</span></span><br><span class="line"><span class="selector-tag">SSCAN</span> <span class="selector-tag">KEY</span> <span class="selector-tag">cursor</span> <span class="selector-attr">[MATCH pattern]</span> <span class="selector-attr">[COUNT count]</span></span><br><span class="line">HSCAN  KEY cursor [MATCH pattern] [COUNT count</span><br><span class="line"><span class="selector-tag">ZSCAN</span> <span class="selector-tag">KEY</span> <span class="selector-tag">cursor</span> <span class="selector-attr">[MATCH pattern]</span> <span class="selector-attr">[COUNT count]</span></span><br></pre></td></tr></table></figure>

<p>scan:迭代当前库</p>
<p>sscan:迭代一个 set 类型</p>
<p>hscan:迭代一个hash类型,并返回相应的值</p>
<p>zscan:迭代一个sorted set，并且返回相应的分数</p>
<p>知道redis是单进程单线程模型,keys和smembers这种命令可能会阻塞服务器,导致redis有可能出现长时间无法响应其他命令的情况,所以出现了scan系列的命令,通过返回一个游标，可以增量式迭代。</p>
<h2 id="scan类型命令的实现"><a href="#scan类型命令的实现" class="headerlink" title="scan类型命令的实现"></a>scan类型命令的实现</h2><p>scan,sscan,hscan,zsan分别有自己的命令入口,入口中会进行参数检测和游标赋值,然后进入统一的入口函数:scanGenericCommand,以hscan命令为例:</p>
<p><img src="/2021/08/25/20210825-redisScanExplain/1.png" alt="图片描述"><br>scanGenericCommand主要分四步:</p>
<ul>
<li>解析count和match参数.如果没有指定count,默认返回10条数据</li>
<li>开始迭代集合,如果key保存为ziplist或者intset,则一次性返回所有数据,没有游标(游标值直接返回0).由于redis设计只有数据量比较小的时候才会保存为ziplist或者intset,所以此处不会影响性能.</li>
</ul>
<p>游标在保存为hash的时候发挥作用,具体入口函数为dictScan,下文详细描述。</p>
<ul>
<li>根据match参数过滤返回值,并且如果这个键已经过期也会直接过滤掉(redis中键过期之后并不会立即删除)</li>
<li>返回结果到客户端,是一个数组,第一个值是游标,第二个值是具体的键值对</li>
</ul>
<h2 id="dictScan中游标的实现"><a href="#dictScan中游标的实现" class="headerlink" title="dictScan中游标的实现"></a>dictScan中游标的实现</h2><p>上文中我们了解到了redis中的rehash操作叫渐进式rehash，所以当迭代一个哈希表时,存在三种情况：</p>
<ul>
<li>从迭代开始到结束,哈希表没有进行rehash</li>
<li>从迭代开始到结束,哈希表进行了rehash,但是每次迭代时,哈希表要么没开始rehash,要么已经结束了rehash</li>
<li>从迭代开始到结束,某次或某几次迭代时哈希表正在进行rehash</li>
</ul>
<p>redis中的字典进行rehash时会存在两个哈希表，ht[0]与ht[1],并且是渐进式rehash(即不会一次性全部rehash);新的键值对会存放到ht[1]中并且会逐步将ht[0]的数据转移到ht[1].全部rehash完毕后,ht[1]赋值给ht[0]然后清空ht[1].</p>
<p>因此游标的实现需要兼顾以上三种情况,以上三种情况的游标实现要求如下:</p>
<ul>
<li>第一种情况比较简单,假设redis的哈希表大小为4,则第一次游标为0,读取第一个bucket的数据,然后游标返回1,下次读取第二个bucket的位置,依次遍历</li>
<li>第二种情况比较复杂,假设redis的哈希表大小为4,如果rehash完后size变成了8.如果仍然按照上边的思路返回游标,则如下图:</li>
</ul>
<p><img src="/2021/08/25/20210825-redisScanExplain/2.png" alt="图片描述"></p>
<p>假设bucket0读完之后返回了游标1,当客户端再次带着游标1返回时哈希表已经进行完rehash,并且size扩大了一倍变成了8.redis按如下方法计算一个键的bucket:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hash(key)&amp;(size<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

<p>即如果size是4时,hash(key)&amp;11,如果size是8时,hash(key)&amp;111.因此当从4扩容到8时,原先在0bucket的数据会分散到0(000)与4(100)两个bucket,bucket对应关系表如下:</p>
<p><img src="/2021/08/25/20210825-redisScanExplain/3.png" alt="图片描述"><br>从二进制来看,当size为4时,hash(key)之后取低两位即 hash(key)&amp;11即key的bucket位置,如果size为8时,bucket位置为 hash(key)&amp;111，即取低三位,当低两位为00时,如果第三位为0,则为000,如果第三位为1,则为100,正好是4.其他槽位的类似.所以如果此时继续按第一种方法遍历,第四个bucket取到的值全部为重复值</p>
<ul>
<li>第三种情况，如果返回游标1时正在进行rehash,ht[0]中的bucket 1中的部分数据可能已经rehash到 ht[1]中的bucket[1]或者bucket[5]，此时必须将ht[0]和ht[1]中的相应bucket全部遍历,否则可能会有遗漏数据</li>
</ul>
<p>所以为了兼顾以上三种情况,做到不漏数据并且尽量不重复,redis使用了一种叫做reverse binary iteration的方法.具体的游标计算代码如下，具体为什么这么做我也不知道，反正redis就是选择这么做了吗，而且效果很明显:</p>
<p><img src="/2021/08/25/20210825-redisScanExplain/4.png" alt="图片描述"><br>代码逻辑很简单,下面示例从4变为8和从4变为16以及从8变为4和从16变为4时,这种方法为何能够做到不重不漏</p>
<p><img src="/2021/08/25/20210825-redisScanExplain/5.png" alt="图片描述"><br>遍历size为4时的游标状态转移为0-2-1-3.</p>
<p>同理,size为8时的游标状态转移为0-4-2-6-1-5-3-7.</p>
<p>size为16时的游标状态转义为0-8-4-12-2-10-6-14-1-9-5-13-3-11-7-15</p>
<p><img src="/2021/08/25/20210825-redisScanExplain/6.png" alt="图片描述"></p>
<p>可以看出，当size由小变大时,所有原来的游标都能在大的hashTable中找到相应的位置,并且顺序一致,不会重复读取并且不会遗漏</p>
<p>例如size原来是4变为了8,且第二次遍历时rehash已经完成.此时游标为2,根据图2,我们知道size为4时的bucket2会rehash到size为8时的2和6.而size为4时的bucket0rehash到size为8时的0和4</p>
<p>由于bucket 0 已经遍历完,也即size为8时的0,4已经遍历,正好开始从2开始继续遍历,不重复也不会遗漏</p>
<p>继续考虑size由大变小的情况.假设size由16变为了4,分两种情况,一种是游标为0,2,1,3中的一种,此时继续读取,也不会遗漏和重复</p>
<p>但如果游标返回的不是这四种,例如返回了10,10&amp;11之后变为了2,所以会从2开始继续遍历.但由于size为16时的bucket2已经读取过,并且2,10,6,14都会rehash到size为4的bucket2,所以会造成重复读取</p>
<p>size为16时的bucket2。即有重复但不会遗漏</p>
<p><strong>总结一下:redis里边rehash从小到大时，scan系列命令不会重复也不会遗漏.而从大到小时,有可能会造成重复但不会遗漏.</strong></p>
<p>截止目前,情况1和情况2已经比较完美的处理了。情况3看看如何处理</p>
<p>情况3需要从ht[0]和ht[1]中都取出数据,主要的难点在于如何在size大的哈希表中找到应该取哪些bucket.redis代码如下:</p>
<p><img src="/2021/08/25/20210825-redisScanExplain/7.png" alt="图片描述"><br>判断条件为:</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">v<span class="meta">&amp;(m0^m1)</span></span><br></pre></td></tr></table></figure>

<p>size 4的m0为00000011,size8的m1为00000111,二者异或之后取值为00000100,即取二者mask高位的值,然后&amp;v,看游标是否在高位还有值</p>
<p>下一个游标的取值方法为</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">v = <span class="comment">(  ((v | m0)</span> <span class="number">+1</span>)&amp; ~<span class="name">m0</span>) | <span class="comment">( v &amp; m0)</span></span><br></pre></td></tr></table></figure>

<p>右半部分 取v的低位,左半部分取v的高位。 （v&amp;m0)取出v的低位 例如size = 4时为 v&amp;00000011</p>
<p>左半部分 （v|m0) + 1即将v的低位都置为1,然后+1之后会进位到v的高位,再次 &amp; ~m0之后即取出了v的高位</p>
<p>整体来看每次将游标v的高位加1.下边举例来看:</p>
<p>假设游标返回了2,并且正在进行rehash,此时size由4变成了8 .则m0 = 00000011 v = 00000010</p>
<p>根据公式计算出的下一个游标为 ( (( 00000010|00000011) +1 ) &amp; (11111100) )| (00000010 &amp; 00000011) = (00000100)&amp;(11111100)|(00000010) = (00000110) 正好是6</p>
<p>判断条件为 (00000010) &amp; (00000011 ^ 00000111) = (00000010) &amp; (00000100) = (00000000) 为0，结束循环</p>
<p><img src="/2021/08/25/20210825-redisScanExplain/6.jpg" alt></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis中的渐进式Rehash</title>
    <url>/2021/08/24/20210824-redisRehash/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>如果你有一个hash表，然后不停的往里面写值或者删值，随着操作的不断执行， 哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的负载因子（load factor）维持在一个合理的范围之内， 当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩。这个过程就叫做rehash，而在redis中这个rehash的过程又叫做渐进式rehash。</p>
<h2 id="Rehash原理"><a href="#Rehash原理" class="headerlink" title="Rehash原理"></a>Rehash原理</h2><p>扩展和收缩哈希表的工作可以通过执行 rehash （重新散列）操作来完成， Redis 对字典的哈希表执行 rehash 的步骤如下：</p>
<ol>
<li>为字典的<strong>ht[1]</strong>哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及<strong>ht[0]</strong>当前包含的键值对数量 （也即是ht[0].used属性的值）：<ul>
<li>如果执行的是扩展操作， 那么 <code>ht[1]</code> 的大小为第一个大于等于 <code>ht[0].used * 2</code> 的 2^n （<code>2</code> 的 <code>n</code> 次方幂），也就是说每次扩容后的大小一定是2^n，因为只有2^n -1的二进制每一位都为1；</li>
<li>如果执行的是收缩操作， 那么 <code>ht[1]</code> 的大小为第一个大于等于 <code>ht[0].used</code> 的 2^n 。</li>
</ul>
</li>
<li>将保存在 <code>ht[0]</code> 中的所有键值对 rehash 到 <code>ht[1]</code> 上面： rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 <code>ht[1]</code>哈希表的指定位置上。</li>
<li>当 <code>ht[0]</code> 包含的所有键值对都迁移到了 <code>ht[1]</code> 之后 （<code>ht[0]</code> 变为空表）， 释放 <code>ht[0]</code> ， 将 <code>ht[1]</code> 设置为 <code>ht[0]</code> ， 并在 <code>ht[1]</code> 新创建一个空白哈希表， 为下一次 rehash 做准备。</li>
</ol>
<p>举个例子， 假设程序要对图 1 所示字典的 <code>ht[0]</code> 进行扩展操作， 那么程序将执行以下步骤：</p>
<ol>
<li><code>ht[0].used</code> 当前的值为 <code>4</code> ， <code>4 * 2 = 8</code> ， 而 <code>8</code> （2^3）恰好是第一个大于等于 <code>4</code> 的 <code>2</code> 的 <code>n</code> 次方， 所以程序会将 <code>ht[1]</code> 哈希表的大小设置为 <code>8</code> 。 图 2 展示了 <code>ht[1]</code> 在分配空间之后， 字典的样子。</li>
<li>将 <code>ht[0]</code> 包含的四个键值对都 rehash 到 <code>ht[1]</code> ， 如图 3 所示。</li>
<li>释放 <code>ht[0]</code> ，并将 <code>ht[1]</code> 设置为 <code>ht[0]</code> ，然后为 <code>ht[1]</code> 分配一个空白哈希表，如图 4 所示。</li>
</ol>
<p>至此， 对哈希表的扩展操作执行完毕， 程序成功将哈希表的大小从原来的 <code>4</code> 改为了现在的 <code>8</code> 。</p>
<h2 id="Rehash图示"><a href="#Rehash图示" class="headerlink" title="Rehash图示"></a><strong>Rehash图示</strong></h2><p><img src="/2021/08/24/20210824-redisRehash/1.png" alt="图1"></p>
<center>图1 执行rehash之前</center>

<p><img src="/2021/08/24/20210824-redisRehash/2.png" alt="图2"></p>
<center>图2 为字典的ht[1]哈希表分配空间</center>

<p><img src="/2021/08/24/20210824-redisRehash/3.png" alt="图3"></p>
<center>图3 ht[0]的所有值对都已经被迁移到ht[1]</center>

<p><img src="/2021/08/24/20210824-redisRehash/4.png" alt="图4"></p>
<center>图4 完成rehash之后的字典</center>

<h2 id="哈希表的扩展与收缩"><a href="#哈希表的扩展与收缩" class="headerlink" title="哈希表的扩展与收缩"></a><strong>哈希表的扩展与收缩</strong></h2><p>当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：</p>
<ol>
<li>服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 <code>1</code> ；</li>
<li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 <code>5</code> ；</li>
</ol>
<p>其中哈希表的负载因子可以通过公式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 负载因子 = 哈希表已保存节点数量 / 哈希表大小</span><br><span class="line">load_factor = ht[0].used / ht[0].size</span><br></pre></td></tr></table></figure>

<p>计算得出。</p>
<p>比如说， 对于一个大小为 <code>4</code> ， 包含 <code>4</code> 个键值对的哈希表来说， 这个哈希表的负载因子为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">load_factor = 4 / 4 = 1</span><br></pre></td></tr></table></figure>

<p>又比如说， 对于一个大小为 <code>512</code> ， 包含 <code>256</code> 个键值对的哈希表来说， 这个哈希表的负载因子为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">load_factor = 256 / 512 = 0.5</span><br></pre></td></tr></table></figure>

<p>根据 BGSAVE 命令或 BGREWRITEAOF 命令是否正在执行， 服务器执行扩展操作所需的负载因子并不相同， 这是因为在执行 BGSAVE命令或 BGREWRITEAOF 命令的过程中， Redis 需要创建当前服务器进程的子进程， 而大多数操作系统都采用写时复制copy-on-write技术来优化子进程的使用效率， 所以在子进程存在期间， 服务器会提高执行扩展操作所需的负载因子， 从而尽可能地避免在子进程存在期间进行哈希表扩展操作， 这可以避免不必要的内存写入操作， 最大限度地节约内存。</p>
<p>另一方面， 当哈希表的负载因子小于 <code>0.1</code> 时， 程序自动开始对哈希表执行收缩操作。</p>
<h2 id="渐进式Rehash"><a href="#渐进式Rehash" class="headerlink" title="渐进式Rehash"></a><strong>渐进式Rehash</strong></h2><p>上面说过， 扩展或收缩哈希表需要将 <code>ht[0]</code> 里面的所有键值对 rehash 到 <code>ht[1]</code> 里面， 但是， 这个 rehash 动作<strong>并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的</strong>。</p>
<p>这样做的原因在于， 如果 <code>ht[0]</code> 里只保存着四个键值对， 那么服务器可以在瞬间就将这些键值对全部 rehash 到 <code>ht[1]</code> ； 但是， 如果哈希表里保存的键值对数量不是四个， 而是四百万、四千万甚至四亿个键值对， 那么要一次性将这些键值对全部 rehash 到 <code>ht[1]</code> 的话， 庞大的计算量可能会导致服务器在一段时间内停止服务。</p>
<p>因此， 为了避免 rehash 对服务器性能造成影响， 服务器不是一次性将 <code>ht[0]</code> 里面的所有键值对全部 rehash 到 <code>ht[1]</code> ， 而是分多次、渐进式地将 <code>ht[0]</code> 里面的键值对慢慢地 rehash 到 <code>ht[1]</code> 。</p>
<p>以下是哈希表渐进式 rehash 的详细步骤：</p>
<ol>
<li>为 <code>ht[1]</code> 分配空间， 让字典同时持有 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表。</li>
<li>在字典中维持一个索引计数器变量 <code>rehashidx</code> ， 并将它的值设置为 <code>0</code> ， 表示 rehash 工作正式开始。</li>
<li>在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 <code>ht[0]</code> 哈希表在 <code>rehashidx</code> 索引上的所有键值对 rehash 到 <code>ht[1]</code> ， 当 rehash 工作完成之后， 程序将 <code>rehashidx</code> 属性的值增一。</li>
<li>随着字典操作的不断执行， 最终在某个时间点上， <code>ht[0]</code> 的所有键值对都会被 rehash 至 <code>ht[1]</code> ， 这时程序将 <code>rehashidx</code> 属性的值设为 <code>-1</code> ， 表示 rehash 操作已完成。</li>
</ol>
<p>渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。</p>
<p>图 5 至图 10 展示了一次完整的渐进式 rehash 过程， 注意观察在整个 rehash 过程中， 字典的 <code>rehashidx</code> 属性是如何变化的。</p>
<h2 id="渐进式Rehash图示"><a href="#渐进式Rehash图示" class="headerlink" title="渐进式Rehash图示"></a><strong>渐进式Rehash图示</strong></h2><p><img src="/2021/08/24/20210824-redisRehash/5.png" alt="图1"></p>
<center>图5 准备开始rehash</center>

<p><img src="/2021/08/24/20210824-redisRehash/6.png" alt="图1"></p>
<center>图6 rehash索引0上的key value</center>

<p><img src="/2021/08/24/20210824-redisRehash/7.png" alt="图1"></p>
<center>图7 rehash索引1上的key value</center>

<p><img src="/2021/08/24/20210824-redisRehash/8.png" alt="图1"></p>
<center>图8 rehash索引2上的key value</center>

<p><img src="/2021/08/24/20210824-redisRehash/9.png" alt="图1"></p>
<center>图9 rehash索引3上的key value</center>

<p><img src="/2021/08/24/20210824-redisRehash/10.png" alt="图1"></p>
<center>图10 rehash完成</center>



<h2 id="渐进式-rehash-执行期间的哈希表操作"><a href="#渐进式-rehash-执行期间的哈希表操作" class="headerlink" title="渐进式 rehash 执行期间的哈希表操作"></a><strong>渐进式 rehash 执行期间的哈希表操作</strong></h2><p>因为在进行渐进式 rehash 的过程中， 字典会同时使用 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 <code>ht[0]</code>里面进行查找， 如果没找到的话， 就会继续到 <code>ht[1]</code> 里面进行查找， 诸如此类。</p>
<p>另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 <code>ht[1]</code> 里面， 而 <code>ht[0]</code> 则不再进行任何添加操作： 这一措施保证了 <code>ht[0]</code> 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。<strong>这里提前透漏一句，就是这个渐进式rehash的缩容操作导致了scan命令的重复值出现。</strong>下一篇会详细讨论一下。</p>
<p><img src="/2021/08/24/20210824-redisRehash/6.jpg" alt></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>获取Redis中同一前缀key踩坑记录</title>
    <url>/2021/08/19/20210819-redisScan/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>之前有一个订单购买后用户生效保护期的需求，根据当时的需求本人是将key设置好自定义前缀规则，并设置了过期时间然后统一放在了redis上面，后来需求变动，所有的保护期过期之后需要留档处理，这时候就需要把之前设置的同一前缀的保护期数据在过期之前全部转移到数据库留档，就需要将之前设置的所有保护期相关数据全部获取出来。这时的kv大概已经有了300w条左右了。</p>
<p>这里就有两个方案了keys * 和 scan</p>
<p>keys *这个虽然可以实现目的但是最好还是不要使用，因为如果线上数据过大，就会导致单线程的redis阻塞，长时间无法处理后续请求，然后你就等着被捶吧。</p>
<p>scan可以理解是keys <em>的分批次执行，简单来说就是会有一个游标记录一次扫描的结束位置，然后拿着这个游标作为下一次扫描的起始位置，反复执行，每次执行数据量不大而且每次执行时间也足够短，直到扫描完整个redis库，全程不会造成redis的无响应状况，但是需要声明一点，*</em>这个scan操作是会出现重复key值的<strong>，所以需要业务侧做好去重处理哈。本文的重点！</strong>为什么说这个scan会出现重复值，又为什么这个scan是不会漏值的？**下面就来说说本人的理解。</p>
<h2 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h2><p>下面是本人在项目中的一些用法,代码实现功能就是将自己需要的一些kv值遍历出来放进mysql进行存储，由于线上数据量较大，整个过程大约持续了30分钟，但是redis服务全程无异常状况，完美达到目的。</p>
<h3 id="核心代码示例"><a href="#核心代码示例" class="headerlink" title="核心代码示例"></a>核心代码示例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rcnn := redis.Connection()</span><br><span class="line">begin := time.Now().Unix()</span><br><span class="line">firstStrs, cursor := rcnn.Scan(<span class="number">0</span>, <span class="string">"xxxxx_service_xxxxx*"</span>, <span class="number">1000</span>).Val()</span><br><span class="line">fmt.Println(time.Now().Unix() - begin)</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> firstStrs &#123;</span><br><span class="line">    key := value</span><br><span class="line">    keyValue := rcnn.Get(key).Val()</span><br><span class="line">    ttlSeconds := <span class="keyword">int64</span>(rcnn.TTL(key).Val().Seconds())</span><br><span class="line">    tnow := time.Now().Unix()</span><br><span class="line">    memberId, _ := strconv.Atoi((strings.Split(key, <span class="string">"&amp;"</span>)[<span class="number">1</span>]))</span><br><span class="line">    orderId := strings.Split(keyValue, <span class="string">"&amp;"</span>)[<span class="number">0</span>]</span><br><span class="line">    pPeriod := &amp;protectperiod.ProtectPeriod&#123;</span><br><span class="line">        MemberId:  <span class="keyword">int64</span>(memberId),</span><br><span class="line">        OrderId:   orderId,</span><br><span class="line">        Content:   keyValue,</span><br><span class="line">        CreatedAt: tnow + ttlSeconds - <span class="number">3628800</span>,</span><br><span class="line">        ExpiredAt: tnow + ttlSeconds,</span><br><span class="line">        Status:    <span class="string">"0"</span>,</span><br><span class="line">        Source:    <span class="string">"redis"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    cErr := pPeriod.CreateNewRecord()</span><br><span class="line">    <span class="keyword">if</span> cErr != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(cErr)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> cursor != <span class="number">0</span> &#123;</span><br><span class="line">    cbegin := time.Now().Unix()</span><br><span class="line">    strs, nextCursor := rcnn.Scan(cursor, <span class="string">"xxxxx_service_xxxxx*"</span>, <span class="number">1000</span>).Val()</span><br><span class="line">    fmt.Println(time.Now().Unix() - cbegin)</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> strs &#123;</span><br><span class="line">        key := value</span><br><span class="line">        keyValue := rcnn.Get(key).Val()</span><br><span class="line">        ttlSeconds := <span class="keyword">int64</span>(rcnn.TTL(key).Val().Seconds())</span><br><span class="line">        tnow := time.Now().Unix()</span><br><span class="line">        memberId, _ := strconv.Atoi((strings.Split(key, <span class="string">"&amp;"</span>)[<span class="number">1</span>]))</span><br><span class="line">        orderId := strings.Split(keyValue, <span class="string">"&amp;"</span>)[<span class="number">0</span>]</span><br><span class="line">        pPeriod := &amp;protectperiod.ProtectPeriod&#123;</span><br><span class="line">            MemberId:  <span class="keyword">int64</span>(memberId),</span><br><span class="line">            OrderId:   orderId,</span><br><span class="line">            Content:   keyValue,</span><br><span class="line">            CreatedAt: tnow + ttlSeconds - <span class="number">3628800</span>,</span><br><span class="line">            ExpiredAt: tnow + ttlSeconds,</span><br><span class="line">            Status:    <span class="string">"0"</span>,</span><br><span class="line">            Source:    <span class="string">"redis"</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        cErr := pPeriod.CreateNewRecord()</span><br><span class="line">        <span class="keyword">if</span> cErr != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(cErr)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cursor = nextCursor</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"all Done"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h2><p>好了，在前言中有说到<strong>为什么说这个scan会出现重复值，又为什么这个scan是安全不会漏值的？</strong> 在讨论这个问题之前，我们需要先了解什么是Rehash，学过java的都知道hashmap，当hashmap中的槽不够用的时候就会在每一个槽产生过长的链表导致效率低下等问题，在hash冲突严重的时候，hashmap就会进行扩容，然后把原来的kv值转移到新的扩容的好hashmap中去，这个过程其实就是rehash。其实在redis中这一过程准确点的叫法是渐进式rehash，点此处了解什么是<a href="https://stevenhoukai.github.io/2021/08/24/20210824-redisRehash/"><strong>渐进式rehash</strong></a>, 了解完上述概念之后，我们现在再来看看<a href="https://stevenhoukai.github.io/2021/08/25/20210825-redisScanExplain/"><strong>scan命令为什么是安全不漏值而且可能会出现重复值</strong></a>的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>如果遇到线上redis需要获取大批量的kv值，用scan不会错。切记客户端一定要做好去重处理！！！</p>
<p><img src="/2021/08/19/20210819-redisScan/6.jpg" alt></p>
]]></content>
      <categories>
        <category>golang踩坑记录</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang的for循环踩坑</title>
    <url>/2021/08/16/20210816-gapGolangFor/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>最近写项目用了太多的for循环，殊不知这么简单的一个操作竟然踩出大坑，记录一波！</p>
<h2 id="for循环使用"><a href="#for循环使用" class="headerlink" title="for循环使用"></a>for循环使用</h2><p>下面来看一下项目中的一些用法</p>
<h3 id="实例踩坑效果"><a href="#实例踩坑效果" class="headerlink" title="实例踩坑效果"></a>实例踩坑效果</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	newArr := []*<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		newArr = <span class="built_in">append</span>(newArr, &amp;v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> newArr &#123;</span><br><span class="line">		fmt.Println(*v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>看到这个结果的时候我其实是一脸懵逼的，这个问题起初我一个java程序员真是无法理解，后来直到我运行了如下的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	newArr := []*<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		fmt.Println(<span class="string">""</span>)</span><br><span class="line">		fmt.Printf(<span class="string">"origin addr: %p value: %v"</span>, &amp;v, v)</span><br><span class="line">		newArr = <span class="built_in">append</span>(newArr, &amp;v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> newArr &#123;</span><br><span class="line">		fmt.Println(<span class="string">""</span>)</span><br><span class="line">		fmt.Printf(<span class="string">"addr: %p  value: %v"</span>, s, *s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">origin addr: <span class="number">0xc0000a67a8</span> value: <span class="number">1</span></span><br><span class="line">origin addr: <span class="number">0xc0000a67a8</span> value: <span class="number">2</span></span><br><span class="line">origin addr: <span class="number">0xc0000a67a8</span> value: <span class="number">3</span></span><br><span class="line">addr: <span class="number">0xc0000a67a8</span>  value: <span class="number">3</span></span><br><span class="line">addr: <span class="number">0xc0000a67a8</span>  value: <span class="number">3</span></span><br><span class="line">addr: <span class="number">0xc0000a67a8</span>  value: <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>总结就是golang的for循环是通过同一个地址槽来反复接值的！！！</p>
<p><img src="/2021/08/16/20210816-gapGolangFor/6.jpg" alt></p>
]]></content>
      <categories>
        <category>golang踩坑记录</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>count(1)、count(*)、count(列)有什么区别？</title>
    <url>/2021/08/12/20210812-explainCount/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>不知不觉入职tencent已经半年了，期间一直都在忙着适应golang还有新的业务新的微服务框架，从java转到golang有所适有所不适吧，但总体来说问题不大，所以就很久没有更新了，但是没关系，工作中遇到的问题小弟我都有一一记录，后面全部补上。今天主要来对sql统计中的count进行一下总结。</p>
<h2 id="count-1-and-count"><a href="#count-1-and-count" class="headerlink" title="count(1) and count(*)"></a><strong>count(1) and count(*)</strong></h2><p>当表的数据量大些时，对表作分析之后，使用count(1)还要比使用count(*)用时多了！ </p>
<p>从执行计划来看，count(1)和count(<em>)的效果是一样的。但是在表做过分析之后，count(1)会比count(</em>)的用时少些（1w以内数据量），不过差不了多少。 </p>
<p>如果count(1)是聚索引,id,那肯定是count(1)快。但是差的很小的。 </p>
<p>因为count(<em>),自动会优化指定到那一个字段。所以没必要去count(1)，用count(</em>)，sql会帮你完成优化的 因此：count(1)和count(*)基本没有差别！</p>
<h2 id="count-1-and-count-字段"><a href="#count-1-and-count-字段" class="headerlink" title="count(1) and count(字段)"></a><strong>count(1) and count(字段)</strong></h2><p>两者的主要区别是</p>
<ol>
<li>count(1) 会统计表中的所有的记录数，包含字段为null 的记录。</li>
<li>count(字段) 会统计该字段在表中出现的次数，忽略字段为null 的情况。即不统计字段为null 的记录。 </li>
</ol>
<p><strong>count(*) 和 count(1)和count(列名)区别</strong> </p>
<p>执行效果上： </p>
<ul>
<li>count(<em>)包括了所有的列，相当于行数，在统计结果的时候，*</em>不会忽略列值为NULL** </li>
<li>count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，<strong>不会忽略列值为NULL</strong> </li>
<li>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，<strong>即某个字段值为NULL时，不统计</strong>。</li>
</ul>
<p>执行效率上： </p>
<ul>
<li>列名为主键，count(列名)会比count(1)快 </li>
<li>列名不为主键，count(1)会比count(列名)快 </li>
<li>如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*） </li>
<li>如果有主键，则 select count（主键）的执行效率是最优的 </li>
<li>如果表只有一个字段，则 select count（*）最优。</li>
</ul>
<h3 id="实例查看效果"><a href="#实例查看效果" class="headerlink" title="实例查看效果"></a>实例查看效果</h3><p>下面来看看一个列子吧</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table counttest(name char(<span class="number">1</span>), age char(<span class="number">2</span>));</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.03</span> sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; insert into counttest values -&gt; (<span class="string">'a'</span>, <span class="string">'14'</span>),(<span class="string">'a'</span>, <span class="string">'15'</span>), (<span class="string">'a'</span>, <span class="string">'15'</span>), -&gt; (<span class="string">'b'</span>, NULL), (<span class="string">'b'</span>, <span class="string">'16'</span>), -&gt; (<span class="string">'c'</span>, <span class="string">'17'</span>), -&gt; (<span class="string">'d'</span>, null), -&gt;(<span class="string">'e'</span>, <span class="string">'');</span></span><br><span class="line"><span class="string">Query OK, 8 rows affected (0.01 sec)</span></span><br><span class="line"><span class="string">Records: 8  Duplicates: 0  Warnings: 0</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">mysql&gt; select * from counttest;</span></span><br><span class="line"><span class="string">+------+------+</span></span><br><span class="line"><span class="string">| name | age  |</span></span><br><span class="line"><span class="string">+------+------+</span></span><br><span class="line"><span class="string">| a | 14   |</span></span><br><span class="line"><span class="string">| a | 15   |</span></span><br><span class="line"><span class="string">| a | 15   |</span></span><br><span class="line"><span class="string">| b | NULL |</span></span><br><span class="line"><span class="string">| b | 16   |</span></span><br><span class="line"><span class="string">| c | 17   |</span></span><br><span class="line"><span class="string">| d | NULL |</span></span><br><span class="line"><span class="string">| e | |</span></span><br><span class="line"><span class="string">+------+------+</span></span><br><span class="line"><span class="string">8 rows in set (0.00 sec)</span></span><br><span class="line"><span class="string">mysql&gt; select name, count(name), count(1), count(*), count(age), count(distinct(age)) -&gt; from counttest -&gt; group by name;</span></span><br><span class="line"><span class="string">+------+-------------+----------+----------+------------+----------------------+</span></span><br><span class="line"><span class="string">| name | count(name) | count(1) | count(*) | count(age) | count(distinct(age)) |</span></span><br><span class="line"><span class="string">+------+-------------+----------+----------+------------+----------------------+</span></span><br><span class="line"><span class="string">| a | 3 | 3 | 3 | 3 | 2 |</span></span><br><span class="line"><span class="string">| b | 2 | 2 | 2 | 1 | 1 |</span></span><br><span class="line"><span class="string">| c | 1 | 1 | 1 | 1 | 1 |</span></span><br><span class="line"><span class="string">| d | 1 | 1 | 1 | 0 | 0 |</span></span><br><span class="line"><span class="string">| e | 1 | 1 | 1 | 1 | 1 |</span></span><br><span class="line"><span class="string">+------+-------------+----------+----------+------------+----------------------+</span></span><br><span class="line"><span class="string">5 rows in set (0.00 sec)</span></span><br></pre></td></tr></table></figure>

<p>好记性不如烂笔头哈～</p>
<p><img src="/2021/08/12/20210812-explainCount/6.jpg" alt></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>goroutine与线程的关系</title>
    <url>/2020/12/29/20201229-goroutine2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>学到这里，我们需要了解一下OS线程一般都是有属于自己的线程栈内存（通常为2MB）。一个goroutine栈在刚启动的时候确实很小的（通常是2KB），所以一次性创建10w个goroutine也是没有问题的，随着运行goroutine栈最大可达到1GB。goroutine属于用户态线程，go语言在runtime层面通过实现了一个GPM机制来对goroutine进行调度。</p>
<h2 id="goroutine的调度机制"><a href="#goroutine的调度机制" class="headerlink" title="goroutine的调度机制"></a><strong>goroutine的调度</strong>机制</h2><p>首先来大致解释下什么是GPM</p>
<p><strong>G：就是goroutine，包含goroutine信息以及与所在P的绑定等信息</strong></p>
<p><strong>P：管理着一组goroutine的队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址以及地址边界），P内部对自己管理的一些列G进行调度，当自己管理的队列消费完了还会去全局队列中取，如果全局队列也消费完了还会去其他的P中取任务</strong></p>
<p><strong>M：是Golang中对os内核线程的抽象，M与内核线程一般就是11对应的关系，goroutine最终都是会在M上进行执行的</strong></p>
<p>我们来稍微理解一下这个GPM模型，本人会觉得与java中的线程池模型还是很相似的，只是本人研究的java线程池中并无全局队列以及去其他队列抢任务的概念出现，了解j<strong><a href="https://www.baidu.com" target="_blank" rel="noopener">JAVA中线程池工作原理</a></strong>戳这里。在GPM中，P和M通常也是11对应的，但这并不是绝对的，可以这么通俗的来理解一个队列P对应一个os线程M，os线程由操作系统cpu运行，然后P来对队列中的任务goroutine进行调度，让每一个goroutine在os线程上不停的来回切换运行（准确一点的表达：P管理着一组G挂载在M上运行，当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G挂载在新建的M上去。当旧的G阻塞完成或者认为其已经死掉时那么就会回收旧的M）。</p>
<h2 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="GOMAXPROCS"></a><strong>GOMAXPROCS</strong></h2><p>​    在前言中我们说了G的内存大小以及创建数量等问题，那么P由这方面的限制吗？P的个数是通过runtime.GOMAXPROCS设定（最大256），Go1.5版本之后默认为物理线程数。在并发量大的时候会适当增加一些P和M，但是也不会太多，切换太频繁也没有太多必要。</p>
<h3 id="实例查看效果"><a href="#实例查看效果" class="headerlink" title="实例查看效果"></a>实例查看效果</h3><p>Go运行时的调度器使用<code>GOMAXPROCS</code>参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核cpu上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。</p>
<p>Go语言中可以通过<code>runtime.GOMAXPROCS()</code>函数设置当前程序并发时占用的CPU逻辑核心数。</p>
<p>Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。</p>
<p>我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，这里我们来举个例子看看。</p>
<h4 id="例1"><a href="#例1" class="headerlink" title="例1:"></a>例1:</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">"A:"</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">"B:"</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> a()</span><br><span class="line">	<span class="keyword">go</span> b()</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">modora#: <span class="keyword">go</span> run ./main.<span class="keyword">go</span></span><br><span class="line">B: <span class="number">1</span></span><br><span class="line">B: <span class="number">2</span></span><br><span class="line">B: <span class="number">3</span></span><br><span class="line">B: <span class="number">4</span></span><br><span class="line">B: <span class="number">5</span></span><br><span class="line">B: <span class="number">6</span></span><br><span class="line">B: <span class="number">7</span></span><br><span class="line">B: <span class="number">8</span></span><br><span class="line">B: <span class="number">9</span></span><br><span class="line">A: <span class="number">1</span></span><br><span class="line">A: <span class="number">2</span></span><br><span class="line">A: <span class="number">3</span></span><br><span class="line">A: <span class="number">4</span></span><br><span class="line">A: <span class="number">5</span></span><br><span class="line">A: <span class="number">6</span></span><br><span class="line">A: <span class="number">7</span></span><br><span class="line">A: <span class="number">8</span></span><br><span class="line">A: <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>上面例子中我们设置了runtime.GOMAXPROCS()为1，也就是说GPM模型中最多一个OS线程在运行，可以很明显的看到Agoroutine和Bgoroutine是串行打印，原因也很简单，两个goroutine在一个OS线程上进行调度的。下面我们将runtime.GOMAXPROCS()设置成2，两个goroutine在两个OS线程上进行调度，这里其实可以理解在OS线程层面并行。</p>
<h4 id="例2"><a href="#例2" class="headerlink" title="例2:"></a>例2:</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">"A:"</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">"B:"</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	runtime.GOMAXPROCS(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> a()</span><br><span class="line">	<span class="keyword">go</span> b()</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">执行结果：</span><br><span class="line">modora#: <span class="keyword">go</span> run ./main.<span class="keyword">go</span></span><br><span class="line">A: <span class="number">1</span></span><br><span class="line">A: <span class="number">2</span></span><br><span class="line">A: <span class="number">3</span></span><br><span class="line">A: <span class="number">4</span></span><br><span class="line">A: <span class="number">5</span></span><br><span class="line">A: <span class="number">6</span></span><br><span class="line">A: <span class="number">7</span></span><br><span class="line">A: <span class="number">8</span></span><br><span class="line">B: <span class="number">1</span></span><br><span class="line">B: <span class="number">2</span></span><br><span class="line">B: <span class="number">3</span></span><br><span class="line">B: <span class="number">4</span></span><br><span class="line">B: <span class="number">5</span></span><br><span class="line">B: <span class="number">6</span></span><br><span class="line">B: <span class="number">7</span></span><br><span class="line">B: <span class="number">8</span></span><br><span class="line">B: <span class="number">9</span></span><br><span class="line">A: <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>再次运行上述代码，发现AB变成了交替打印。各种意味自行理解哈～</p>
<p><img src="/2020/12/29/20201229-goroutine2/6.jpg" alt></p>
]]></content>
      <categories>
        <category>Golang并发编程</category>
      </categories>
      <tags>
        <tag>Go并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo迁移（Windows -> Mac）</title>
    <url>/2020/12/18/20201218-HexoTransferWindowsToMac/</url>
    <content><![CDATA[<h2 id="Hexo迁移（Windows-gt-Mac）"><a href="#Hexo迁移（Windows-gt-Mac）" class="headerlink" title="Hexo迁移（Windows -&gt; Mac）"></a>Hexo迁移（Windows -&gt; Mac）</h2><p>最近因工作需要换了台mac，需要将windows上面的hexo全数转移至新机，记录一下整个过程。</p>
<h3 id="1-找到自己Windows的hexo根目录"><a href="#1-找到自己Windows的hexo根目录" class="headerlink" title="1.找到自己Windows的hexo根目录"></a>1.找到自己Windows的hexo根目录</h3><h3 id="2-在-Mac-安装git和node-js"><a href="#2-在-Mac-安装git和node-js" class="headerlink" title="2.在 Mac 安装git和node.js"></a>2.在 Mac 安装git和node.js</h3><p>首先在自己电脑上装好node和git（首先确保brew安装好了） </p>
<p><code>brew install git</code></p>
<p><code>brew install node</code></p>
<h3 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3.安装hexo"></a>3.安装hexo</h3><p><em>用node.js来安装，这里可能会安装失败，我这里是切换npm源才成功</em></p>
<p><code>npm config set registry https://registry.npm.taobao.org</code></p>
<p><code>npm install -g hexo-cli</code> </p>
<h3 id="4-初始化hexo目录"><a href="#4-初始化hexo目录" class="headerlink" title="4.初始化hexo目录"></a><strong>4.初始化hexo目录</strong></h3><p>新建一个hexo目录，mkdir blog，cd blog</p>
<p><code>hexo init</code><br>在用<code>hexo s</code></p>
<p>测试是否成功，打开<code>localhost:4000</code>查看本地 </p>
<h3 id="5-生成SSH密钥，关联github"><a href="#5-生成SSH密钥，关联github" class="headerlink" title="5.生成SSH密钥，关联github"></a>5.生成SSH密钥，关联github</h3><p>先查看本地的SSH key: <code>cd ~/.ssh</code><br>(我是新买的mac，这一步需要直接先走安装）<br>$ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com" target="_blank" rel="noopener">youremail@example.com</a>“  后面那个是注册邮箱</p>
<p>进入.ssh文件夹： <code>cd ~/.ssh</code>，然后打开里面的 id_rsa.pub文件，里面的内容就是 SSH key，复制全部内容；</p>
<p>网页打开 github 的设置：Settings -&gt; SSH and GPG keys，点击绿色的按钮 New SSH key，然后在输入框中输入刚才复制的内容；</p>
<p>保存后，github 会向你的邮箱发送一个验证链接（记得要去登录邮箱验证，不然之后的 hexo d 部署会一直不成功的！）；</p>
<p>可以先测试一下是否成功：ssh <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>，<br>看到以下即成功：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; PTY allocation request failed on channel 0</span><br><span class="line">&gt; Hi gjincai! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br><span class="line">&gt; Connection to github.com closed.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="6-文件配置转移"><a href="#6-文件配置转移" class="headerlink" title="6.文件配置转移"></a>6.文件配置转移</h3><p>windows 下的博客根目录 hexo，复制该目录下的：<code>_config.yml</code>, <code>scaffolds</code>, <code>source</code>, <code>themes</code>；<br>mac 下的博客根目录 hexo，把刚才复制的内容，直接覆盖替换相同的文件文件夹。</p>
<h3 id="7-设置个人信息"><a href="#7-设置个人信息" class="headerlink" title="7.设置个人信息"></a>7.设置个人信息</h3><p><code>git config --global user.name &quot;yourname&quot;</code></p>
<p><code>git config --global user.email youremail@example.com</code></p>
<p>到这就好了，和往常一样hexo g   hexo d(或者直接hexo g -d)发布文章吧！结果会提示ERROR Deployer not found: git</p>
<p>安装以下再尝试：<code>npm install hexo-deployer-git --save（若提示有关权限不足的，加sudo，反正我是遇到了）</code></p>
<h3 id="8-最重要！！！！！！！"><a href="#8-最重要！！！！！！！" class="headerlink" title="8.最重要！！！！！！！"></a>8.最重要！！！！！！！</h3><p>以上是通常情况下的解决方案，本人遇到这个问题其实比较棘手并没有那么的顺利：本人旧机Window安装的node是v10.15.3，hexo版本是v3.9.0；要知道hexo最新版本已经是v5.2.0，跟旧版本相比有了很大的改动，比如主题安装，变化还是比较多的。所以最好是确定node版本在12或13或者以下版本，hexo版本最好也保持一致，否则会出现deploy d失败的情况，可以通过nvm安装多版本node解决即可</p>
<p><img src="/2020/12/18/20201218-HexoTransferWindowsToMac/6.jpg" alt></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>goroutine</title>
    <url>/2020/12/04/20201204-goroutine/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>之前学JAVA并发编程的时候，了解到了cpu内存模型、JMM、竞态资源、同步关键字synchronized、可见性以及指令重排关键字volatile再到后面的AQS源码等等。可以说JAVA的并发编程体系是非常完善的，但据说golang是天生就具备并发性能的语言，今天就来好好学习一下golang并发编程中的第一个重要概念goroutine。</p>
<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a><strong>并发与并行</strong></h2><p>相信学过并发编程的同学一定对这两个概念不陌生，我这里就只举两个非常简单形象的例子来描述一下：</p>
<p><strong>并发：假如你是一个渣男，某一天晚上你用微信轮流不停的和两个女朋友聊天</strong></p>
<p><strong>并行：你和你老弟都是好男人，某一天晚上你们都在用微信和自己女朋友聊天</strong></p>
<p>Java中通过Thread实现并发，GoLang中的并发则通过goroutine实现。goroutine类似于线程，属于用户态的线程，我们可以根据需要创建成千上万个goroutine并发工作。goroutine是由Golang的运行时调度完成的，而线程是由操作系统调度完成。</p>
<p>golang还提供channel在多个goroutine间进行通信。goroutine和channel是Go语言秉承的CSP(Communicating Sequential Process)并发模式的重要实现基础</p>
<h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a><strong>goroutine</strong></h2><p>在JAVA中要实现并发编程的时候，通常需要自己维护一个Threadpool，并且需要自己去包装一个又一个的任务(runnable or callable其实本质还是用户态Thread)往这个池子中丢任务，线程池根据自己的工作机制来运行这个任务或者阻塞这个任务又或者拒绝这个任务，今天我们不讨论JAVA线程池，有兴趣的朋友可以看我另外一篇文章，<strong><a href="https://www.baidu.com" target="_blank" rel="noopener">JAVA中线程池工作原理</a></strong>点这里查看。</p>
<p><code>goroutine</code>的概念类似于线程，但 <code>goroutine</code>是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。</p>
<p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能 –<code>goroutine</code>，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个<code>goroutine</code>去执行这个函数就可以了，就是这么简单粗暴。</p>
<h3 id="use-goroutine"><a href="#use-goroutine" class="headerlink" title="use goroutine"></a>use goroutine</h3><p>Go语言中使用<code>goroutine</code>非常简单，只需要在调用函数的时候在前面加上<code>go</code>关键字，就可以为一个函数创建一个<code>goroutine</code>。一个<code>goroutine</code>必定对应一个函数，可以创建多个<code>goroutine</code>去执行相同的函数。</p>
<h4 id="启动单个goroutine"><a href="#启动单个goroutine" class="headerlink" title="启动单个goroutine"></a>启动单个goroutine</h4><p>Golang中启动goroutine的方式非常简单，只需要在调用的函数（普通函数和匿名函数）前面加上一个<code>go</code>关键字。如下示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"Hello stephen!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	hello()</span><br><span class="line">	fmt.Println(<span class="string">"main stephen over!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例中hello函数和下面的语句是串行的，执行的结果是打印完<code>Hello stephen!</code>后打印<code>main stephen done!</code>。</p>
<p>下面我们在调用hello函数前面加上关键字<code>go</code>，也就是启动一个goroutine去执行hello这个函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> hello() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">	fmt.Println(<span class="string">"main stephen done!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一次的执行结果只打印了<code>main stephen done!</code>，并没有打印<code>Hello stephen!</code>。为什么呢？在程序启动时，Go程序就会为<code>main()</code>函数创建第一个默认的<code>goroutine</code>，这个goroutine。当main()函数返回的时候该<code>goroutine</code>就结束了，所有在<code>main()</code>函数中启动的<code>goroutine</code>会一同结束，<code>main</code>函数所在的<code>goroutine</code>就像是打着降龙十八掌的乔峰，乔峰运功十八条龙(sub goroutines)在空气里穿梭，乔峰收工，十八条龙在空气中消失。这样好理解了吧。所以我们要想办法让main函数等一等hello函数，java中我们可以通过Thread.sleep()或者while(true)，而golang这里最简单粗暴的方式就是<code>time.Sleep</code>了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> hello() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">	fmt.Println(<span class="string">"main stephen done!"</span>)</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上面的代码你会发现，这一次先打印<code>main stephen done!</code>，然后紧接着打印<code>Hello stephen !</code>。这里会先打印<code>main stephen done!</code>是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的<code>goroutine</code>是继续执行的。</p>
<h4 id="启动多个goroutine-引出WaitGroup"><a href="#启动多个goroutine-引出WaitGroup" class="headerlink" title="启动多个goroutine(引出WaitGroup)"></a>启动多个goroutine(引出WaitGroup)</h4><p>了解到如何启动单个goroutine后，那么启动多个goroutine同理如下，同样我们需要main goroutine在一系列的sub goroutine执行完之前保持存活状态，这里就引入了一个新的概念WaitGroup，这个东西我在学习java并发编程的时也是有发现类似功能的组件的，比如AQS的直接产物CountDownLatch或者间接产物CyclicBarrier，原理也比较有趣，有兴趣了解其工作原理的<strong><a href="https://www.baidu.com" target="_blank" rel="noopener">戳这里</a></strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done() <span class="comment">// goroutine结束就登记-1</span></span><br><span class="line">	fmt.Println(<span class="string">"Hello stephen!"</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>) <span class="comment">// 启动一个goroutine就登记+1</span></span><br><span class="line">		<span class="keyword">go</span> hello(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait() <span class="comment">// 等待所有登记的goroutine都结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上述代码，你会发现执行的打印结果每一次都是不一样的，原因也很简单，因为后台的goroutine的调度是随机的~，好了今天我们初步的了解了goroutine的一些基本概念和基本用法，下一篇来详细讨论一下GMP调度模型，学习一下goroutine调度背后的故事。</p>
<p><img src="/2020/12/04/20201204-goroutine/6.jpg" alt></p>
]]></content>
      <categories>
        <category>Golang并发编程</category>
      </categories>
      <tags>
        <tag>Go并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang练习二</title>
    <url>/2020/11/28/20201128-golangprectice2/</url>
    <content><![CDATA[<p>学习Golang的过程中，练习必不可少，俗话说的好 Talk is cheap,show me the code，学完Golang基本语法，是需要适当做一些练习加深理解的，虽然很很很简单！但是本人Java转go，语法还是要多熟悉，秉承多写一遍就多一次理解的原则，开始吧~</p>
<ul>
<li><h4 id="练习4"><a href="#练习4" class="headerlink" title="练习4"></a><strong>练习4</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//练习4</span><br><span class="line">  //打印9*9乘法口诀表</span><br><span class="line">  package main</span><br><span class="line">  </span><br><span class="line">  import &quot;fmt&quot;</span><br><span class="line">  </span><br><span class="line">  /*</span><br><span class="line">   * 练习4 打印乘法乘法口诀表</span><br><span class="line">   */</span><br><span class="line">  </span><br><span class="line">  func test4() &#123;</span><br><span class="line">  	for i := 1; i &lt;= 9; i++ &#123;</span><br><span class="line">  		for j := 1; j &lt;= 9; j++ &#123;</span><br><span class="line">  			if j &lt;= i &#123;</span><br><span class="line">  				fmt.Printf(&quot;%v * %v = %v &quot;, i, j, i*j)</span><br><span class="line">  			&#125;</span><br><span class="line">  		&#125;</span><br><span class="line">  		fmt.Printf(&quot;\n&quot;)</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  func main() &#123;</span><br><span class="line">  	test4()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><h4 id="练习5"><a href="#练习5" class="headerlink" title="练习5"></a><strong>练习5</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//练习5</span><br><span class="line">  //编写代码统计出字符串中每一个单词出现的次数</span><br><span class="line">  func test5() &#123;</span><br><span class="line">  	mymap := make(map[string]int)</span><br><span class="line">  	str := &quot;how do you do&quot;</span><br><span class="line">  	arr := strings.Split(str, &quot; &quot;)</span><br><span class="line">  	for _, v := range arr &#123;</span><br><span class="line">  		value, ok := mymap[v]</span><br><span class="line">  		if ok &#123;</span><br><span class="line">  			mymap[v] = value + 1</span><br><span class="line">  		&#125; else &#123;</span><br><span class="line">  			mymap[v] = 1</span><br><span class="line">  		&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	fmt.Println(mymap)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><h4 id="练习6"><a href="#练习6" class="headerlink" title="练习6"></a><strong>练习6</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func calc(index string, a, b int) int &#123;</span><br><span class="line">  	ret := a + b</span><br><span class="line">  	fmt.Println(index, a, b, ret)</span><br><span class="line">  	return ret</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  func main() &#123;</span><br><span class="line">  	x := 1</span><br><span class="line">  	y := 2</span><br><span class="line">  	defer calc(&quot;AA&quot;, x, calc(&quot;A&quot;, x, y))</span><br><span class="line">  	x = 10</span><br><span class="line">  	defer calc(&quot;BB&quot;, x, calc(&quot;B&quot;, x, y))</span><br><span class="line">  	y = 20</span><br><span class="line">  &#125;</span><br><span class="line">  //思考下输出结果？提示一下:</span><br><span class="line">  //defer注册要延迟执行的函数时该函数所有的参数都需要确定其值</span><br><span class="line">  //defer入栈出栈？</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><h4 id="练习7"><a href="#练习7" class="headerlink" title="练习7"></a><strong>练习7</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">  你有100枚金币，需要分配给以下几个人：Matthew,Sarah,Augustus,Heidi,Emilie,Peter,Giana,Adriano,Aaron,Elizabeth。</span><br><span class="line">  分配规则如下：</span><br><span class="line">  a. 名字中每包含1个&apos;e&apos;或&apos;E&apos;分1枚金币</span><br><span class="line">  b. 名字中每包含1个&apos;i&apos;或&apos;I&apos;分2枚金币</span><br><span class="line">  c. 名字中每包含1个&apos;o&apos;或&apos;O&apos;分3枚金币</span><br><span class="line">  d: 名字中每包含1个&apos;u&apos;或&apos;U&apos;分4枚金币</span><br><span class="line">  写一个程序，计算每个用户分到多少金币，以及最后剩余多少金币？</span><br><span class="line">  程序结构如下，请实现 ‘dispatchCoin’ 函数</span><br><span class="line">  */</span><br><span class="line">  var (</span><br><span class="line">  	coins = 100</span><br><span class="line">  	users = []string&#123;</span><br><span class="line">  		&quot;Matthew&quot;, &quot;Sarah&quot;, &quot;Augustus&quot;, &quot;Heidi&quot;, &quot;Emilie&quot;, &quot;Peter&quot;, &quot;Giana&quot;, &quot;Adriano&quot;, &quot;Aaron&quot;, &quot;Elizabeth&quot;,</span><br><span class="line">  	&#125;</span><br><span class="line">  	distribution = make(map[string]int, len(users))</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  func dispatchCoin() int &#123;</span><br><span class="line">  	for _, v := range users &#123;</span><br><span class="line">  		var count = 0</span><br><span class="line">  		for _, val := range v &#123;</span><br><span class="line">  			switch val &#123;</span><br><span class="line">  			case &apos;e&apos;:</span><br><span class="line">  				count++</span><br><span class="line">  			case &apos;E&apos;:</span><br><span class="line">  				count++</span><br><span class="line">  			case &apos;i&apos;:</span><br><span class="line">  				count = count + 2</span><br><span class="line">  			case &apos;I&apos;:</span><br><span class="line">  				count = count + 2</span><br><span class="line">  			case &apos;o&apos;:</span><br><span class="line">  				count = count + 3</span><br><span class="line">  			case &apos;O&apos;:</span><br><span class="line">  				count = count + 3</span><br><span class="line">  			case &apos;u&apos;:</span><br><span class="line">  				count = count + 4</span><br><span class="line">  			case &apos;U&apos;:</span><br><span class="line">  				count = count + 4</span><br><span class="line">  			&#125;</span><br><span class="line">  		&#125;</span><br><span class="line">  		distribution[v] = count</span><br><span class="line">  		coins = coins - count</span><br><span class="line">  	&#125;</span><br><span class="line">  	fmt.Println(distribution)</span><br><span class="line">  	return coins</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  func main() &#123;</span><br><span class="line">  	left := dispatchCoin()</span><br><span class="line">  	fmt.Println(&quot;剩下：&quot;, left)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>  Talk is cheap,show me the code~</p>
<p>  <img src="/2020/11/28/20201128-golangprectice2/1.jpeg" alt></p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang习题</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的遍历</title>
    <url>/2020/11/26/20201126-blbinarytree/</url>
    <content><![CDATA[<p>本文主要就二叉树的遍历方式进行总结和记录，从而了解递归、栈以及队列的应用，通常对于一个二叉树的遍历方式大致分为：</p>
<ol>
<li>前序遍历（中 -&gt; 左 -&gt; 右）</li>
<li>中序遍历（左 -&gt; 中 -&gt; 右）</li>
<li>后续遍历（左 -&gt; 右 -&gt; 中）</li>
<li>层次遍历</li>
</ol>
<ul>
<li><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a><strong>前序遍历</strong></h3><p>   <img src="/2020/11/26/20201126-blbinarytree/beforebl.png" alt></p>
<ul>
<li><h4 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a><strong>递归实现</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 思路：若二叉树非空：</span><br><span class="line"> * 1、访问根节点</span><br><span class="line"> * 2、遍历左子树</span><br><span class="line"> * 3、遍历右子数</span><br><span class="line"> */</span><br><span class="line"> public void PreOrder(Btree T)&#123;</span><br><span class="line">     if(T != null)&#123;</span><br><span class="line">         show(T)</span><br><span class="line">         PreOrder(T.left)</span><br><span class="line">         PreOrder(T.right)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>




</li>
</ul>
</li>
</ul>
<ul>
<li><h4 id="栈实现"><a href="#栈实现" class="headerlink" title="栈实现"></a><strong>栈实现</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 思路：若二叉树非空</span><br><span class="line"> * 1、根遍历，拿到一个节点的指针，先判断是否为空，不为空就先访问该结点，然后直接进栈，</span><br><span class="line"> * 2、接着遍历左子树；为空则要从栈中弹出一个节点来，这个时候弹出的结点就是其父亲</span><br><span class="line"> * 3、然后访问其父亲的右子树，直到当前节点为空且栈为空时，算法结束.</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"> public void PreOrder1(Btree T) &#123;</span><br><span class="line">        stack&lt;Btree&gt; st;</span><br><span class="line">        if (T == NULL)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        st.push(T);</span><br><span class="line">        while (!st.empty())&#123;</span><br><span class="line">            Btree T =st.pop();</span><br><span class="line">            show(T)</span><br><span class="line">            if (T.right!=NULL)</span><br><span class="line">                st.push(p.right);</span><br><span class="line">            if (p.left!=NULL)</span><br><span class="line">                st.push(p.left);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a><strong>中序遍历</strong></h3><p>   <img src="/2020/11/26/20201126-blbinarytree/middlebl.png" alt></p>
<ul>
<li><h4 id="递归实现-1"><a href="#递归实现-1" class="headerlink" title="递归实现"></a><strong>递归实现</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 思路：若二叉树非空：</span><br><span class="line"> * 1、遍历左子树</span><br><span class="line"> * 2、访问根节点</span><br><span class="line"> * 3、遍历右子数</span><br><span class="line"> */</span><br><span class="line"> public void MidOrder(Btree T)&#123;</span><br><span class="line">     if(T != null)&#123;</span><br><span class="line">         MidOrder(T.left)</span><br><span class="line">         show(T)</span><br><span class="line">         MidOrder(T.right)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>




</li>
</ul>
</li>
</ul>
<ul>
<li><h4 id="栈实现-1"><a href="#栈实现-1" class="headerlink" title="栈实现"></a><strong>栈实现</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 思路：借助栈</span><br><span class="line"> * 1、初始时依次扫描根节点的所在左侧节点并将它们一一进栈；</span><br><span class="line"> * 2、出栈一个节点，访问它</span><br><span class="line"> * 3、扫描该节点的右孩子节点并将其出栈</span><br><span class="line"> * 4、依次扫描右孩子节点的所有左侧节点并一一进栈</span><br><span class="line"> * 5、反复 2 - 4 步骤</span><br><span class="line"> */</span><br><span class="line">public void MidOrder2(Btree T)&#123;</span><br><span class="line">    Stack s = new Stack();</span><br><span class="line">    BTree p = T;</span><br><span class="line">    while(p||!s.IsEmpty())&#123;</span><br><span class="line">        if(p)&#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            p = s.pop();</span><br><span class="line">            show(p);</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</li>
</ul>
<ul>
<li><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a><strong>后序遍历</strong></h3><p>​    <img src="/2020/11/26/20201126-blbinarytree/afterbl.png" alt></p>
<ul>
<li><h4 id="递归实现-2"><a href="#递归实现-2" class="headerlink" title="递归实现"></a><strong>递归实现</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 思路：若二叉树非空：</span><br><span class="line"> * 1、遍历左子树</span><br><span class="line"> * 2、遍历右子数</span><br><span class="line"> * 3、访问根节点</span><br><span class="line"> */</span><br><span class="line"> public void PostOrder(Btree T)&#123;</span><br><span class="line">     if(T != null)&#123;</span><br><span class="line">         PostOrder(T.left)</span><br><span class="line">         PostOrder(T.right)</span><br><span class="line">         show(T)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>




</li>
</ul>
</li>
</ul>
<ul>
<li><h4 id="栈实现-2"><a href="#栈实现-2" class="headerlink" title="栈实现"></a><strong>栈实现</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 思路：借助栈</span><br><span class="line"> */</span><br><span class="line">public void AfterOrder2(Btree root)&#123;</span><br><span class="line">    if (root == NULL)&#123;</span><br><span class="line">       return;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;BTree&gt; s = new Stack();</span><br><span class="line">	s.push(root);//根指针入栈</span><br><span class="line">	while (!s.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		//重复将栈顶指针指向结点的左子树压栈,直到栈顶指针指向结点的左子树为空</span><br><span class="line">		while (s.top().left != NULL)&#123;</span><br><span class="line">			s.push(s.top().left);</span><br><span class="line">		&#125;</span><br><span class="line">		Btree last = NULL;//上一次遍历过的指针</span><br><span class="line">		//重复检查</span><br><span class="line">		while (!s.empty())&#123;</span><br><span class="line">			if (s.top().right==NULL||last==s.top().right) &#123;</span><br><span class="line">			//如果栈顶指针指向结点的右子树为空或者遍历过</span><br><span class="line">				show(s.top())</span><br><span class="line">				last = s.top();//更新指针last</span><br><span class="line">				s.pop();//栈顶指针出栈</span><br><span class="line">			&#125;</span><br><span class="line">			//如果栈顶指针指向的结点的右子树不为空</span><br><span class="line">			else if(s.top()-&gt;R!=NULL)&#123;</span><br><span class="line">					s.push(s.top()-&gt;R);//将右子树入栈</span><br><span class="line">					break;//退出检查</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</li>
</ul>
<ul>
<li><h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a><strong>层次遍历</strong></h3></li>
</ul>
<ul>
<li><h4 id="队列实现"><a href="#队列实现" class="headerlink" title="队列实现"></a><strong>队列实现</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 思路：借助队列 队列的就是FIFO</span><br><span class="line"> * 1、初始将根节点入队并访问根节点，然后出队</span><br><span class="line"> * 2、如果有左子树，将左子树的根入队</span><br><span class="line"> * 3、如果有右子树，将右子树的根入队</span><br><span class="line"> * 4、然后出队，访问该节点</span><br><span class="line"> * 5、反复出队访问直到队列为空</span><br><span class="line"> * 伪代码</span><br><span class="line"> */</span><br><span class="line">public void levelOrder(Btree T)&#123;</span><br><span class="line">    InitQueue(Q)</span><br><span class="line">    BTree p;</span><br><span class="line">    EnQueue(Q,T)</span><br><span class="line">    while(!IsEmpty(Q))&#123;</span><br><span class="line">        Dequeue(Q,p);</span><br><span class="line">        show(p);</span><br><span class="line">        if(p.left != null)&#123;</span><br><span class="line">            EnQueue(Q,p.left);</span><br><span class="line">        &#125;</span><br><span class="line">        if(p.right != null)&#123;</span><br><span class="line">            Enqueue(Q,p.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>二叉树是数据结构中非常重要的一环，弄懂其相关操作对于后续的学习也是十分重要，Java中的Treemap以及Hashmap中都有红黑树的引入，红黑树就是二叉树的一种特殊存在，通常我们也叫它黑高平衡树，后面再详细描述~</p>
<p><img src="/2020/11/26/20201126-blbinarytree/1.jpeg" alt></p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang练习一</title>
    <url>/2020/11/26/20201127-golangprectice1/</url>
    <content><![CDATA[<p>学习Golang的过程中，练习必不可少，俗话说的好 Talk is cheap,show me the code，学完Golang基本语法，是需要适当做一些练习加深理解的，虽然很很很简单！但是本人Java转go，语法还是要多熟悉，秉承多写一遍就多一次理解的原则，开始吧~</p>
<ul>
<li><h4 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a><strong>练习1</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//练习1</span><br><span class="line">  //编写代码分别定义一个整型、浮点型、布尔型、字符串型变量，使</span><br><span class="line">  //用fmt.Printf()搭配%T分别打印出上述变量的值和类型。</span><br><span class="line">  package main</span><br><span class="line">  </span><br><span class="line">  import (</span><br><span class="line">  	&quot;fmt&quot;</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  func test1() &#123;</span><br><span class="line">  	a := 10</span><br><span class="line">  	b := 1.0</span><br><span class="line">  	c := false</span><br><span class="line">  	d := &quot;哈哈哈&quot;</span><br><span class="line">  	fmt.Printf(&quot;a的类型为%T\n&quot;, a)</span><br><span class="line">  	fmt.Printf(&quot;b的类型为%T\n&quot;, b)</span><br><span class="line">  	fmt.Printf(&quot;c的类型为%T\n&quot;, c)</span><br><span class="line">  	fmt.Printf(&quot;d的类型为%T\n&quot;, d)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  func main() &#123;</span><br><span class="line">  	test1()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><h4 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a><strong>练习2</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//练习2</span><br><span class="line">  //编写代码统计出字符串&quot;hello沙河小王子&quot;中汉字的数量</span><br><span class="line">  package main</span><br><span class="line">  </span><br><span class="line">  import (</span><br><span class="line">  	&quot;fmt&quot;</span><br><span class="line">  	&quot;unicode&quot;</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  func test2() &#123;</span><br><span class="line">  	s := &quot;hello沙河小王子&quot;</span><br><span class="line">  	count := 0</span><br><span class="line">  	for _, c := range s &#123;</span><br><span class="line">  		if unicode.Is(unicode.Han, c) &#123;</span><br><span class="line">  			count = count + 1</span><br><span class="line">  		&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	fmt.Printf(&quot;字符串包含%v个中文&quot;, count)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  func main() &#123;</span><br><span class="line">  	test2()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><h4 id="练习3"><a href="#练习3" class="headerlink" title="练习3"></a><strong>练习3</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//练习3</span><br><span class="line">  //求数组[1, 3, 5, 7, 8]所有元素的和</span><br><span class="line">  package main</span><br><span class="line">  </span><br><span class="line">  import (</span><br><span class="line">  	&quot;fmt&quot;</span><br><span class="line">  	&quot;unicode&quot;</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  func test3() &#123;</span><br><span class="line">  	arr := [...]int&#123;1, 3, 5, 7, 9&#125;</span><br><span class="line">  	count := 0</span><br><span class="line">  	for _, v := range arr &#123;</span><br><span class="line">  		count = count + v</span><br><span class="line">  	&#125;</span><br><span class="line">  	fmt.Printf(&quot;result:%v&quot;, count)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  func main() &#123;</span><br><span class="line">  	test3()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><h4 id="练习4"><a href="#练习4" class="headerlink" title="练习4"></a><strong>练习4</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//练习4</span><br><span class="line">  //找出数组中和为指定值的两个元素的下标，</span><br><span class="line">  //比如从数组[1, 3, 5, 7, 8]中找出和为8的两个元素的下标分别为(0,3)和(1,2)。</span><br><span class="line">  package main</span><br><span class="line">  </span><br><span class="line">  import &quot;fmt&quot;</span><br><span class="line">  </span><br><span class="line">  func test4() (int, int) &#123;</span><br><span class="line">  	result := 8</span><br><span class="line">  	resultmap := make(map[int]int)</span><br><span class="line">  	arr := [...]int&#123;1, 3, 5, 7, 9&#125;</span><br><span class="line">  	for index, v := range arr &#123;</span><br><span class="line">  		gapv := result - v</span><br><span class="line">  		va, ok := resultmap[gapv]</span><br><span class="line">  		if ok &#123;</span><br><span class="line">  			return index, va</span><br><span class="line">  		&#125;</span><br><span class="line">  		resultmap[v] = index</span><br><span class="line">  	&#125;</span><br><span class="line">  	fmt.Println(resultmap)</span><br><span class="line">  	return 0, 0</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  func main() &#123;</span><br><span class="line">  	res1, res2 := test4()</span><br><span class="line">  	fmt.Printf(&quot;%v,%v&quot;, res1, res2)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>  Talk is cheap,show me the code~</p>
<p>  <img src="/2020/11/26/20201127-golangprectice1/1.jpeg" alt></p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang习题</tag>
      </tags>
  </entry>
  <entry>
    <title>如何实现一个带括号的四则混合运算表达式求值</title>
    <url>/2020/11/25/20201125-selfcomputer/</url>
    <content><![CDATA[<p>本题其实相对比较简单，只要了解如何利用stack将中缀表达式转为后缀表达式(去括号的过程)，然后对后缀表达式进行求值即可！这里不对stack的结构和原理进行讲解，可自行查阅相关数据，也比较简单。</p>
<ul>
<li><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//实现 (1+2)*4*(5+1)/2+3 求值</span><br><span class="line">public class ComputerReview &#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		Scanner sc = new Scanner(System.in);</span><br><span class="line">		String s = sc.nextLine();</span><br><span class="line">		//1去括号，中缀转后缀</span><br><span class="line">		ArrayList&lt;String&gt; backExpList = tansToBackExp(s);</span><br><span class="line">		//2后缀计算</span><br><span class="line">		int result = compute(backExpList);</span><br><span class="line">		System.out.println(result);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//这一步就是利用stack的特性将中缀表达式转换为后缀表达式同时去除掉括号的过程</span><br><span class="line">//实现方式有很多种，这里只是我的思路</span><br><span class="line">private static ArrayList tansToBackExp(String s) &#123;</span><br><span class="line">		ArrayList&lt;String&gt; al = new ArrayList();</span><br><span class="line">		Stack&lt;String&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">		for(int i = 0 ; i &lt; s.length() ; i++)&#123;</span><br><span class="line">			String c = s.charAt(i)+&quot;&quot;;</span><br><span class="line">			if(c.matches(&quot;\\d&quot;))&#123;</span><br><span class="line">				al.add(c);</span><br><span class="line">			&#125;else &#123;</span><br><span class="line">				if(c.equals(&quot;(&quot;))&#123;</span><br><span class="line">					stack.push(c);</span><br><span class="line">				&#125;else if(c.equals(&quot;+&quot;)||c.equals(&quot;-&quot;))&#123;</span><br><span class="line">					while(!stack.isEmpty())&#123;</span><br><span class="line">						if(stack.peek().equals(&quot;(&quot;))&#123;</span><br><span class="line">							break;</span><br><span class="line">						&#125;</span><br><span class="line">						al.add(stack.pop());</span><br><span class="line">					&#125;</span><br><span class="line">					stack.push(c);</span><br><span class="line">				&#125;else if(c.equals(&quot;*&quot;)||c.equals(&quot;/&quot;))&#123;</span><br><span class="line"></span><br><span class="line">					while(!stack.isEmpty())&#123;</span><br><span class="line">						if(stack.peek().equals(&quot; (&quot;)||stack.peek().equals(&quot;+&quot;)||stack.peek().equals(&quot;-&quot;))&#123;</span><br><span class="line">							break;</span><br><span class="line">						&#125;</span><br><span class="line">						if(c.equals(&quot;*&quot;)||c.equals(&quot;/&quot;))&#123;</span><br><span class="line">							al.add(stack.pop());</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					stack.push(c);</span><br><span class="line">				&#125;else &#123;</span><br><span class="line">					while(!stack.isEmpty())&#123;</span><br><span class="line">						if(!stack.peek().equals(&quot;(&quot;))&#123;</span><br><span class="line">							al.add(stack.pop());</span><br><span class="line">						&#125;else&#123;</span><br><span class="line">							//这一步很关键</span><br><span class="line">							stack.pop();</span><br><span class="line">							break;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		while(!stack.isEmpty())&#123;</span><br><span class="line">			al.add(stack.pop());</span><br><span class="line">		&#125;</span><br><span class="line">		return al;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//这一步相对来说就比较简单了，直接对转换后的后缀表达式求值，还是利用栈的特性</span><br><span class="line">//遍历后缀表达式，遇到数字就压栈处理，遇到表达式就出栈计算结果然后将结果再压栈，</span><br><span class="line">//最后栈中剩下的数字就是最终的结果</span><br><span class="line">private static Integer compute(ArrayList&lt;String&gt; al) &#123;</span><br><span class="line">		Stack&lt;String&gt; stack = new Stack&lt;String&gt;();</span><br><span class="line">		for(int i = 0 ; i &lt; al.size(); i++)&#123;</span><br><span class="line">			String s = al.get(i);</span><br><span class="line">			if(s.matches(&quot;\\d&quot;))&#123;</span><br><span class="line">				stack.push(s);</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			String str2 = stack.pop();</span><br><span class="line">			String str1 = stack.pop();</span><br><span class="line">			if(&quot;+&quot;.equals(s))&#123;</span><br><span class="line">				stack.push(Integer.parseInt(str1)+Integer.parseInt(str2)+&quot;&quot;);</span><br><span class="line">			&#125;else if(&quot;-&quot;.equals(s))&#123;</span><br><span class="line">				stack.push(Integer.parseInt(str1)-Integer.parseInt(str2)+&quot;&quot;);</span><br><span class="line">			&#125;else if(&quot;*&quot;.equals(s))&#123;</span><br><span class="line">				stack.push(Integer.parseInt(str1)*Integer.parseInt(str2)+&quot;&quot;);</span><br><span class="line">			&#125;else if(&quot;/&quot;.equals(s))&#123;</span><br><span class="line">				stack.push(Integer.parseInt(str1)/Integer.parseInt(str2)+&quot;&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return Integer.parseInt(stack.peek());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h6><p>栈是一个很重要的数据结构，FILO、LIFO的策略值得我们好好理解学习，jvm中的栈以及本地方法栈也都是采用了这样的数据结构</p>
<p><img src="/2020/11/25/20201125-selfcomputer/1.jpg" alt></p>
<p><img src="/2020/11/25/20201125-selfcomputer/5.jpeg" alt></p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>xx后台开发面试总结</title>
    <url>/2020/11/21/20201121-ms1%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="XX-后台开发工程师-接受Java转Go"><a href="#XX-后台开发工程师-接受Java转Go" class="headerlink" title="XX 后台开发工程师(接受Java转Go)"></a><strong>XX 后台开发工程师(接受Java转Go)</strong></h2><p>以下经历来源自个人好友谢晓峰</p>
<ul>
<li><h3 id="一面-技术leader面-50分钟（20201019）"><a href="#一面-技术leader面-50分钟（20201019）" class="headerlink" title="一面  技术leader面  50分钟（20201019）"></a>一面  技术leader面  50分钟（20201019）</h3></li>
</ul>
<ol>
<li><p>都是项目介绍，工作做了些啥 ？ </p>
</li>
<li><p>索引的实现原理，为什么要用b树实现索引 ？</p>
</li>
<li><p>数据库相关原理 bufferpool redolog undolog changebuffer等等执行一条insert语句，数据库擎层面是怎么做的 ？  </p>
</li>
<li><p>数据库主从原理 ？</p>
</li>
<li><p>redis集群原理 rediscluster  </p>
</li>
<li><p>redis主从原理 sentinel机制 ？</p>
</li>
<li><p>https原理是什么 ？</p>
</li>
<li><p>情景: 敏感词过滤  14w的敏感词要做么做 ？</p>
</li>
<li><p>网络安全相关 xss csrf sql注入等 ？</p>
</li>
<li><p>linux命令 wc如何使用问题 ？</p>
</li>
<li><p>消息队列的选型对比kafka rabbitmq rocketmq ？</p>
<p>只记得这么多问题了……</p>
</li>
</ol>
<p>​       面完后十分钟立刻通知二面，三少爷感觉回答问题都是游刃有余除了两个细节不太好， linux命令这块确实不熟悉，只是在知道命令层面，具体的参数写法都是需要baidu的那种，一般的top free df du iostat vmstat都是会的，也知道日志查看相关的命令，再细致点怎么统计就得靠度娘了。本次面试是xx会议语音面试</p>
<ul>
<li><h3 id="二面-总监面-50分钟-20201022"><a href="#二面-总监面-50分钟-20201022" class="headerlink" title="二面 总监面  50分钟(20201022)"></a>二面 总监面  50分钟(20201022)</h3></li>
</ul>
<ol>
<li>平时工作内容 最大挑战  ？</li>
<li>所在公司的职级  ？</li>
<li>年薪多少 ？</li>
<li>怎么学习，为什么要学习springcloud，讲讲springcloud的组件和核心原理  ？</li>
<li>这里工作强度等问题  ？</li>
<li>然后就是工作内容的询问等  ？</li>
</ol>
<p>​       本次面试是xx会议视频（我单方的视频是看不到面试官的）面试，这一点三少爷觉得并不太好，因为只有三少爷开了视频，嘿嘿，尽人事听天命吧，学习每天还是得继续的。</p>
<ul>
<li><h3 id="三面-HR经理面试-60分钟-20201027"><a href="#三面-HR经理面试-60分钟-20201027" class="headerlink" title="三面 HR经理面试 60分钟(20201027)"></a>三面 HR经理面试 60分钟(20201027)</h3></li>
</ul>
<p>​       最难的一个面试，大概就是谈价和谈职级吧，所以说大厂经验才是谈资，像三少爷这种传统企业去互联网的真真儿没有什么话语权，怎么说呢，其实就是行业的问题，技术本身并不矛盾，缺乏的是行业经验，比如你ERP经验对于互联网来说并无任何光环加成，反过来也一样，每一个行业都有很多精英，多向身边比你优秀的人多多学习吧。</p>
<ul>
<li><h3 id="四面-HR经理复面-20分钟-20201102"><a href="#四面-HR经理复面-20分钟-20201102" class="headerlink" title="四面 HR经理复面 20分钟(20201102)"></a>四面 HR经理复面 20分钟(20201102)</h3></li>
</ul>
<p>​       其实就是确定薪资和职级以及公司福利的介绍等等，基本就是确定offer走审批流程阶段了，其实这个阶段并不安全，没有邮件的offer都是会存在未知因素的，最终被顶掉的例子也是比比皆是，希望三少爷努力了这么久不会中彩吧！</p>
<ul>
<li><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li>
</ul>
<p>​       感受：历时一个多月，终于拿到offer，三少爷还是满怀喜悦的，毕竟努力得到了认可。整体面试下来总体感受还是不错的，面试进度也推进的很快，虽然最后offer在薪酬审批过程中被卡了很久，但总算是有惊无险。技术方面问的东西偏底层，需要平时大量的积累，关键是跟面试官聊的来很重要，业务方面考察平时解决问题的思路以及学习方法和学习深度等。后面可能就从Java转向Golang了，于少爷而言具有挑战但难度不大，毕竟少爷可是看了大量jdk源码的人呐，加油吧！</p>
<ul>
<li><h3 id="复习学习计划"><a href="#复习学习计划" class="headerlink" title="复习学习计划"></a>复习学习计划</h3></li>
</ul>
<ol>
<li><p>操作系统  </p>
</li>
<li><p>计算机组成原理  </p>
</li>
<li><p>计算机网络  </p>
</li>
<li><p>数据结构与算法  </p>
</li>
<li><p>linux</p>
</li>
<li><p>golang</p>
<p>最后来一波鸡血吧，学习走起~</p>
</li>
</ol>
<p><img src="/2020/11/21/20201121-ms1的副本/timg.jpg" alt="图p1"></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>总结一下</title>
    <url>/2020/10/16/20201016-summarytobacktowrite/</url>
    <content><![CDATA[<h2 id="后面该写一些什么"><a href="#后面该写一些什么" class="headerlink" title="后面该写一些什么"></a>后面该写一些什么</h2><p>之前很长一段时间没有更新，其实也不是因为懒，主要是有很多东西需要沉淀和研究，该写的东西应该是都有记录，陆续再慢慢放上来，最主要是这个hexo的格式实在是太难调整了，在这里就打打鸡血，博客是要继续写的，好记性不如烂笔头，后续我这列了一个提纲，一步一步来写出自己的理解：   </p>
<ul>
<li>1、并发编程  </li>
<li>2、jvm  </li>
<li>3、redis  </li>
<li>4、mysql  </li>
<li>5、框架分析(spring、springmvc、springboot、springcloud)  </li>
<li>6、rabbitmq  </li>
<li>7、zookeeper  </li>
<li>8、jdk源码分析  </li>
<li>9、分布式相关</li>
</ul>
<p>接下来就开始吧！<br><img src="/2020/10/16/20201016-summarytobacktowrite/timg.jpg" alt="图p1"></p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>springIOC---2、手工简单实现基于annotation的IOC框架</title>
    <url>/2020/01/29/springioc-anno/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>……上一篇中我们探讨了基于xml配置文件的方式如何实现一个IOC容器，然而实际情况是这种方式在现在的开发中应用场景已经不多了，如果你们公司还在使用这种方式那说明你们公司的技术是真的还挺落后的，在敏捷开发至上的时代，我们往往使用的是另外一种方式—基于annotation来实现IOC管理，springboot中就已经很少去使用xml文件的方式了，基本上都是采用注解的方式，下面我们就来看看，基于annotation我们该如何去实现一个IOC容器。</p>
<h1 id="如何基于注解实现一个IOC容器"><a href="#如何基于注解实现一个IOC容器" class="headerlink" title="如何基于注解实现一个IOC容器"></a>如何基于注解实现一个IOC容器</h1><p>……这里我也不多做关于spring的相关介绍，大家可自行去官网了解相关内容，我们直接进入正题，承接上一篇文章，今天就来讲解一下第2种方式，通过annotation的方式来实现IOC容器。</p>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p>……整体的代码结构如下图，下面就逐一解析<br><img src="/2020/01/29/springioc-anno/1.jpg" alt="图p1"></p>
<center>**代码结构**</center>

<h3 id="入口类TestMain"><a href="#入口类TestMain" class="headerlink" title="入口类TestMain"></a>入口类TestMain</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.hk.annospringioc;</span><br><span class="line"></span><br><span class="line">public class TestMain &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		MyAnnotationApplicationContext fac = new MyAnnotationApplicationContext(&quot;com.hk.annospringioc&quot;);</span><br><span class="line">		Boy bean1 = (Boy) fac.getBean(&quot;boy&quot;);</span><br><span class="line">		bean1.printAll();</span><br><span class="line">		Girl bean2 = (Girl) fac.getBean(&quot;girl&quot;);</span><br><span class="line">		bean2.printAll();</span><br><span class="line">		Person bean = (Person) fac.getBean(&quot;person&quot;);</span><br><span class="line">		Person beancopy = (Person) fac.getBean(&quot;person&quot;);</span><br><span class="line">		bean.printAll();</span><br><span class="line">		System.out.println(bean == beancopy ? &quot;是同一个person&quot; : &quot;不是同一个person&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个程序的main方法中我们new了一个MyAnnotationApplicationContext这样的一个对象，并传入了一个类似包路径的参数，这里我们管它叫包扫描根目录，springboot就有这个概念，默认在主函数同级目录，这个类也是整个注解IOC构建过程中的核心类，介绍该类之前，先说明两个接口<br>ApplicationContext用于IOC容器构建  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.hk.springioc;</span><br><span class="line"></span><br><span class="line">public interface ApplicationContext &#123;</span><br><span class="line">	public void springIOC();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanFactory用于对象实例管理与获取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.hk.springioc;</span><br><span class="line"></span><br><span class="line">public interface BeanFactory &#123;</span><br><span class="line">	public Object getBean(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MyAnnotationApplicationContext"><a href="#MyAnnotationApplicationContext" class="headerlink" title="MyAnnotationApplicationContext"></a>MyAnnotationApplicationContext</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.hk.annospringioc;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Map.Entry;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class MyAnnotationApplicationContext implements BeanFactory,ApplicationContext &#123;</span><br><span class="line"></span><br><span class="line">	private ConfigManager configManager;</span><br><span class="line">	</span><br><span class="line">	private Map&lt;String,AnnoBean&gt; beanContainer;</span><br><span class="line">	</span><br><span class="line">	private Map&lt;String,Object&gt; instanceContainer ;</span><br><span class="line">	</span><br><span class="line">	public MyAnnotationApplicationContext(String path)&#123;</span><br><span class="line">		configManager = new ConfigManager();</span><br><span class="line">		instanceContainer = new HashMap&lt;String,Object&gt;();</span><br><span class="line">		beanContainer = configManager.ScanPackage(path);</span><br><span class="line">		springIOC();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//依賴注入的關鍵</span><br><span class="line">	@Override</span><br><span class="line">	public void springIOC() &#123;</span><br><span class="line">		Set&lt;Entry&lt;String, AnnoBean&gt;&gt; entrySet = beanContainer.entrySet();</span><br><span class="line">		for(Entry&lt;String, AnnoBean&gt; entry : entrySet)&#123;</span><br><span class="line">//			String name = entry.getKey();</span><br><span class="line">			AnnoBean bean = entry.getValue();</span><br><span class="line">			Object instance = createBean(bean);</span><br><span class="line">//			instanceContainer.put(name, instance);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private Object createBean(AnnoBean bean) &#123;</span><br><span class="line">		if(instanceContainer.get(bean.getName())!=null)&#123;</span><br><span class="line">			return instanceContainer.get(bean.getName());</span><br><span class="line">		&#125;</span><br><span class="line">		String className = bean.getClassName();</span><br><span class="line">		List&lt;Property&gt; props = bean.getProps();</span><br><span class="line">		Object newInstance = null;</span><br><span class="line">		try &#123;</span><br><span class="line">			Class&lt;?&gt; forName = Class.forName(className);</span><br><span class="line">			newInstance = forName.newInstance();</span><br><span class="line">			for(Property pro : props)&#123;</span><br><span class="line">				String name = pro.getName();</span><br><span class="line">				Field field = forName.getDeclaredField(name);</span><br><span class="line">				field.setAccessible(true);</span><br><span class="line">				if(pro.getRef()!=null)&#123;</span><br><span class="line">					String ref = pro.getRef();</span><br><span class="line">					Object existBean = getBean(ref);</span><br><span class="line">					if(existBean==null)&#123;</span><br><span class="line">						Object createBean = createBean(beanContainer.get(ref));</span><br><span class="line">						field.set(newInstance,createBean);</span><br><span class="line">					&#125;else&#123;</span><br><span class="line">						field.set(newInstance,existBean);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;else&#123;</span><br><span class="line">					Class&lt;?&gt; type = field.getType();</span><br><span class="line">					if(type==int.class)&#123;</span><br><span class="line">						field.set(newInstance,Integer.parseInt(pro.getValue()));</span><br><span class="line">					&#125;else&#123;</span><br><span class="line">						field.set(newInstance,pro.getValue());</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if(bean.getSingleton().equals(&quot;1&quot;))&#123;</span><br><span class="line">				instanceContainer.put(bean.getName(), newInstance);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; catch (InstantiationException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; catch (NoSuchFieldException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; catch (SecurityException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		return newInstance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Object getBean(String name) &#123;</span><br><span class="line">		return instanceContainer.get(name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释一下这个类主要做了什么：<br>1、new了一个ConfigManager对象<br>2、构建了一个HashMap类型的实例化容器instanceContainer<br>3、用第一步的ConfigManager对象对包扫描根目录下面的所有类进行扫描，获取一个Bean容器，这里的Bean就是annotation注解的相关bean信息，后面会有一个类进行封装<br>4、对Bean容器进行解析，构建最终的IOC实例容器，也就是第二步中的instanceContainer<br>下面就是我们相关自定义注解以及实体类中的注解表达方式</p>
<h3 id="VO组装已经相关类和属相的注解信息"><a href="#VO组装已经相关类和属相的注解信息" class="headerlink" title="VO组装已经相关类和属相的注解信息"></a>VO组装已经相关类和属相的注解信息</h3><p>实体组装结构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">封装Person信息，依赖注入Boy和Girl</span><br><span class="line">package com.hk.annospringioc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@MyComponent(value=&quot;person&quot;)</span><br><span class="line">public class Person &#123;</span><br><span class="line">	</span><br><span class="line">	@MyAutoWired(value = &quot;boy&quot;)</span><br><span class="line">	private Boy boy;</span><br><span class="line">	@MyAutoWired(value = &quot;girl&quot;)</span><br><span class="line">	private Girl girl;</span><br><span class="line"></span><br><span class="line">	public void printAll()&#123;</span><br><span class="line">		boy.printAll();</span><br><span class="line">		girl.printAll();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">类封装girl信息  </span><br><span class="line">package com.hk.annospringioc;</span><br><span class="line"></span><br><span class="line">@MyComponent(&quot;girl&quot;)</span><br><span class="line">public class Girl &#123;</span><br><span class="line">	</span><br><span class="line">	@MyValue(&quot;lily&quot;)</span><br><span class="line">	private String name;</span><br><span class="line">	@MyValue(&quot;17&quot;)</span><br><span class="line">	private int age;</span><br><span class="line"></span><br><span class="line">	public void printAll()&#123;</span><br><span class="line">		System.out.println(name+&quot;:&quot;+age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">封装boy的信息  </span><br><span class="line">package com.hk.annospringioc;</span><br><span class="line"></span><br><span class="line">@MyComponent(&quot;boy&quot;)</span><br><span class="line">public class Boy &#123;</span><br><span class="line"></span><br><span class="line">	@MyValue(&quot;lilei&quot;)</span><br><span class="line">	private String name;</span><br><span class="line">	</span><br><span class="line">	@MyValue(&quot;12&quot;)</span><br><span class="line">	private int age;</span><br><span class="line"></span><br><span class="line">	public void printAll()&#123;</span><br><span class="line">		System.out.println(name+&quot;:&quot;+age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">封装在类级别打上了注解的bean信息  </span><br><span class="line">package com.hk.annospringioc;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class AnnoBean &#123;</span><br><span class="line">	private String name;</span><br><span class="line">	private String className;</span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getClassName() &#123;</span><br><span class="line">		return className;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setClassName(String className) &#123;</span><br><span class="line">		this.className = className;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getSingleton() &#123;</span><br><span class="line">		return singleton;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setSingleton(String singleton) &#123;</span><br><span class="line">		this.singleton = singleton;</span><br><span class="line">	&#125;</span><br><span class="line">	public List&lt;Property&gt; getProps() &#123;</span><br><span class="line">		return props;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setProps(List&lt;Property&gt; props) &#123;</span><br><span class="line">		this.props = props;</span><br><span class="line">	&#125;</span><br><span class="line">	private String singleton = &quot;1&quot;;</span><br><span class="line">	private List&lt;Property&gt; props;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">封装在属性级别打上了注解的property的bean信息  </span><br><span class="line">package com.hk.annospringioc;</span><br><span class="line"></span><br><span class="line">public class Property &#123;</span><br><span class="line">	private String name;</span><br><span class="line">	private String value;</span><br><span class="line">	private String ref;</span><br><span class="line"></span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String getValue() &#123;</span><br><span class="line">		return value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setValue(String value) &#123;</span><br><span class="line">		this.value = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String getRef() &#123;</span><br><span class="line">		return ref;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setRef(String ref) &#123;</span><br><span class="line">		this.ref = ref;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ConfigManager"><a href="#ConfigManager" class="headerlink" title="ConfigManager"></a>ConfigManager</h3><p>……这里我们只需要对包扫描根路径下的所有类进行扫描，通过类以及属性的注解扫描组装好对应bean容器即可，其实跟xml配置文件的整个流程是一样一样的，只是在实际实现上面，我们不用去解析xml文件，而是通过reflect对每一个类进行扫描解析，扫描到对应的注解就做对应的操作，仅此而已，大家稍看代码自己体会一下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.hk.annospringioc;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.lang.annotation.Annotation;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.net.URL;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">import org.dom4j.Document;</span><br><span class="line">import org.dom4j.DocumentException;</span><br><span class="line">import org.dom4j.Element;</span><br><span class="line">import org.dom4j.io.SAXReader;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @ClassName: ConfigManager </span><br><span class="line"> * @Description: TODO(这里用一句话描述这个类的作用) </span><br><span class="line"> * @author A18ccms a18ccms_gmail_com </span><br><span class="line"> * @date 2019年4月9日 下午5:33:23 </span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class ConfigManager &#123;</span><br><span class="line">	</span><br><span class="line">	public  Map&lt;String,AnnoBean&gt; ScanPackage(String basePackage)&#123;</span><br><span class="line">		List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">		Map&lt;String,AnnoBean&gt; map = new HashMap&lt;String,AnnoBean&gt;();</span><br><span class="line">		final URL url = this.getClass().getClassLoader().getResource(basePackage.replaceAll(&quot;\\.&quot;, &quot;/&quot;));</span><br><span class="line">        final File basePackageFile = new File(url.getPath());</span><br><span class="line">        File[] listFiles = basePackageFile.listFiles();</span><br><span class="line">        for(File file : listFiles)&#123;</span><br><span class="line">        	if(file.isFile())&#123;</span><br><span class="line">        		list.add(basePackage+&quot;.&quot;+file.getName().split(&quot;\\.&quot;)[0]);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(String strr : list)&#123;</span><br><span class="line">        	String className = strr;</span><br><span class="line">        	try &#123;</span><br><span class="line">				Class&lt;?&gt; forName = Class.forName(className);</span><br><span class="line">				if(forName.isAnnotationPresent(MyComponent.class))&#123;</span><br><span class="line">					MyComponent annotation = forName.getAnnotation(MyComponent.class);</span><br><span class="line">					String value = annotation.value();</span><br><span class="line">					AnnoBean bean = new AnnoBean();</span><br><span class="line">					bean.setName(value);</span><br><span class="line">					bean.setClassName(className);</span><br><span class="line">					List&lt;Property&gt; propList = new ArrayList&lt;Property&gt;();</span><br><span class="line">					Field[] fields = forName.getDeclaredFields();</span><br><span class="line">					for(Field field : fields)&#123;</span><br><span class="line">						if(field.isAnnotationPresent(MyAutoWired.class))&#123;</span><br><span class="line">							Property prop = new Property();</span><br><span class="line">							MyAutoWired annotation2 = field.getAnnotation(MyAutoWired.class);</span><br><span class="line">							prop.setName(field.getName());</span><br><span class="line">							prop.setRef(annotation2.value());</span><br><span class="line">							propList.add(prop);</span><br><span class="line">						&#125;</span><br><span class="line">						if(field.isAnnotationPresent(MyValue.class))&#123;</span><br><span class="line">							Property prop = new Property();</span><br><span class="line">							MyValue annotation2 = field.getAnnotation(MyValue.class);</span><br><span class="line">							prop.setName(field.getName());</span><br><span class="line">							prop.setValue(annotation2.value());</span><br><span class="line">							propList.add(prop);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					bean.setProps(propList);</span><br><span class="line">					map.put(value,bean);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">        	</span><br><span class="line">        &#125;</span><br><span class="line">		return map;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写到这里还没有完，现在重点来了，有没有发现，上面这些类的类名或者属性上面多了三个这个东西，@MyAutoWired，@MyComponent，@MyValue，这就是我们的自定义注解，下面就看看这三个东西如何编写。 </p>
<h3 id="自定义注解编写"><a href="#自定义注解编写" class="headerlink" title="自定义注解编写"></a>自定义注解编写</h3><p>……自定义注解其实就是告诉框架，需要识别的注解是哪些，当构建bean容器的时候，框架初始化时见到对应的注解去做对应的操作，MyComponent是类级别注解，MyAutowired、MyValue是属性级别注解，只能在对应区域进行使用！！！  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.hk.annospringioc;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">import org.dom4j.Element;</span><br><span class="line"></span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.FIELD)</span><br><span class="line">public @interface MyAutoWired &#123;</span><br><span class="line">	String value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">package com.hk.annospringioc;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">import org.dom4j.Element;</span><br><span class="line"></span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">public @interface MyComponent &#123;</span><br><span class="line">	String value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">package com.hk.annospringioc;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">import org.dom4j.Element;</span><br><span class="line"></span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.FIELD)</span><br><span class="line">public @interface MyValue &#123;</span><br><span class="line">	String value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，到此整个基于注解的ioc实现方式代码就写完了，下面我们来运行一下看看结果</p>
<h3 id="最后运行TestMain"><a href="#最后运行TestMain" class="headerlink" title="最后运行TestMain"></a>最后运行TestMain</h3><p>查看最终运行结果: 同样IOC容器内的实例也是单例的<br><img src="/2020/01/29/springioc-anno/2.jpg" alt="图p2"></p>
<center>**运行结果**</center>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>……ok，写到这里我们就简单的实现了一个基于注解方式的IOC容器，原理其实也很简单，只需要你了解reflect以及java基础你都不用去了解xml相关的内容，本篇文章重点只是向大家介绍一个最基本的实现原理，理解这个原理对于以后的开发会有极大的帮助，所以现在你有稍微了解到我们在使用springboot开发过程中那些@Controller、@Service、@Component、@Autowired注解的含义了吗？下一篇文章我们就基于本篇的原理来自己实现一个简单的springmvc框架…谢谢！</p>
]]></content>
      <categories>
        <category>spring相关框架原理</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>框架原理解析</tag>
      </tags>
  </entry>
  <entry>
    <title>springIOC---1、手工简单实现基于xml的IOC框架</title>
    <url>/2020/01/28/20200127springioc/</url>
    <content><![CDATA[<h1 id="如何自己实现一个IOC容器"><a href="#如何自己实现一个IOC容器" class="headerlink" title="如何自己实现一个IOC容器"></a>如何自己实现一个IOC容器</h1><p>……这里我并不想多做关于spring的相关介绍，大家可自行去官网了解相关内容，我们直接进入正题，假如让你自己去做开发，并且spring开始收取高额的费用了，这里只是假设，你该如何去开发？思考一分钟……稍微有点框架基础的人应该都会说自己开发一个IOC框架进行容器管理不就得了，确实，容器管理是本文的重点，今天就来讲解一下第一种方式，通过xml文件的方式来实现IOC容器。</p>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p>……整体的代码结构如下图，下面就逐一解析<br><img src="/2020/01/28/20200127springioc/1.png" alt="图p1"></p>
<center>**代码结构**</center>

<h3 id="入口类TestMain"><a href="#入口类TestMain" class="headerlink" title="入口类TestMain"></a>入口类TestMain</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.hk.springioc;</span><br><span class="line"></span><br><span class="line">public class TestMain &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		MyXmlClassPathApplicationContext fac = new MyXmlClassPathApplicationContext(&quot;myspring.xml&quot;);</span><br><span class="line">		Person bean1 = (Person) fac.getBean(&quot;person&quot;);</span><br><span class="line">		Person bean2 = (Person) fac.getBean(&quot;person&quot;);</span><br><span class="line">		bean1.printAll();</span><br><span class="line">		bean2.printAll();</span><br><span class="line">		System.out.print(bean1 == bean2 ? &quot;同一个对象&quot; : &quot;非同一个对象&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个程序的main方法中我们new了一个MyXmlClassPathApplicationContext这样的一个对象，这也是整个稍后IOC构建过程中的核心类，介绍该类之前，先说明两个接口<br>ApplicationContext用于IOC容器构建  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.hk.springioc;</span><br><span class="line"></span><br><span class="line">public interface ApplicationContext &#123;</span><br><span class="line">	public void springIOC();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanFactory用于对象实例管理与获取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.hk.springioc;</span><br><span class="line"></span><br><span class="line">public interface BeanFactory &#123;</span><br><span class="line">	public Object getBean(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MyXmlClassPathApplicationContext"><a href="#MyXmlClassPathApplicationContext" class="headerlink" title="MyXmlClassPathApplicationContext"></a>MyXmlClassPathApplicationContext</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.hk.springioc;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Map.Entry;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class MyXmlClassPathApplicationContext implements BeanFactory,ApplicationContext &#123;</span><br><span class="line"></span><br><span class="line">	private ConfigManager configManager;</span><br><span class="line">	</span><br><span class="line">	private Map&lt;String,Bean&gt; beanContainer;</span><br><span class="line">	</span><br><span class="line">	private Map&lt;String,Object&gt; instanceContainer ;</span><br><span class="line">	</span><br><span class="line">	public MyXmlClassPathApplicationContext(String path)&#123;</span><br><span class="line">		configManager = new ConfigManager();</span><br><span class="line">		instanceContainer = new HashMap&lt;String,Object&gt;();</span><br><span class="line">		beanContainer = configManager.parseXML(path);</span><br><span class="line">		springIOC();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//依賴注入的關鍵</span><br><span class="line">	@Override</span><br><span class="line">	public void springIOC() &#123;</span><br><span class="line">		Set&lt;Entry&lt;String, Bean&gt;&gt; entrySet = beanContainer.entrySet();</span><br><span class="line">		for(Entry&lt;String, Bean&gt; entry : entrySet)&#123;</span><br><span class="line">//			String name = entry.getKey();</span><br><span class="line">			Bean bean = entry.getValue();</span><br><span class="line">			Object instance = createBean(bean);</span><br><span class="line">//			instanceContainer.put(name, instance);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private Object createBean(Bean bean) &#123;</span><br><span class="line">		if(instanceContainer.get(bean.getName())!=null)&#123;</span><br><span class="line">			return instanceContainer.get(bean.getName());</span><br><span class="line">		&#125;</span><br><span class="line">		String className = bean.getClassName();</span><br><span class="line">		List&lt;Property&gt; props = bean.getProps();</span><br><span class="line">		Object newInstance = null;</span><br><span class="line">		try &#123;</span><br><span class="line">			Class&lt;?&gt; forName = Class.forName(className);</span><br><span class="line">			newInstance = forName.newInstance();</span><br><span class="line">			for(Property pro : props)&#123;</span><br><span class="line">				String name = pro.getName();</span><br><span class="line">				Field field = forName.getDeclaredField(name);</span><br><span class="line">				field.setAccessible(true);</span><br><span class="line">				if(pro.getRef()!=null)&#123;</span><br><span class="line">					String ref = pro.getRef();</span><br><span class="line">					Object existBean = getBean(ref);</span><br><span class="line">					if(existBean==null)&#123;</span><br><span class="line">						Object createBean = createBean(beanContainer.get(ref));</span><br><span class="line">						field.set(newInstance,createBean);</span><br><span class="line">					&#125;else&#123;</span><br><span class="line">						field.set(newInstance,existBean);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;else&#123;</span><br><span class="line">					Class&lt;?&gt; type = field.getType();</span><br><span class="line">					if(type==int.class)&#123;</span><br><span class="line">						field.set(newInstance,Integer.parseInt(pro.getValue()));</span><br><span class="line">					&#125;else&#123;</span><br><span class="line">						field.set(newInstance,pro.getValue());</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if(bean.getSingleton().equals(&quot;1&quot;))&#123;</span><br><span class="line">				instanceContainer.put(bean.getName(), newInstance);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; catch (InstantiationException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; catch (NoSuchFieldException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; catch (SecurityException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		return newInstance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Object getBean(String name) &#123;</span><br><span class="line">		return instanceContainer.get(name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释一下这个类主要做了什么：<br>1、new了一个ConfigManager对象<br>2、构建了一个HashMap类型的实例化容器instanceContainer<br>3、用第一步的ConfigManager对象解析XML文件，获取一个Bean容器，这里的Bean就是XML文件中配置的相关bean信息，后面会有一个类进行封装<br>4、对Bean容器进行解析，构建最终的IOC实例容器，也就是第二步中的instanceContainer<br>下面就是xml文件以及对应封装类Bean</p>
<h3 id="myspring-xml"><a href="#myspring-xml" class="headerlink" title="myspring.xml"></a>myspring.xml</h3><p>配置文件结构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans&gt;</span><br><span class="line">&lt;bean name=&quot;person&quot; class=&quot;com.hk.springioc.Person&quot;&gt;</span><br><span class="line">&lt;property name=&quot;boy&quot; ref=&quot;boy&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;girl&quot; ref=&quot;girl&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean name=&quot;boy&quot; class=&quot;com.hk.springioc.Boy&quot;&gt;</span><br><span class="line">&lt;property name=&quot;age&quot; value=&quot;2&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;name&quot; value=&quot;lilei&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean name=&quot;girl&quot; class=&quot;com.hk.springioc.Girl&quot;&gt;</span><br><span class="line">&lt;property name=&quot;age&quot; value=&quot;1&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;name&quot; value=&quot;lily&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br><span class="line">封装Person信息，依赖注入Boy和Girl</span><br><span class="line">package com.hk.springioc;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">	private Boy boy;</span><br><span class="line">	private Girl girl;</span><br><span class="line">	public Boy getBoy() &#123;</span><br><span class="line">		return boy;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setBoy(Boy boy) &#123;</span><br><span class="line">		this.boy = boy;</span><br><span class="line">	&#125;</span><br><span class="line">	public Girl getGirl() &#123;</span><br><span class="line">		return girl;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setGirl(Girl girl) &#123;</span><br><span class="line">		this.girl = girl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public Person()&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	public void printAll()&#123;</span><br><span class="line">		System.out.println(boy.getName()+&quot;:&quot;+boy.getAge());</span><br><span class="line">		System.out.println(girl.getName()+&quot;:&quot;+girl.getAge());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">类封装girl信息  </span><br><span class="line">package com.hk.springioc;</span><br><span class="line"></span><br><span class="line">public class Girl &#123;</span><br><span class="line">	private String name;</span><br><span class="line">	private int age;</span><br><span class="line"></span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public int getAge() &#123;</span><br><span class="line">		return age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setAge(int age) &#123;</span><br><span class="line">		this.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Girl()&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	public void printAll()&#123;</span><br><span class="line">		System.out.println(name+&quot;:&quot;+age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">封装boy的信息  </span><br><span class="line">package com.hk.springioc;</span><br><span class="line"></span><br><span class="line">public class Boy &#123;</span><br><span class="line"></span><br><span class="line">	private String name;</span><br><span class="line">	private int age;</span><br><span class="line"></span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public int getAge() &#123;</span><br><span class="line">		return age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setAge(int age) &#123;</span><br><span class="line">		this.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Boy()&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	public void printAll()&#123;</span><br><span class="line">		System.out.println(name+&quot;:&quot;+age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">类封装xml中的bean标签信息  </span><br><span class="line">package com.hk.springioc;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class Bean &#123;</span><br><span class="line">	private String name;</span><br><span class="line">	private String className;</span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getClassName() &#123;</span><br><span class="line">		return className;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setClassName(String className) &#123;</span><br><span class="line">		this.className = className;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getSingleton() &#123;</span><br><span class="line">		return singleton;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setSingleton(String singleton) &#123;</span><br><span class="line">		this.singleton = singleton;</span><br><span class="line">	&#125;</span><br><span class="line">	public List&lt;Property&gt; getProps() &#123;</span><br><span class="line">		return props;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setProps(List&lt;Property&gt; props) &#123;</span><br><span class="line">		this.props = props;</span><br><span class="line">	&#125;</span><br><span class="line">	private String singleton = &quot;1&quot;;</span><br><span class="line">	private List&lt;Property&gt; props;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">类封装xml文件中的property信息  </span><br><span class="line"></span><br><span class="line">package com.hk.springioc;</span><br><span class="line"></span><br><span class="line">public class Property &#123;</span><br><span class="line">	private String name;</span><br><span class="line">	private String value;</span><br><span class="line">	private String ref;</span><br><span class="line"></span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String getValue() &#123;</span><br><span class="line">		return value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setValue(String value) &#123;</span><br><span class="line">		this.value = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String getRef() &#123;</span><br><span class="line">		return ref;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setRef(String ref) &#123;</span><br><span class="line">		this.ref = ref;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ConfigManager"><a href="#ConfigManager" class="headerlink" title="ConfigManager"></a>ConfigManager</h3><p>我们可以使用dom4j或者SAXReader对xml文件进行解析，构建需要的Bean容器，这里需要重点说明一点！！！我们的xml配置文件中没有特殊说明的bean都是singleton，也只有单例的对象才需要IOC容器进行管理，非单例的对象IOC容器是不会管理的  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.hk.springioc;</span><br><span class="line"></span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">import org.dom4j.Document;</span><br><span class="line">import org.dom4j.DocumentException;</span><br><span class="line">import org.dom4j.Element;</span><br><span class="line">import org.dom4j.io.SAXReader;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @ClassName: ConfigManager </span><br><span class="line"> * @Description: TODO(这里用一句话描述这个类的作用) </span><br><span class="line"> * @author A18ccms a18ccms_gmail_com </span><br><span class="line"> * @date 2019年4月9日 下午5:33:23 </span><br><span class="line"> * 解析xml組裝Bean容器</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class ConfigManager &#123;</span><br><span class="line">	</span><br><span class="line">	public  Map&lt;String,Bean&gt; parseXML(String path)&#123;</span><br><span class="line">		Map&lt;String,Bean&gt; map = new HashMap&lt;String,Bean&gt;();</span><br><span class="line">		InputStream is = this.getClass().getResourceAsStream(path);</span><br><span class="line">		SAXReader reader = new SAXReader();</span><br><span class="line">		try &#123;</span><br><span class="line">			Document doc = reader.read(is);</span><br><span class="line">			List&lt;Element&gt; selectNodes = doc.selectNodes(&quot;//bean&quot;);</span><br><span class="line">			for(Element ele : selectNodes)&#123;</span><br><span class="line">				String nameValue = ele.attributeValue(&quot;name&quot;);</span><br><span class="line">				String classValue = ele.attributeValue(&quot;class&quot;);</span><br><span class="line">				String singtonValue = ele.attributeValue(&quot;singleton&quot;);</span><br><span class="line">				Bean bean = new Bean();</span><br><span class="line">				bean.setName(nameValue);</span><br><span class="line">				bean.setClassName(classValue);</span><br><span class="line">				if(singtonValue!=null)&#123;</span><br><span class="line">					bean.setSingleton(singtonValue);</span><br><span class="line">				&#125;</span><br><span class="line">				List&lt;Property&gt; list = new ArrayList&lt;Property&gt;();</span><br><span class="line">				List&lt;Element&gt; pros = ele.elements(&quot;property&quot;);</span><br><span class="line">				for(Element pro : pros)&#123;</span><br><span class="line">					Property prop = new Property();</span><br><span class="line">					prop.setName(pro.attributeValue(&quot;name&quot;));</span><br><span class="line">					prop.setValue(pro.attributeValue(&quot;value&quot;));</span><br><span class="line">					prop.setRef(pro.attributeValue(&quot;ref&quot;));</span><br><span class="line">					list.add(prop);</span><br><span class="line">				&#125;</span><br><span class="line">				bean.setProps(list);</span><br><span class="line">				map.put(bean.getName(), bean);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch (DocumentException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		return map;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最后运行TestMain"><a href="#最后运行TestMain" class="headerlink" title="最后运行TestMain"></a>最后运行TestMain</h3><p>查看最终运行结果:<br><img src="/2020/01/28/20200127springioc/2.png" alt="图p2"></p>
<center>**运行结果**</center>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>……好了，写到这里我们就简单的实现了一个基于xml配置文件方式的IOC容器，原理其实很简单，只需要你了解reflect以及java基础，难的在于实现，spring框架通过各种设计模式实现了方便大家使用的最终发版，这里我不多做讲解，因为本人也在研究和学习当中，设计模式也是本人的缺陷，本篇文章重点只是向大家介绍一个最基本的实现原理，理解这个原理对于以后的开发会有很大的帮助，下一篇文章中我们再来讨论一下基于annotation的IOC容器构建…谢谢</p>
]]></content>
      <categories>
        <category>spring相关框架原理</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>框架原理解析</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot添加actuator</title>
    <url>/2019/11/25/20191125-springboot-actuator/</url>
    <content><![CDATA[<h1 id="springboot如何添加actuator"><a href="#springboot如何添加actuator" class="headerlink" title="springboot如何添加actuator"></a>springboot如何添加actuator</h1><h2 id="一、正常添加"><a href="#一、正常添加" class="headerlink" title="一、正常添加"></a>一、正常添加</h2><p>首先你需要引入相关jar包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">        compile(&apos;org.springframework.boot:spring-boot-starter-actuator&apos;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>接下来需要在yml添加如下配置，大致意思就是开放节点检查并且暴露出所有的endpoint以http的方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">management:</span><br><span class="line">  endpoint:</span><br><span class="line">    health:</span><br><span class="line">      show-details: always</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &quot;*&quot;</span><br></pre></td></tr></table></figure>

<p>其实到这一步就完成了配置了，你就可以在浏览器通过http:\ip:port\actuator进行访问了，但是这个东东还是个挺隐私的东西,我们不能让任何人通过url就能进行访问和操作，所以需要你对这个东西进行权限验证，<br>这里我们使用springsecurity，添加如下代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSecurity</span><br><span class="line">public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http.formLogin().and().authorizeRequests()</span><br><span class="line">                .antMatchers(&quot;/actuator/*&quot;).authenticated()</span><br><span class="line">                .and().csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有没有发现我们配置了地址授权，但是我们要输入什么授权信息了？所以你还需要在yml中添加如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  security:</span><br><span class="line">    user:</span><br><span class="line">      roles: ACTUATOR_ADMIN</span><br><span class="line">      name: actuator</span><br><span class="line">      password: AA@4321,</span><br></pre></td></tr></table></figure>

<p>到这里我们就真正完成了actuator的添加，我们来测试一下，但我访问：<br>http:\ip:port\actuator\info时，浏览器直接就跳转了：<br><img src="/2019/11/25/20191125-springboot-actuator/1.jpg" alt="图p1"></p>
<center>**图p1**</center>
当然这是一种简单的情况，应用本来就没有做任何的权限或加密动作，添加起来也是很简单，下面就说一种小猴我项目中遇到的特殊情况

<h2 id="二、不正常情况添加"><a href="#二、不正常情况添加" class="headerlink" title="二、不正常情况添加"></a>二、不正常情况添加</h2><p>其实我说的这种不正常添加就是原本的项目你就已经添加了security，并且使用了加密检测。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public BCryptPasswordEncoder bcryptPasswordEncoder()&#123;</span><br><span class="line">    return new BCryptPasswordEncoder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们就用上述的方式启动项目然后访问http:\ip:port\actuator\info看看是什么情况，没错你会发现正常会跳转到授权页面<br><img src="/2019/11/25/20191125-springboot-actuator/2.jpg" alt="图p2"></p>
<center>**图p2**</center>  
但是你只要输入密码，  就会像下图一样显示这样的报错信息：  
同时，  我们在控制台也能看到如下的警告：  
![图p4](20191125-springboot-actuator/4.jpg)
<center>**图p4**</center>
很明显所有的问题都出在这个加密器上面，这时你只需要加入下面一行代码，所有的问题就可以得到解决：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Value(&quot;$&#123;spring.security.user.roles&#125;&quot;)</span><br><span class="line">private String roles;</span><br><span class="line">@Value(&quot;$&#123;spring.security.user.name&#125;&quot;)</span><br><span class="line">private String name;</span><br><span class="line">@Value(&quot;$&#123;spring.security.user.password&#125;&quot;)</span><br><span class="line">private String password;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser(name)</span><br><span class="line">                .password(new BCryptPasswordEncoder().encode(password))</span><br><span class="line">                .roles(roles);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这行代码大致意思就是还是在配置文件yml里面配置相关信息，但是这些信息注册到授权时先用这个加密器把密码加密好，然后当你重启后再输入用户密码，就能看到以下页面了<br><img src="/2019/11/25/20191125-springboot-actuator/5.jpg" alt="图p5"></p>
<center>**图p5**</center>]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>actuator</tag>
      </tags>
  </entry>
  <entry>
    <title>Git---删除本地和远程分支</title>
    <url>/2019/11/25/20191125-git-deletebranch/</url>
    <content><![CDATA[<h2 id="Git—删除本地和远程分支"><a href="#Git—删除本地和远程分支" class="headerlink" title="Git—删除本地和远程分支"></a>Git—删除本地和远程分支</h2><p>1.列出本地和远程分支：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>

<p>2.删除本地分支：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -D BranchName</span><br></pre></td></tr></table></figure>

<p>其中-D也可以是–delete，如：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch --delete BranchName</span><br></pre></td></tr></table></figure>

<p>3.删除本地的远程分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -r -D origin/BranchName</span><br></pre></td></tr></table></figure>

<p>4.远程删除git服务器上的分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin -d BranchName</span><br></pre></td></tr></table></figure>

<p>其中-d也可以是–delete，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin --delete BranchName</span><br></pre></td></tr></table></figure>

<p>5.再使用命令查看本地和远程分支情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins-1、jenkins环境搭建</title>
    <url>/2019/11/19/20191119-jenkins-build/</url>
    <content><![CDATA[<h1 id="Jenkins环境搭建"><a href="#Jenkins环境搭建" class="headerlink" title="Jenkins环境搭建"></a>Jenkins环境搭建</h1><h2 id="1、jdk安装"><a href="#1、jdk安装" class="headerlink" title="1、jdk安装"></a>1、jdk安装</h2><h3 id="1-1-安装jdk"><a href="#1-1-安装jdk" class="headerlink" title="1.1 安装jdk"></a>1.1 安装jdk</h3><p>此步骤省略，参考这篇文章  </p>
<h2 id="2、Jenkins安装"><a href="#2、Jenkins安装" class="headerlink" title="2、Jenkins安装"></a>2、Jenkins安装</h2><p>以下是jenkins安装的完整步骤:  </p>
<h3 id="2-1-下载jenkins"><a href="#2-1-下载jenkins" class="headerlink" title="2.1 下载jenkins"></a>2.1 下载jenkins</h3><p>下载jenkin命令:  </p>
<p>wget <a href="https://pkg.jenkins.io/redhat/jenkins-2.205-1.1.noarch.rpm" target="_blank" rel="noopener">https://pkg.jenkins.io/redhat/jenkins-2.205-1.1.noarch.rpm</a> </p>
<h3 id="2-2-安装jenkins"><a href="#2-2-安装jenkins" class="headerlink" title="2.2 安装jenkins"></a>2.2 安装jenkins</h3><p>安装执行：</p>
<p>rpm -ivh jenkins-2.83-1.1.noarch.rpm  </p>
<h3 id="2-3-修改jenkins用户和端口"><a href="#2-3-修改jenkins用户和端口" class="headerlink" title="2.3 修改jenkins用户和端口"></a>2.3 修改jenkins用户和端口</h3><p>修改用户和端口：  </p>
<p>vi /etc/sysconfig/jenkins<br>JENKINS_USER=root<br>JENKINS_PORT=8888  </p>
<h3 id="2-4-启动服务"><a href="#2-4-启动服务" class="headerlink" title="2.4 启动服务:"></a>2.4 启动服务:</h3><p>执行启动命令:<br>systemctl start jenkins</p>
<p>本人第一次启动是失败的遇到如下问题：  </p>
<p>[root@localhost ~]# systemctl start jenkins<br>Job for jenkins.service failed because the control process exited with error code. See systemctl status jenkins.service and journalctl -xe for details.</p>
<p>按照提示输入查看问题,发现是jdk问题：    </p>
<p>[root@localhost bin]# systemctl status jenkins.service<br>Starting Jenkins bash: /software/jdk/jdk1.8.0_152/bin: 是一个目录</p>
<p>所以需要修改按如下修改一下  </p>
<p>vi /etc/init.d/jenkins</p>
<p>在最下面添加你的jdk位置即可  </p>
<p>candidates=<br>/etc/alternatives/java<br>/usr/lib/jvm/java-1.8.0/bin/java<br>/usr/lib/jvm/jre-1.8.0/bin/java<br>/usr/lib/jvm/java-1.7.0/bin/java<br>/usr/lib/jvm/jre-1.7.0/bin/java<br>/usr/bin/java<br>/software/jdk/jdk1.8.0_152/bin/java</p>
<p>重新执行如下命令:  </p>
<p>systemctl daemon-reload<br>systemctl start jenkins</p>
<p>然后就启动成功了</p>
<h3 id="2-5-访问服务"><a href="#2-5-访问服务" class="headerlink" title="2.5 访问服务:"></a>2.5 访问服务:</h3><p>地址：http:\服务器ip:上面配置的port 都是你之前配置的,配置步骤就省略了<br><a href="http://10.170.198.239:8080/" target="_blank" rel="noopener">http://10.170.198.239:8080/</a><br>yonyou/yonyou@600588<br><img src="/2019/11/19/20191119-jenkins-build/1.png" alt="图p1"></p>
<center>**图p1**</center>
ok搭建完成。


<h3 id="2-6-maven插件安装和Git插件安装"><a href="#2-6-maven插件安装和Git插件安装" class="headerlink" title="2.6 maven插件安装和Git插件安装"></a>2.6 maven插件安装和Git插件安装</h3><p>在系统管理–&gt;插件管理中安装插件<br><img src="/2019/11/19/20191119-jenkins-build/5.jpg" alt="图p2"></p>
<center>**图p2**</center>

]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
        <tag>deploy</tag>
      </tags>
  </entry>
  <entry>
    <title>Quartz---3、定时任务开发手册1--基础使用篇</title>
    <url>/2019/11/17/20191117-quartz-devuse/</url>
    <content><![CDATA[<h1 id="项目结构说明"><a href="#项目结构说明" class="headerlink" title="项目结构说明"></a>项目结构说明</h1><h2 id="项目结构图"><a href="#项目结构图" class="headerlink" title="项目结构图"></a>项目结构图</h2><p><img src="/2019/11/17/20191117-quartz-devuse/1.jpg" alt="图p1"></p>
<center>**图p1**</center>
整体的后台任务项目结构如上图所述,我们在开发过程中只需要关注job类的编写以及相关调用服务类的编写并且在前台配置好执行计划即可，至于任务的执行计划也就是后台任务日志会由job监听器来自动完成。我们只需要关注业务代码编写即可,这里我们希望按照一种定义好的规范进行自定义job的编写，如下：  

<h2 id="job类代码"><a href="#job类代码" class="headerlink" title="job类代码"></a>job类代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/***</span><br><span class="line"> * 测试job类</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">@DisallowConcurrentExecution</span><br><span class="line">public class Job extends QuartzJobBean &#123;</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    TestService testService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void executeInternal(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123;</span><br><span class="line">        // 获取参数</span><br><span class="line">        JobDataMap jobDataMap = jobExecutionContext.getJobDetail().getJobDataMap();</span><br><span class="line">        // 业务逻辑 ...</span><br><span class="line">        testService.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>job类需要继承QuartzJobBean,并且复写executeInternal方法,这里需要注意不要直接在该方法内写业务代码因为可能会导至事务完整性问题,实际的业务代码需要在TestService中进行编写,并将该服务类注入到自定的job中进行业务调用。@DisallowConcurrentExecution注解不可缺少。</p>
<h2 id="Service类代码"><a href="#Service类代码" class="headerlink" title="Service类代码"></a>Service类代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class TestService &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Transactional(propagation = Propagation.REQUIRED)</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        System.out.println(&quot;test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Transactional(propagation = Propagation.REQUIRES_NEW)</span><br><span class="line">    public void test_NEW()&#123;</span><br><span class="line">        System.out.println(&quot;test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码，需要@Service注解让你的服务类被IOC容器管理，并且在你的业务方法上面使用@Transactional注解，至于传播属性需要根据实际业务情况进行使用,如果不存在事务嵌套的情况,上述两种方式基本都可以解决大部分的问题,下一篇文章中我们会详细分析一下遇到事务嵌套情况该如何处理(这是一个比较复杂的问题，可能需要对aop有一定深度的理解，下一篇中我们详细探讨一下)。</p>
<h1 id="事务完整性演示"><a href="#事务完整性演示" class="headerlink" title="事务完整性演示"></a>事务完整性演示</h1><p>介绍完基本的开发方法,来检测一下是否按照上述标准事务完整性是正确的。<br>1、job类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@DisallowConcurrentExecution</span><br><span class="line">public class Job extends QuartzJobBean &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    TestService testService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void executeInternal(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123;</span><br><span class="line">        // 获取参数</span><br><span class="line">        JobDataMap jobDataMap = jobExecutionContext.getJobDetail().getJobDataMap();</span><br><span class="line">        // 业务逻辑 ...</span><br><span class="line">        System.out.println(&quot;job start&quot;);</span><br><span class="line">        testService.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、service类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class TestService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    @Transactional(propagation = Propagation.REQUIRED)</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        System.out.println(&quot;test&quot;);</span><br><span class="line">        jdbcTemplate.execute(&quot;insert into quartz_test(code,name) values(1,&apos;111&apos;) &quot;);</span><br><span class="line">        int j = 1/0;//注意这里</span><br><span class="line">        jdbcTemplate.execute(&quot;insert into quartz_test(code,name) values(2,&apos;222&apos;) &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Transactional(propagation = Propagation.REQUIRES_NEW)</span><br><span class="line">    public void test_NEW()&#123;</span><br><span class="line">        System.out.println(&quot;test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、注册任务项目启动后每隔15秒执行一次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Order(value = 1)</span><br><span class="line">public class AgentApplicationRun implements CommandLineRunner &#123;</span><br><span class="line"></span><br><span class="line">	@Autowired</span><br><span class="line">	QuartzService quartzService;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run(String... strings) throws Exception &#123;</span><br><span class="line">		HashMap&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">		map.put(&quot;name&quot;,3);</span><br><span class="line">		quartzService.deleteJob(&quot;job3&quot;, &quot;icbc&quot;);</span><br><span class="line">		quartzService.addJob(Job.class, &quot;job3&quot;, &quot;icbc&quot;, &quot;15 * * * * ?&quot;,&quot;job任务3&quot;, map, new Date(),new Date(new Date().getTime()+1000000));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>4、执行结果<br>4.1 服务代码中int j = 1/0没有注释掉<br><img src="/2019/11/17/20191117-quartz-devuse/2.png" alt="图p2"></p>
<center>**图p2**</center>  
上图我们看到任务执行，并且如期抛出了/0异常，我们再检查数据库中的确一条数据也没有

<p><img src="/2019/11/17/20191117-quartz-devuse/3.jpg" alt="图p3"></p>
<center>**图p3**</center>

<p>4.1 下面我们把服务代码中int j = 1/0注释掉，再看执行结果<br><img src="/2019/11/17/20191117-quartz-devuse/4.jpg" alt="图p4"></p>
<center>**图p4**</center>  
上图我们看到任务执行，并且没有抛出异常，我们再检查数据库中的确两条数据都进去了

<p><img src="/2019/11/17/20191117-quartz-devuse/5.jpg" alt="图p5"></p>
<center>**图p5**</center>

<h1 id="定制任务计划说明"><a href="#定制任务计划说明" class="headerlink" title="定制任务计划说明"></a>定制任务计划说明</h1><h3 id="最后需要很强调一点-由于quartz有一个复杂的misfired机制-本人暂时也没有摸的很清楚-希望在前台定制执行计划的时候选择任务开始时间时尽量选择在当前时间之后-也就是你点击保存按钮之后的时间最佳-否则就有可能出现第一次执行任务出现misfired情况-轮到第二次执行任务时会立即执行两次或两次以上-这都是由于quartz内部不同的trigger类型采用了不同的misfired机制导致的。"><a href="#最后需要很强调一点-由于quartz有一个复杂的misfired机制-本人暂时也没有摸的很清楚-希望在前台定制执行计划的时候选择任务开始时间时尽量选择在当前时间之后-也就是你点击保存按钮之后的时间最佳-否则就有可能出现第一次执行任务出现misfired情况-轮到第二次执行任务时会立即执行两次或两次以上-这都是由于quartz内部不同的trigger类型采用了不同的misfired机制导致的。" class="headerlink" title="最后需要很强调一点,由于quartz有一个复杂的misfired机制,本人暂时也没有摸的很清楚,希望在前台定制执行计划的时候选择任务开始时间时尽量选择在当前时间之后,也就是你点击保存按钮之后的时间最佳,否则就有可能出现第一次执行任务出现misfired情况,轮到第二次执行任务时会立即执行两次或两次以上,这都是由于quartz内部不同的trigger类型采用了不同的misfired机制导致的。"></a>最后需要很强调一点,由于quartz有一个复杂的misfired机制,本人暂时也没有摸的很清楚,希望在前台定制执行计划的时候选择任务开始时间时尽量选择在当前时间之后,也就是你点击保存按钮之后的时间最佳,否则就有可能出现第一次执行任务出现misfired情况,轮到第二次执行任务时会立即执行两次或两次以上,这都是由于quartz内部不同的trigger类型采用了不同的misfired机制导致的。</h3>]]></content>
      <categories>
        <category>Quartz</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>springcloud</tag>
        <tag>quartz</tag>
      </tags>
  </entry>
  <entry>
    <title>Quartz---1、Cron表达式</title>
    <url>/2019/11/15/20191115-quartz/</url>
    <content><![CDATA[<h2 id="CronTrigger"><a href="#CronTrigger" class="headerlink" title="CronTrigger"></a>CronTrigger</h2><p>借用网上的一篇Cron表达式说明<br>CronTriggers往往比SimpleTrigger更有用，如果您需要基于日历的概念，而非SimpleTrigger完全指定的时间间隔，复发的发射工作的时间表。<br>CronTrigger，你可以指定触发的时间表如“每星期五中午”，或“每个工作日9:30时”，甚至“每5分钟一班9:00和10:00逢星期一上午，星期三星期五“。<br>即便如此，SimpleTrigger一样，CronTrigger拥有的startTime指定的时间表时生效，指定的时间表时，应停止（可选）结束时间。</p>
<p>Cron Expressions<br>cron的表达式被用来配置CronTrigger实例。 cron的表达式是字符串，实际上是由七子表达式，描述个别细节的时间表。这些子表达式是分开的空白，代表：</p>
<ol>
<li>Seconds</li>
<li>Minutes</li>
<li>Hours</li>
<li>Day-of-Month</li>
<li>Month</li>
<li>Day-of-Week</li>
<li>Year (可选字段)<br>例  “0 0 12 ? * WED” 在每星期三下午12:00 执行,<br>个别子表达式可以包含范围, 例如，在前面的例子里(“WED”)可以替换成 “MON-FRI”, “MON, WED, FRI”甚至”MON-WED,SAT”.</li>
</ol>
<p>“*” 代表整个时间段.</p>
<p>每一个字段都有一套可以指定有效值，如</p>
<p>Seconds (秒)         ：可以用数字0－59 表示，</p>
<p>Minutes(分)          ：可以用数字0－59 表示，</p>
<p>Hours(时)             ：可以用数字0-23表示,</p>
<p>Day-of-Month(天) ：可以用数字1-31 中的任一一个值，但要注意一些特别的月份</p>
<p>Month(月)            ：可以用0-11 或用字符串  “JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV and DEC” 表示</p>
<p>Day-of-Week(每周)：可以用数字1-7表示（1 ＝ 星期日）或用字符口串“SUN, MON, TUE, WED, THU, FRI and SAT”表示</p>
<p>“/”：为特别单位，表示为“每”如“0/15”表示每隔15分钟执行一次,“0”表示为从“0”分开始, “3/20”表示表示每隔20分钟执行一次，“3”表示从第3分钟开始执行</p>
<p>“?”：表示每月的某一天，或第周的某一天</p>
<p>“L”：用于每月，或每周，表示为每月的最后一天，或每个月的最后星期几如“6L”表示“每月的最后一个星期五”</p>
<p>“W”：表示为最近工作日，如“15W”放在每月（day-of-month）字段上表示为“到本月15日最近的工作日”</p>
<p>““#”：是用来指定“的”每月第n个工作日,例 在每周（day-of-week）这个字段中内容为”6#3” or “FRI#3” 则表示“每月第三个星期五”</p>
<p>1）Cron表达式的格式：秒 分 时 日 月 周 年(可选)。</p>
<pre><code>字段名                 允许的值                        允许的特殊字符  
秒                      0-59                       , - * /  
分                      0-59                       , - * /  
小时                    0-23                        , - * /  
日                      1-31                       , - * ? / L W C  
月                      1-12 or JAN-DEC           , - * /  
周几                    1-7 or SUN-SAT           , - * ? / L C #  
年 (可选字段)         empty, 1970-2099                 , - * /



 “?”字符：表示不确定的值

 “,”字符：指定数个值

 “-”字符：指定一个值的范围

 “/”字符：指定一个值的增加幅度。n/m表示从n开始，每次增加m

 “L”字符：用在日表示一个月中的最后一天，用在周表示该月最后一个星期X

 “W”字符：指定离给定日期最近的工作日(周一到周五)

 “#”字符：表示该月第几个周X。6#3表示该月第3个周五</code></pre><p>   2）Cron表达式范例：</p>
<pre><code>每隔5秒执行一次：*/5 * * * * ?

每隔1分钟执行一次：0 */1 * * * ?

每天23点执行一次：0 0 23 * * ?

每天凌晨1点执行一次：0 0 1 * * ?

每月1号凌晨1点执行一次：0 0 1 1 * ?

每月最后一天23点执行一次：0 0 23 L * ?

每周星期天凌晨1点实行一次：0 0 1 ? * L

在26分、29分、33分执行一次：0 26,29,33 * * * ?

每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ?</code></pre>]]></content>
      <categories>
        <category>Quartz</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>springcloud</tag>
        <tag>quartz</tag>
      </tags>
  </entry>
  <entry>
    <title>Quartz---2、项目Quartz定时任务使用</title>
    <url>/2019/11/15/20191116-quartz-use/</url>
    <content><![CDATA[<h1 id="界面说明"><a href="#界面说明" class="headerlink" title="界面说明"></a>界面说明</h1><p>注意如果项目启动报错:<br>需要执行以下语句安装必须包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save react-cron-builder</span><br></pre></td></tr></table></figure>

<p>项目目前只采用一个任务组：ICBC  </p>
<h3 id="1、界面展示"><a href="#1、界面展示" class="headerlink" title="1、界面展示"></a>1、界面展示</h3><p><img src="/2019/11/15/20191116-quartz-use/1.jpg" alt="图p1"></p>
<center>**图p1**</center>
后台任务管理界面在系统设置里面，界面上能监控任务的实时状态

<h1 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h1><p>目前后台任务节点包含以下功能</p>
<h3 id="1、查询全部任务"><a href="#1、查询全部任务" class="headerlink" title="1、查询全部任务"></a>1、查询全部任务</h3><p><img src="/2019/11/15/20191116-quartz-use/3.jpg" alt="图p3"></p>
<center>**图p2**</center>  

<h3 id="2、查询运行中任务"><a href="#2、查询运行中任务" class="headerlink" title="2、查询运行中任务"></a>2、查询运行中任务</h3><p>可以查询正在处于运行的任务   </p>
<h3 id="3、新建Simple任务"><a href="#3、新建Simple任务" class="headerlink" title="3、新建Simple任务"></a>3、新建Simple任务</h3><p><img src="/2019/11/15/20191116-quartz-use/2.jpg" alt="图p3"></p>
<center>**图p3**</center>  

<h3 id="4、新建Cron任务"><a href="#4、新建Cron任务" class="headerlink" title="4、新建Cron任务"></a>4、新建Cron任务</h3><p>同上，只是jobtime换成的Cron表达式,关于Cron表达式,可以参考上一篇<br><a href="https://stevenhoukai.github.io/2019/11/15/20191115-quartz/">Cron表达式介绍</a>! </p>
<h3 id="5、修改任务"><a href="#5、修改任务" class="headerlink" title="5、修改任务"></a>5、修改任务</h3><p>可以动态的修改任务的执行计划等</p>
<h3 id="6、暂停任务"><a href="#6、暂停任务" class="headerlink" title="6、暂停任务"></a>6、暂停任务</h3><p>可以停止正在运行中的任务</p>
<h3 id="7、继续任务"><a href="#7、继续任务" class="headerlink" title="7、继续任务"></a>7、继续任务</h3><p>可以重启启动已经暂停的任务  </p>
<h3 id="8、立即运行一次任务"><a href="#8、立即运行一次任务" class="headerlink" title="8、立即运行一次任务"></a>8、立即运行一次任务</h3><p>内存copy一份job进行独立运行</p>
<h3 id="9、删除任务"><a href="#9、删除任务" class="headerlink" title="9、删除任务"></a>9、删除任务</h3><p>手动删除不需要的job</p>
<h1 id="开发说明"><a href="#开发说明" class="headerlink" title="开发说明"></a>开发说明</h1><p>目前整个台任务采取独立jar包的方式，支持集群部署(集群服务器时间必须保持一致)，随机负载均衡策略。<br>开发具体的自定job如下图:</p>
<p><img src="/2019/11/15/20191116-quartz-use/5.jpg" alt="图p4"></p>
<center>**图p4**</center>

<p><img src="/2019/11/15/20191116-quartz-use/4.jpg" alt="图p5"></p>
<center>**图p5**</center>

<p>自定义job类按照如图方式必须继承QuartzJobBean,并且重写executeInternal方法，在方法中添加业务代码即可，注意自定义job类上的注解要保留，目前业务代码的事务还在测试中，非数据库交互定时任务可以正常使用</p>
]]></content>
      <categories>
        <category>Quartz</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>springcloud</tag>
        <tag>quartz</tag>
      </tags>
  </entry>
  <entry>
    <title>React实战笔记---如何动态加载查询条件</title>
    <url>/2019/11/07/20191107-react-01/</url>
    <content><![CDATA[<h2 id="React实战笔记—如何动态加载查询条件"><a href="#React实战笔记—如何动态加载查询条件" class="headerlink" title="React实战笔记—如何动态加载查询条件"></a>React实战笔记—如何动态加载查询条件</h2><p>如图需要动态加载第五个查询条件<br><img src="/2019/11/07/20191107-react-01/1.png" alt="图p1"></p>
<p>由于框架原因，没法使用父组件直接调用子组件的方式。<br>下面给我这边的解决方案–&gt;通过页面加载完成之后再根据最新数据强制渲染一次的方式,<br>代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//页面渲染之前加载数据</span><br><span class="line">componentWillMount() &#123;</span><br><span class="line">    this.getCCYType();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//页面渲染完成之后再根据加载的数据强制渲染一次</span><br><span class="line">//时间间隔为0.001ms</span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">    setInterval(() =&gt; &#123;</span><br><span class="line">                   this.setState(() =&gt; &#123;</span><br><span class="line">                        return &#123; unseen: &quot;does not display&quot; &#125;</span><br><span class="line">&#125;);&#125;, 0.001);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取数据方法</span><br><span class="line">getCCYType = async () =&gt; &#123;</span><br><span class="line">        const retdata = await getCCYType();</span><br><span class="line">        var data = [];</span><br><span class="line">        if (retdata.code === 20000) &#123;</span><br><span class="line">            let ccylist = retdata.result.item_list;</span><br><span class="line">            for (var i = 0; i &lt; ccylist.length; i++) &#123;</span><br><span class="line">                data.push(&#123;id: ccylist[i].currencyCode, name: ccylist[i].currencyName&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            this.formList.push( &#123;</span><br><span class="line">                type: &apos;SELECT&apos;,</span><br><span class="line">                label: &apos;币种&apos;,</span><br><span class="line">                field: &apos;currencyType&apos;,</span><br><span class="line">                placeholder: &apos;请输入导入日期&apos;,</span><br><span class="line">                list: data,</span><br><span class="line">                width: 100,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            message.error(&quot;获取币种类型异常！ error=&quot; + retdata.msg)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样就可以以动态方式加载查询条件了，如下<br><img src="/2019/11/07/20191107-react-01/2.jpg" alt="图p2"></p>
]]></content>
      <categories>
        <category>React实战笔记</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>笔记篇---快速搭建vsftpd文件服务器</title>
    <url>/2019/11/06/20191106-vsftpd/</url>
    <content><![CDATA[<h2 id="vsftpd搭建文件服务器"><a href="#vsftpd搭建文件服务器" class="headerlink" title="vsftpd搭建文件服务器"></a>vsftpd搭建文件服务器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum remove vsftpd</span><br><span class="line">yum -y install vsftpd</span><br></pre></td></tr></table></figure>

<p>先删除已安装的软件，再重新安装完整的vsftpd;<br>然后添加一个ftp用户和密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd ftpuser</span><br><span class="line">passwd ftpuser</span><br></pre></td></tr></table></figure>

<p>防火墙开21端口  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /etc/sysconfig/iptables</span><br></pre></td></tr></table></figure>

<p>(在有 22 -j ACCEPT 的下面复制一行，端口改成21，wq保存并退出)<br>重启 iptables</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service iptables restart</span><br></pre></td></tr></table></figure>

<p>修改 selinux（外网可以访问，但无法返回目录，因为selinux）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getsebool -a | grep ftp（查看状态）</span><br><span class="line">setsebool -P allow_ftpd_full_access on （设置为 on）</span><br><span class="line">setsebool -P ftp_home_dir on（设置为 on）</span><br></pre></td></tr></table></figure>

<p>关闭匿名访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /etc/vsftpd/vsftpd.conf（anonymous_enable=NO）</span><br><span class="line">service vsftpd restart</span><br></pre></td></tr></table></figure>

<p>开机启动 vsftpd 服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chkconfig vsftpd on</span><br></pre></td></tr></table></figure>

<p>接下来就可以通过filezilla使用ftp协议访问了如图：</p>
<p><img src="/2019/11/06/20191106-vsftpd/1.jpg" alt="图p1"></p>
<center>**图p1**</center>

<p>另外这里附上FtpUtil.java工具类，首先如果你是gradle项目需要引入如下依赖包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &apos;commons-fileupload:commons-fileupload:1.3.1&apos;</span><br><span class="line">compile &apos;commons-net:commons-net:3.3&apos;</span><br></pre></td></tr></table></figure>

<p>代码如下，自行调试即可:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.yyicbc.utils;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.net.ftp.FTP;</span><br><span class="line">import org.apache.commons.net.ftp.FTPClient;</span><br><span class="line">import org.apache.commons.net.ftp.FTPFile;</span><br><span class="line">import org.apache.commons.net.ftp.FTPReply;</span><br><span class="line"></span><br><span class="line">public class FtpUtil &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Description: 向FTP服务器上传文件</span><br><span class="line">	 * @param host FTP服务器hostname</span><br><span class="line">	 * @param port FTP服务器端口</span><br><span class="line">	 * @param username FTP登录账号</span><br><span class="line">	 * @param password FTP登录密码</span><br><span class="line">	 * @param basePath FTP服务器基础目录</span><br><span class="line">	 * @param filePath FTP服务器文件存放路径。例如分日期存放：/2019/01/01。文件的路径为basePath+filePath</span><br><span class="line">	 * @param filename 上传到FTP服务器上的文件名</span><br><span class="line">	 * @param input 输入流</span><br><span class="line">	 * @return 成功返回true，否则返回false</span><br><span class="line">	 */</span><br><span class="line">	public static boolean uploadFile(String host, int port, String username, String password, String basePath,</span><br><span class="line">			String filePath, String filename, InputStream input) &#123;</span><br><span class="line">		boolean result = false;</span><br><span class="line">		FTPClient ftp = new FTPClient();</span><br><span class="line">		try &#123;</span><br><span class="line">			int reply;</span><br><span class="line">			ftp.connect(host, port);// 连接FTP服务器</span><br><span class="line">			// 如果采用默认端口，可以使用ftp.connect(host)的方式直接连接FTP服务器</span><br><span class="line">			ftp.login(username, password);// 登录</span><br><span class="line">			reply = ftp.getReplyCode();</span><br><span class="line">			if (!FTPReply.isPositiveCompletion(reply)) &#123;</span><br><span class="line">				ftp.disconnect();</span><br><span class="line">				return result;</span><br><span class="line">			&#125;</span><br><span class="line">			//切换到上传目录</span><br><span class="line">			if (!ftp.changeWorkingDirectory(basePath+filePath)) &#123;</span><br><span class="line">				//如果目录不存在创建目录</span><br><span class="line">				String[] dirs = filePath.split(&quot;/&quot;);</span><br><span class="line">				String tempPath = basePath;</span><br><span class="line">				for (String dir : dirs) &#123;</span><br><span class="line">					if (null == dir || &quot;&quot;.equals(dir)) continue;</span><br><span class="line">					tempPath += &quot;/&quot; + dir;</span><br><span class="line">					if (!ftp.changeWorkingDirectory(tempPath)) &#123;</span><br><span class="line">						if (!ftp.makeDirectory(tempPath)) &#123;</span><br><span class="line">							return result;</span><br><span class="line">						&#125; else &#123;</span><br><span class="line">							ftp.changeWorkingDirectory(tempPath);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			//设置上传文件的类型为二进制类型</span><br><span class="line">			ftp.setFileType(FTP.BINARY_FILE_TYPE);</span><br><span class="line">			//上传文件</span><br><span class="line">			if (!ftp.storeFile(filename, input)) &#123;</span><br><span class="line">				return result;</span><br><span class="line">			&#125;</span><br><span class="line">			input.close();</span><br><span class="line">			ftp.logout();</span><br><span class="line">			result = true;</span><br><span class="line">		&#125; catch (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			if (ftp.isConnected()) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					ftp.disconnect();</span><br><span class="line">				&#125; catch (IOException ioe) &#123;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Description: 从FTP服务器下载文件</span><br><span class="line">	 * @param host FTP服务器hostname</span><br><span class="line">	 * @param port FTP服务器端口</span><br><span class="line">	 * @param username FTP登录账号</span><br><span class="line">	 * @param password FTP登录密码</span><br><span class="line">	 * @param remotePath FTP服务器上的相对路径</span><br><span class="line">	 * @param fileName 要下载的文件名</span><br><span class="line">	 * @param localPath 下载后保存到本地的路径</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	public static boolean downloadFile(String host, int port, String username, String password, String remotePath,</span><br><span class="line">			String fileName, String localPath) &#123;</span><br><span class="line">		boolean result = false;</span><br><span class="line">		FTPClient ftp = new FTPClient();</span><br><span class="line">		try &#123;</span><br><span class="line">			int reply;</span><br><span class="line">			ftp.connect(host, port);</span><br><span class="line">			// 如果采用默认端口，可以使用ftp.connect(host)的方式直接连接FTP服务器</span><br><span class="line">			ftp.login(username, password);// 登录</span><br><span class="line">			reply = ftp.getReplyCode();</span><br><span class="line">			if (!FTPReply.isPositiveCompletion(reply)) &#123;</span><br><span class="line">				ftp.disconnect();</span><br><span class="line">				return result;</span><br><span class="line">			&#125;</span><br><span class="line">			ftp.changeWorkingDirectory(remotePath);// 转移到FTP服务器目录</span><br><span class="line">			FTPFile[] fs = ftp.listFiles();</span><br><span class="line">			for (FTPFile ff : fs) &#123;</span><br><span class="line">				if (ff.getName().equals(fileName)) &#123;</span><br><span class="line">					File localFile = new File(localPath + &quot;/&quot; + ff.getName());</span><br><span class="line"></span><br><span class="line">					OutputStream is = new FileOutputStream(localFile);</span><br><span class="line">					ftp.retrieveFile(ff.getName(), is);</span><br><span class="line">					is.close();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ftp.logout();</span><br><span class="line">			result = true;</span><br><span class="line">		&#125; catch (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			if (ftp.isConnected()) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					ftp.disconnect();</span><br><span class="line">				&#125; catch (IOException ioe) &#123;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">	        FileInputStream in=new FileInputStream(new File(&quot;E:\\ftptest\\test.jpg&quot;));</span><br><span class="line">	        boolean flag = uploadFile(&quot;xxxx&quot;, 21, &quot;xxxx&quot;, &quot;xxxx&quot;, &quot;/home/xxxx/files&quot;,&quot;/2019/11/06&quot;, &quot;test.jpg&quot;, in);</span><br><span class="line">	        System.out.println(flag);</span><br><span class="line">	    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">	        e.printStackTrace();</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>环境笔记篇</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>linux</tag>
        <tag>vsftpd</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/05/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo框架使用</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>笔记篇---Linux环境下安装JDK完整步骤</title>
    <url>/2019/11/05/20191105-01/</url>
    <content><![CDATA[<h2 id="1、检查一下系统中的jdk版本"><a href="#1、检查一下系统中的jdk版本" class="headerlink" title="1、检查一下系统中的jdk版本"></a>1、检查一下系统中的jdk版本</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost software]# java -version  </span><br><span class="line">显示：</span><br><span class="line"></span><br><span class="line">openjdk version &quot;1.8.0_102&quot;  </span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_102-b14)  </span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.102-b14, mixed mode)</span><br></pre></td></tr></table></figure>

<h2 id="2、检测jdk安装包"><a href="#2、检测jdk安装包" class="headerlink" title="2、检测jdk安装包"></a>2、检测jdk安装包</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost software]# rpm -qa | grep java</span><br><span class="line">显示：</span><br><span class="line"></span><br><span class="line">java-1.7.0-openjdk-1.7.0.111-2.6.7.8.el7.x86_64</span><br><span class="line">python-javapackages-3.4.1-11.el7.noarch</span><br><span class="line">tzdata-java-2016g-2.el7.noarch</span><br><span class="line">javapackages-tools-3.4.1-11.el7.noarch</span><br><span class="line">java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64</span><br><span class="line">java-1.8.0-openjdk-headless-1.8.0.102-4.b14.el7.x86_64</span><br><span class="line">java-1.7.0-openjdk-headless-1.7.0.111-2.6.7.8.el7.x86_64</span><br></pre></td></tr></table></figure>

<h2 id="3、卸载openjdk"><a href="#3、卸载openjdk" class="headerlink" title="3、卸载openjdk"></a>3、卸载openjdk</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost software]# rpm -e --nodeps tzdata-java-2016g-2.el7.noarch</span><br><span class="line">[root@localhost software]# rpm -e --nodeps java-1.7.0-openjdk-1.7.0.111-2.6.7.8.el7.x86_64</span><br><span class="line">[root@localhost software]# rpm -e --nodeps java-1.7.0-openjdk-headless-1.7.0.111-2.6.7.8.el7.x86_64</span><br><span class="line">[root@localhost software]# rpm -e --nodeps java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64</span><br><span class="line">[root@localhost software]# rpm -e --nodeps java-1.8.0-openjdk-headless-1.8.0.102-4.b14.el7.x86_64</span><br></pre></td></tr></table></figure>

<p>或者使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost jvm]# yum remove *openjdk*</span><br></pre></td></tr></table></figure>

<p>之后再次输入rpm -qa | grep java 查看卸载情况：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost software]# rpm -qa | grep java</span><br><span class="line">python-javapackages-3.4.1-11.el7.noarch</span><br><span class="line">javapackages-tools-3.4.1-11.el7.noarch</span><br></pre></td></tr></table></figure>

<h2 id="4、安装新的jdk"><a href="#4、安装新的jdk" class="headerlink" title="4、安装新的jdk"></a>4、安装新的jdk</h2><p>首先到jdk官网上下载你想要的jdk版本，下载完成之后将需要安装的jdk安装包放到Linux系统指定的文件夹下，并且命令进入该文件夹下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost software]# ll</span><br><span class="line">total 252664</span><br><span class="line">-rw-r--r--. 1 root root  11830603 Jun  9 06:43 alibaba-rocketmq-3.2.6.tar.gz</span><br><span class="line">-rw-r--r--. 1 root root  43399561 Jun  9 06:42 apache-activemq-5.11.1-bin.tar.gz</span><br><span class="line">-rwxrw-rw-. 1 root root 185540433 Apr 21 09:06 jdk-8u131-linux-x64.tar.gz</span><br><span class="line">-rw-r--r--. 1 root root   1547695 Jun  9 06:44 redis-3.2.9.tar.gz</span><br><span class="line">-rw-r--r--. 1 root root  16402010 Jun  9 06:40 zookeeper-3.4.5.tar.gz</span><br></pre></td></tr></table></figure>

<p>解压 jdk-8u131-linux-x64.tar.gz安装包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost software]# mkdir -p /usr/lib/jvm</span><br><span class="line">[root@localhost software]# tar -zxvf jdk-8u131-linux-x64.tar.gz -C /usr/lib/jvm</span><br></pre></td></tr></table></figure>

<h2 id="5、设置环境变量"><a href="#5、设置环境变量" class="headerlink" title="5、设置环境变量"></a>5、设置环境变量</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost software]# vim /etc/profile</span><br></pre></td></tr></table></figure>

<p>在最前面添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_131  </span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre  </span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib  </span><br><span class="line">export  PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure>

<h2 id="6、执行profile文件"><a href="#6、执行profile文件" class="headerlink" title="6、执行profile文件"></a>6、执行profile文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost software]# source /etc/profile</span><br></pre></td></tr></table></figure>

<p>这样可以使配置不用重启即可立即生效。</p>
<h2 id="7、检查新安装的jdk"><a href="#7、检查新安装的jdk" class="headerlink" title="7、检查新安装的jdk"></a>7、检查新安装的jdk</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost software]# java -version</span><br></pre></td></tr></table></figure>

<p>显示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java version &quot;1.8.0_131&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_131-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)</span><br></pre></td></tr></table></figure>

<p>到这里，整个安装过程就结束了。</p>
]]></content>
      <categories>
        <category>环境笔记篇</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习篇</title>
    <url>/2019/08/24/20190824-1/</url>
    <content><![CDATA[<p>to be continue</p>
]]></content>
      <categories>
        <category>springboot相关</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>micro service</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>笔记篇---集群启动shell脚本编写</title>
    <url>/2019/08/24/20190824/</url>
    <content><![CDATA[<h2 id="编写shell脚本启动zk集群or-redis集群"><a href="#编写shell脚本启动zk集群or-redis集群" class="headerlink" title="编写shell脚本启动zk集群or redis集群"></a>编写shell脚本启动zk集群or redis集群</h2><p>先去到伪zk集群的文件夹付所在目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch zkStartAll.sh</span><br><span class="line"></span><br><span class="line">vi ./zkStartAll.sh</span><br></pre></td></tr></table></figure>

<p>编写内容，其实就是依次进入文件夹启动单机实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/local/zookeeper1/bin</span><br><span class="line">./zkServer.sh start</span><br><span class="line">cd /usr/local/zookeeper2/bin</span><br><span class="line">./zkServer.sh start</span><br><span class="line">cd /usr/local/zookeeper3/bin</span><br><span class="line">./zkServer.sh start</span><br></pre></td></tr></table></figure>

<p>给文件授权，运行文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod u+wxr startAllZk.sh</span><br><span class="line"></span><br><span class="line">./startAllZk.sh</span><br></pre></td></tr></table></figure>

<p>结果就是集群成功启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@nginxslaver local]# ./startAllZk.sh</span><br><span class="line">JMX enabled by default</span><br><span class="line">Using config: /usr/local/zookeeper1/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br><span class="line">JMX enabled by default</span><br><span class="line">Using config: /usr/local/zookeeper2/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br><span class="line">JMX enabled by default</span><br><span class="line">Using config: /usr/local/zookeeper3/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure>

<p>redis伪集群启动方式类似</p>
<p>用来记录项目中需要配置但是容易忘记的一些记录</p>
<p>Slogan:学过几年技术，尘世间一枚不起眼的迷途小书童</p>
]]></content>
      <categories>
        <category>环境笔记篇</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>java提升篇--1(简单模拟NC服务端客户端通讯模型---RMI)</title>
    <url>/2019/08/05/20190805/</url>
    <content><![CDATA[<h2 id="第一节-RMI-Remote-Mothed-invoke-是什么？"><a href="#第一节-RMI-Remote-Mothed-invoke-是什么？" class="headerlink" title="第一节 RMI(Remote Mothed invoke)是什么？"></a>第一节 RMI(Remote Mothed invoke)是什么？</h2><p>一句话简单总结，我个人认为RMI就是RPC的java版本实现，当然他们本身底层也有很大的区别，比如序列化协议，网络通讯模型等等，今天我们就来简单的学习一下NC使用的RMI技术；</p>
<h2 id="第二节-RMI简单实现"><a href="#第二节-RMI简单实现" class="headerlink" title="第二节 RMI简单实现"></a>第二节 RMI简单实现</h2><p>废话不多说我们直接上代码，我这里区分了服务端与客户端，见下图:<br><img src="/2019/08/05/20190805/p1.png" alt="图p1"></p>
<center>图p1、整体概况</center>
- 服务端代码:        


<ol>
<li><p>HelloService接口存根</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package RPC;</span><br><span class="line"></span><br><span class="line">public interface HelloService &#123;</span><br><span class="line">	public String hello(String  name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上述接口的实现类HelloServiceImpl</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package RPC;</span><br><span class="line"></span><br><span class="line">public class HelloServiceImpl implements HelloService &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String hello(String name) &#123;</span><br><span class="line">		return name+&quot;:from hkserver!&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器启动接口类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package RPC;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public interface Server &#123;</span><br><span class="line">	</span><br><span class="line">    //启动服务器</span><br><span class="line">	public void start() ;</span><br><span class="line">	//停止服务器</span><br><span class="line">	public void stop();</span><br><span class="line">	//往服务容器中注册服务</span><br><span class="line">	public void register() throws ClassNotFoundException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器实现类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package RPC;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.TypeVariable;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.net.SocketAddress;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class ServerImpl implements Server &#123;</span><br><span class="line"></span><br><span class="line">	//注册中心用于处理</span><br><span class="line">	private Map&lt;String,Class&gt; serviceRegister = new HashMap&lt;String,Class&gt;();</span><br><span class="line">	</span><br><span class="line">	private static final int PORT = 9999;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//开放端口提供给client进行调用</span><br><span class="line">	@Override</span><br><span class="line">	public void start() &#123;</span><br><span class="line">		ServerSocket ss = null;</span><br><span class="line">		OutputStream os = null;</span><br><span class="line">		InputStream is = null;</span><br><span class="line">		Socket sk = null;</span><br><span class="line">		try &#123;</span><br><span class="line">			ss = new ServerSocket();</span><br><span class="line">			ss.bind(new InetSocketAddress(PORT));</span><br><span class="line">			sk = ss.accept();</span><br><span class="line">			//阻塞等待</span><br><span class="line">			is = sk.getInputStream();</span><br><span class="line">			ObjectInputStream ois = new ObjectInputStream(is);</span><br><span class="line">			String servicename = ois.readUTF();</span><br><span class="line">			String methodname = ois.readUTF();</span><br><span class="line">			Class[] paraTypes = (Class[])ois.readObject();</span><br><span class="line">			Object[] args= (Object[])ois.readObject();</span><br><span class="line">			Class serviceClass = serviceRegister.get(servicename);</span><br><span class="line">			@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">			Method invokeMethod = serviceClass.getMethod(methodname, paraTypes);</span><br><span class="line">			Object result = invokeMethod.invoke(serviceClass.newInstance(), args);</span><br><span class="line">			os = sk.getOutputStream();</span><br><span class="line">			ObjectOutputStream oos = new ObjectOutputStream(os);</span><br><span class="line">			oos.writeObject(result);</span><br><span class="line">			oos.flush();</span><br><span class="line">		&#125; catch (IOException e) &#123;</span><br><span class="line">			// TODO Auto-generated catch block</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">			// TODO Auto-generated catch block</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">			// TODO Auto-generated catch block</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; catch (SecurityException e) &#123;</span><br><span class="line">			// TODO Auto-generated catch block</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">			// TODO Auto-generated catch block</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">			// TODO Auto-generated catch block</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">			// TODO Auto-generated catch block</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; catch (InstantiationException e) &#123;</span><br><span class="line">			// TODO Auto-generated catch block</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;finally&#123;</span><br><span class="line">			if(os!=null)&#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					os.close();</span><br><span class="line">				&#125; catch (IOException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if(is!=null)&#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					is.close();</span><br><span class="line">				&#125; catch (IOException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			try &#123;</span><br><span class="line">				ss.close();</span><br><span class="line">				sk.close();</span><br><span class="line">			&#125; catch (IOException e) &#123;</span><br><span class="line">				// TODO Auto-generated catch block</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void stop() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void register() throws ClassNotFoundException &#123;</span><br><span class="line">		serviceRegister.put(&quot;HelloService&quot;, Class.forName(&quot;RPC.HelloServiceImpl&quot;));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>5.服务端main方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package RPC;</span><br><span class="line"></span><br><span class="line">public class ServerMain &#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		ServerImpl center = new ServerImpl();</span><br><span class="line">		try &#123;</span><br><span class="line">			center.register();</span><br><span class="line">			center.start();</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			// TODO Auto-generated catch block</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上我们服务端代码就完成了，简单而言就是通过一个main方法来启动我们的服务器，服务器启动的时候回向服务容器中注册我们的服务；（tips:这里我只是注册了一个服务实现类本身，如果结合之前我说过的日志记录以及事务处理等等，需要将服务实现类本身换成动态代理类）,我这里并没有实现服务器的多线程处理，如果需要同时为多个客户端服务，需要将sk = ss.accept();获取到的Socket对象放进一个新的Thread进行操作,也就是说每当有一个client连接到服务器，服务器就新建一个Thread对该客户端进行服务！NC服务端就是采用的这种方式，同步阻塞IO，伪异步线程池；</p>
<ul>
<li>客户端代码: </li>
</ul>
<ol>
<li><p>HClient</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package rpcclient;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">	// 获取代表服务端接口HelloService的动态代理对象</span><br><span class="line">	/*</span><br><span class="line">	 * @param</span><br><span class="line">	 */</span><br><span class="line">	public static &lt;T&gt; T getRemoteProxyObj(final String serviceName, final InetSocketAddress addr) throws ClassNotFoundException &#123;</span><br><span class="line">		final Class&lt;?&gt; forName = Class.forName(serviceName);</span><br><span class="line">		@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">		T newProxyInstance = (T) Proxy.newProxyInstance(forName.getClassLoader(), new Class[] &#123; forName &#125;,</span><br><span class="line">				new InvocationHandler() &#123;</span><br><span class="line">					@Override</span><br><span class="line">					public Object invoke(Object proxy, Method method, Object[] args) &#123;</span><br><span class="line">						Socket sk = new Socket();</span><br><span class="line">						OutputStream os = null;</span><br><span class="line">						InputStream is = null;</span><br><span class="line">						try&#123;</span><br><span class="line">					    sk.connect(addr);</span><br><span class="line">						os = sk.getOutputStream();</span><br><span class="line">						ObjectOutputStream oos = new ObjectOutputStream(os);</span><br><span class="line">						oos.writeUTF(forName.getSimpleName());</span><br><span class="line">						oos.writeUTF(method.getName());</span><br><span class="line">						oos.writeObject(method.getParameterTypes());</span><br><span class="line">						oos.writeObject(args);</span><br><span class="line">						oos.flush();</span><br><span class="line">						is = sk.getInputStream();</span><br><span class="line">						ObjectInputStream ois = new ObjectInputStream(is);</span><br><span class="line">						Object result = ois.readObject();</span><br><span class="line">						return result;</span><br><span class="line">						&#125;catch(Exception e)&#123;</span><br><span class="line">							return null;</span><br><span class="line">						&#125;finally&#123;</span><br><span class="line">							if(os!=null)&#123;</span><br><span class="line">								try &#123;</span><br><span class="line">									os.close();</span><br><span class="line">								&#125; catch (IOException e) &#123;</span><br><span class="line">									// TODO Auto-generated catch block</span><br><span class="line">									e.printStackTrace();</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">							if(is!=null)&#123;</span><br><span class="line">								try &#123;</span><br><span class="line">									is.close();</span><br><span class="line">								&#125; catch (IOException e) &#123;</span><br><span class="line">									// TODO Auto-generated catch block</span><br><span class="line">									e.printStackTrace();</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">							try &#123;</span><br><span class="line">								sk.close();</span><br><span class="line">							&#125; catch (IOException e) &#123;</span><br><span class="line">								// TODO Auto-generated catch block</span><br><span class="line">								e.printStackTrace();</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">		return newProxyInstance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) throws ClassNotFoundException&#123;</span><br><span class="line">        /*由于我这里演示是本机演示，没有通过ngrok外网映射，如果你打通了外网映射，你就可以实现你的对外服务器啦*/</span><br><span class="line">		/*HelloService remoteProxyObj = (HelloService)getRemoteProxyObj(&quot;rpcclient.HelloService&quot;,new InetSocketAddress(&quot;free.idcfengye.com&quot;,18034));*/</span><br><span class="line">        HelloService remoteProxyObj = (HelloService)getRemoteProxyObj(&quot;rpcclient.HelloService&quot;,new InetSocketAddress(&quot;127.0.0.1&quot;,9999));</span><br><span class="line">		String result = remoteProxyObj.hello(&quot;hahaha&quot;);</span><br><span class="line">		System.out.println(result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端服务存根HelloService(这也就解释了我们的NC的接口代码为什么要放在public下面，因为客户端需要这个类的信息)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package rpcclient;</span><br><span class="line"></span><br><span class="line">public interface HelloService &#123;</span><br><span class="line">	public String hello(String  name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>以上就是我们的客户端代码，我们客户端只放了一个服务方法存根HelloService，那么我们是如何做到向服务端发送请求的了？答案就是动态代理，我们在获取HelloService对象的时候其实就是对该接口的匿名内部类实现进行了动态代理，然后再通过动态代理去向服务端发送请求，服务端拿到我们的请求方法名和请求参数等等去容器中寻找实现类并将执行结果返回到客户端，至此一次完整的RMI请求结束；</p>
<h2 id="第三节-运行结果演示"><a href="#第三节-运行结果演示" class="headerlink" title="第三节 运行结果演示"></a>第三节 运行结果演示</h2><p>1、启动服务端main方法如下图：</p>
<p><img src="/2019/08/05/20190805/p2.png" alt="图p2"></p>
<center>图p2、服务启动等待客户端连接</center>

<p>2、启动客户端连接服务器，发出请求得到结果:</p>
<p><img src="/2019/08/05/20190805/p3.png" alt="图p3"></p>
<center>图p3、客户端启动结果</center>


<p>Slogan:学过几年技术，尘世间一枚不起眼的迷途小书童</p>
]]></content>
      <categories>
        <category>java高级篇</category>
      </categories>
      <tags>
        <tag>UAP</tag>
        <tag>java</tag>
        <tag>rmi</tag>
      </tags>
  </entry>
  <entry>
    <title>UAP应该知道的那些事儿--2(事务)</title>
    <url>/2019/07/24/20190724/</url>
    <content><![CDATA[<h2 id="第一节-事务是什么？隔离级别？传播属性？"><a href="#第一节-事务是什么？隔离级别？传播属性？" class="headerlink" title="第一节 事务是什么？隔离级别？传播属性？"></a>第一节 事务是什么？隔离级别？传播属性？</h2><p>开始本章内容之前，本人希望你已经看过了该系列的第一篇<a href="https://stevenhoukai.github.io/2019/07/17/20190719-2/">UAP应该知道的那些事儿–1</a>!这对你充分理解本章的内容起到了很大的作用，废话不多说我们开始本章的内容！<br>在平时的开发中，除了写代码，你一定每天都和各种各样的数据库打过交道，Nosql我这里先不说，起码mysql、oracle、sqlserver这些常见的关系数据库你一定不陌生，那么用数据库有一个名词你是一定要了解的，那就是事务(分布式事务今天这里先不谈)，啥是事务？</p>
<p>数据库事务(简称:事务)是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。<br>并非任意的对数据库的操作序列都是数据库事务。数据库事务拥有以下四个特性，习惯上被称之为ACID特性。</p>
<ul>
<li>原子性(Atomicity):事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li>
<li>一致性(Consistency):事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。</li>
<li>隔离性(Isolation):多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li>
<li>持久性(Durability):已被提交的事务对数据库的修改应该永久保存在数据库中。</li>
</ul>
<p>以上是官方对于数据库事务的一个定义，我这里也不对这些东西做解释了，自行去了解一下这些概念</p>
<p><img src="/2019/07/24/20190724/p1.png" alt="图p1"></p>
<center>图p8</center>

<p>spring七个事物传播属性：</p>
<ul>
<li>PROPAGATION_REQUIRED -支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。</li>
<li>PROPAGATION_SUPPORTS -支持当前事务，如果当前没有事务，就以非事务方式执行。</li>
<li>PROPAGATION_MANDATORY -支持当前事务，如果当前没有事务，就抛出异常。</li>
<li>PROPAGATION_REQUIRES_NEW -新建事务，如果当前存在事务，把当前事务挂起。</li>
<li>PROPAGATION_NOT_SUPPORTED -以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li>PROPAGATION_NEVER -以非事务方式执行，如果当前存在事务，则抛出异常。</li>
<li>PROPAGATION_NESTED -如果当前存在事务则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。</li>
</ul>
<p>以上这些不是本章的重点，看一看了解一下先即可。</p>
<h2 id="第二节-NC用的什么隔离级别？支持哪几种传播属性？"><a href="#第二节-NC用的什么隔离级别？支持哪几种传播属性？" class="headerlink" title="第二节 NC用的什么隔离级别？支持哪几种传播属性？"></a>第二节 NC用的什么隔离级别？支持哪几种传播属性？</h2><p>ok，经过上一节介绍应该对事务有了一个大致的了解了，那么回来我们说说NC，NC支持Oracle和Sqlserver<br>(这里多说一句，通过修改源码可以支持db2以及mysql，本人已亲证)，其实这两个数据库默认的隔离级别都是读已提交(read commit)，也就是说一个事务只能读取到另外一个事务commit了的数据，当然你可以根据你项目的需求进行调整，<br>上一章我强调过了，从源码层面分析了我们NC其实是只支持两种传播属性：Requires和equiresNew<br>，见下图:</p>
<p><img src="/2019/07/24/20190724/p2.png" alt="图p1"></p>
<center>图p1</center>


<h2 id="第三节-本章重点：如何让你的代码使用到事务"><a href="#第三节-本章重点：如何让你的代码使用到事务" class="headerlink" title="第三节 本章重点：如何让你的代码使用到事务!!!"></a>第三节 本章重点：如何让你的代码使用到事务!!!</h2><p>不用多说这是本章的重点，在说本节内容之前，先提一个名词—&gt;jdk动态代理，不知诸位对这个东东有没有了解过，没了解过的建议去百度一下，我这里直接上代码:<br>1、先有一个接口TargetItf：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdkdtproxy;</span><br><span class="line"></span><br><span class="line">public interface TargetItf &#123;</span><br><span class="line">	</span><br><span class="line">	public void method1();</span><br><span class="line">	</span><br><span class="line">	public String method2();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、对该接口有一个实现类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdkdtproxy;</span><br><span class="line"></span><br><span class="line">public class Target implements TargetItf &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void method1() &#123;</span><br><span class="line">		System.out.println(&quot;method invoked&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String method2() &#123;</span><br><span class="line">		System.out.println(&quot;method invoked&quot;);</span><br><span class="line">		return &quot;method2 result&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、产生动态代理并通过动态代理调用方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package jdkdtproxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @ClassName: TargetTest </span><br><span class="line"> * @Description: TODO(这里用一句话描述这个类的作用) </span><br><span class="line"> * @author steven </span><br><span class="line"> * @date 2018年11月24日 上午9:53:24 </span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class TargetTest &#123;</span><br><span class="line">	</span><br><span class="line">	@Test</span><br><span class="line">	public void test1()&#123;</span><br><span class="line">		</span><br><span class="line">		final Target target = new Target();</span><br><span class="line">		TargetItf newProxyInstance = (TargetItf)Proxy.</span><br><span class="line">				newProxyInstance(target.getClass().getClassLoader(), </span><br><span class="line">						target.getClass().getInterfaces(), </span><br><span class="line">						new InvocationHandler() &#123;</span><br><span class="line">					@Override</span><br><span class="line">					public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">						System.out.println(&quot;invoke before&quot;);</span><br><span class="line">						Object invokeResult = method.invoke(target, args);</span><br><span class="line">						System.out.println(&quot;invoke after&quot;);</span><br><span class="line">						return invokeResult;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">		newProxyInstance.method1();</span><br><span class="line">		String method2 = newProxyInstance.method2();</span><br><span class="line">		System.out.println(method2);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">invoke before</span><br><span class="line">method invoked</span><br><span class="line">invoke after</span><br><span class="line">invoke before</span><br><span class="line">method invoked</span><br><span class="line">invoke after</span><br><span class="line">method2 result</span><br></pre></td></tr></table></figure>

<p>是不是觉得很神奇？竟然在你的目标方法内容前后都进行了操作!没错，这就是动态代理，它能够对你的目标对象进行拦截切面，而且我们NC的服务端容器就是完全依赖了这个东东，所有通过upm文件中写了cmt属性的接口在服务容器中都是一个动态代理对象而不是实现类本身，现在回应上一章的内容，你如果通过了NcLocator来获取到了一个对象，然后使用这个代理对象去调用对应的服务方法，然后的东西你明白了吗？来看看下面两张我精心挑选的图：<br><img src="/2019/07/24/20190724/p3.png" alt="p6"></p>
<center>图p2、Requires属性的处理方式</center>

<p><img src="/2019/07/24/20190724/p4.png" alt="p6"></p>
<center>图p3、RequiresNew属性的处理方式</center>
现在是不是清晰了许多，我来总结一下：服务启动，会在内存中产生一个Locator容器keyvalue形式,key是接口类名称，value就是实现类的动态代理对象，通过上图很明显的看到，如果你想让你的代码能够使用到事务以及事务的传播属性，那你一定要通过Nclocator进行对象的获取，因为事务的开启与关闭以及服务方法调用前后的日志记录都是通过代理对象来实现的！

<p>由于篇幅原因，Requires和RequiresNew具体区别我们下一张详细论述！！！,下一章我们通过实例来详细分析如何让你的代码能够使用到事务以及事务的传播属性。</p>
<p>Slogan:技术界一枚不起眼的迷途小书童</p>
]]></content>
      <categories>
        <category>UAP框架</category>
      </categories>
      <tags>
        <tag>UAP</tag>
        <tag>ufida NC</tag>
      </tags>
  </entry>
  <entry>
    <title>UAP应该知道的那些事儿--1(通讯模型)</title>
    <url>/2019/07/19/20190719-2/</url>
    <content><![CDATA[<h2 id="第一节-NCLocator了解吗-客户端与服务端如何进行通讯"><a href="#第一节-NCLocator了解吗-客户端与服务端如何进行通讯" class="headerlink" title="第一节 NCLocator了解吗,客户端与服务端如何进行通讯"></a>第一节 NCLocator了解吗,客户端与服务端如何进行通讯</h2><p>在平时的开发中，如果我们想要在客户端调用服务端部署好的服务，一般我们是这样在客户端通过以下方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IxxxService service = NCLocator.getInstance().lookup(IxxxService.class);</span><br></pre></td></tr></table></figure>

<p>获取到service这样一个接口对象，然后通过这个service调用对应的method就能实现与服务端的通讯，但是诸位有没有想过为什么这样就可以进行client到server的网络IO通讯，其实这里就是通过了jdk的动态代理来实现的，jdk动态代理是javase高级知识点，没接触过的可以去看看相关知识点，在java高级知识介绍中我会用一篇日记来仔细讲解，这里就不做详细介绍。继续讲我们在客户端获取到的service对象就是一个IxxxService接口的动态代理对象，这里看一下动态代理是如何获取的，如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Proxy.newProxyInstance(classloader, interfaces, InvocationHanddler);</span><br></pre></td></tr></table></figure>

<p><img src="/2019/07/19/20190719-2/p8.png" alt="图p8"></p>
<center>图p8</center>

<p>有没有发现上图中h=RemoteInvocationHandler很眼熟，这就是一个InvocationHanddler的实现方式<br>这里我通过下面一个通用接口来进行详细说明:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IBillcodeManage lookup = NCLocator.getInstance().lookup(IBillcodeManage.class);</span><br></pre></td></tr></table></figure>

<p>从上图我们看到在客户端拿到的lookup对象确实就是一个动态代理类，并非对象本身那么简单，换句话说我们可以理解，<br>NCLocator.getInstance()其实就是获取到客户端jvm中的一个hashmap容器，<br>key是IxxxService.class,value就是这个接口类的一个动态代理实例，<br>这样说或许会比较好容易理解，但事实上也确实如此，只是具体实现上面会复杂很多，好了<br>接下来就去看看这个客户端获取到的动态代理是如何往服务端发送请求的</p>
<p><img src="/2019/07/19/20190719-2/p2.png" alt="图p2"></p>
<center>图p2</center>

<p><img src="/2019/07/19/20190719-2/p3.png" alt="图p3"></p>
<center>图p3</center>

<p><img src="/2019/07/19/20190719-2/p4.png" alt="图p4"></p>
<center>图p4</center>

<p>看到这里是不是有种拨开云雾的赶脚，没错，你没有眼花，我们的NC客户端采用的就是最原始最古老的BIO通讯模型<br>，不是说这个BIO模型不好，而是因为他存在有很大的局限性，比如同步、阻塞、无法处理高并发访问等，但是用在<br>erp系统中我觉得是够用的，这里我在整理总结一下当你使用客户端接口的动态代理调用方法时具体发生了什么：</p>
<ul>
<li>1、进入RemoteInvocationHandler的invoke方法</li>
<li>2、获取调用的方法名称和参数</li>
<li>3、Tcp三次握手与服务端建立连接</li>
<li>4、网络io发送调用方法的相关信息和参数信息到服务端</li>
<li>5、同步等待服务端返回结果（这里就是一个所谓同步调用的概念）</li>
</ul>
<p>这里再多解释一句，NC服务端启动的时候会有一个ServerSocket.accept()的方法专门用来处理客户端<br>发送来的连接请求，这也是BIO模型的精髓所在&lt;同步与阻塞&gt;。<br>这里还有非常一个值得一提的地方见下图，客户端并不是无限制的创建Socket，而是设计了一个Socket连接池来进行Socket复用，原理类似数据库连接池;</p>
<p><img src="/2019/07/19/20190719-2/p5.png" alt="图p5"></p>
<center>图p5</center>


<p><code>Socket s = (Socket)sq.poll();</code><br>这就是通过有界阻塞队列来实现Socket容器。</p>
<h2 id="第二节-事务与日志-NC系统的事务型组件"><a href="#第二节-事务与日志-NC系统的事务型组件" class="headerlink" title="第二节 事务与日志(NC系统的事务型组件)"></a>第二节 事务与日志(NC系统的事务型组件)</h2><p>上一节我们讲到了客户端接口类的动态代理发送请求到服务端，那么我们NC的服务端又是如何处理请求，<br>又是如何将请求发送回客户端的了？我们慢慢来讲，跟第一章一样，我们先通过：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">IBillcodeManage lookup = NCLocator.getInstance().lookup(IBillcodeManage.class);</span><br></pre></td></tr></table></figure>

<p>在服务端获取到lookup的动态代理对象，注意了这里我们是在服务端(private)获取了，不是在客户端(client)了哈,重要的事情说三遍:</p>
<ul>
<li>不是在客户端(client)</li>
<li>不是在客户端(client)</li>
<li>不是在客户端(client)</li>
</ul>
<p>见下图:</p>
<p><img src="/2019/07/19/20190719-2/p1.png" alt="图p1"></p>
<center>图p1</center>


<p>是不是发现了异样，同样的方法在客户端和服务端拿到的lookup对象是完全不一样的！因为服务端获取到的是具体实现类的动态代理，是要去实实在在做事情的了，这也就解释了NC是分服务端容器和客户端两大容器的！见下图：</p>
<p><img src="/2019/07/19/20190719-2/p9.png" alt="图p2"></p>
<center>图p2</center>


<p>有没有，看了图p2是不是就感觉发现了新大陆，这就是NC所谓的事务型组件的设计原理:根据接口设计中的方法名后缀来进行判断决定采用何种事务的传播属性，另外强调一下<br>NC的事务传播属性并没有很多种，从源码层面来看NC只支持最基本的Requires和equiresNew，并非像UAP红皮书中说的还支持mandatory、support以及never，至少我在源码层面是没有发现支持<br>与spring的7大事务传播属性相差甚远，至于这两种传播属性具体有什么区别，我会在我的第二篇UAP文章中进行剖析，好了这里我再总结一下服务端接收到客户端请求后都做了一些什么操作，见图p11、p12、p13</p>
<ul>
<li>1、服务端bioserver开启SocketServer等待客户端请求到来</li>
<li>2、服务端接受到请求后解析请求参数，通过servicename去服务端的服务实现类动态代理容器中寻找对应的服务类动态代理</li>
<li>3、最后通过反射机制，mothod.invoke(obj)来实现事务控制以及日志记录以及实际的业务处理</li>
<li>4、返回结果到客户端，至此一次bio完整的请求通讯结束</li>
</ul>
<p><img src="/2019/07/19/20190719-2/p11.png" alt="图p11"></p>
<center>图p11</center>

<p><img src="/2019/07/19/20190719-2/p12.png" alt="图p12"></p>
<center>图p12</center>

<p><img src="/2019/07/19/20190719-2/p13.png" alt="图p13"></p>
<center>图p13</center>


<h2 id="第三节-系统是如何保证一次请求中的多次数据库交互拿到的是同一个Connection"><a href="#第三节-系统是如何保证一次请求中的多次数据库交互拿到的是同一个Connection" class="headerlink" title="第三节 系统是如何保证一次请求中的多次数据库交互拿到的是同一个Connection"></a>第三节 系统是如何保证一次请求中的多次数据库交互拿到的是同一个Connection</h2><p>其实这是一个扩展思考的问题，当时也是因为这个事务问题笨人就多思考了一点，就是说你如果要保证事务有效，<br>前提条件你必须让你的一次请求过程中拿到的conn是同一个对象对吧，<br>这个问题我并不想描述的太多，因为这是一个很基础的并发编程问题–&gt;如何让一个变量(conn)成为一个线程的独享变量，<br>从而达到解决线程安全的问题，这里的解决方案就是ThreadLocal;<br>我提供几个关键截图,朋友们可以自行去了解一下ThreadLocal的原理再回过头来就看这几行代码，<br>就能很好的理解其设计原理</p>
<p><img src="/2019/07/19/20190719-2/p6.png" alt="p6"></p>
<center>图p6</center>

<p><img src="/2019/07/19/20190719-2/p7.png" alt="p7"></p>
<center>图p7</center>

<p>上图中的connRef对象就是一个ThreadLocal变量。用于获取当前线程的conn，但是conn对象并非是存在这个变量中的，而是存储在每一个Thread的一个ThreadLocalMap的变量中的，这个ThreadLocalMap中key就是connRef的softreference形式，value就是conn对象，这里有点绕，所以我的建议是先了解原理再看代码；</p>
<p>前前后后写了三四个小时，终于写完了本人的第一篇博文，后续还会更新更多…</p>
<p>Slogan:技术界一枚不起眼的迷途小书童</p>
]]></content>
      <categories>
        <category>UAP框架</category>
      </categories>
      <tags>
        <tag>UAP</tag>
        <tag>ufida NC</tag>
      </tags>
  </entry>
</search>
